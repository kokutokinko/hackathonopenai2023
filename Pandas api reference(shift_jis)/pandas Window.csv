ƒ‰ƒCƒuƒ‰ƒŠ–¼,Í,ß,“à—e
Pandas,Window,pandas.core.window.rolling.Rolling.count,"pandas.core.window.rolling.Rolling.count#Rolling.count(numeric_only=False)[source]#Calculate the rolling count of non NaN observations.Parameters:numeric_onlybool, default FalseInclude only float, int, boolean columns.New in version 1.5.0.Returns:Series or DataFrameReturn type is the same as the original object withnp.float64dtype.See alsopandas.Series.rollingCalling rolling with Series data.pandas.DataFrame.rollingCalling rolling with DataFrames.pandas.Series.countAggregating count for Series.pandas.DataFrame.countAggregating count for DataFrame.Examples>>>s=pd.Series([2,3,np.nan,10])>>>s.rolling(2).count()0    NaN1    2.02    1.03    1.0dtype: float64>>>s.rolling(3).count()0    NaN1    NaN2    2.03    2.0dtype: float64>>>s.rolling(4).count()0    NaN1    NaN2    NaN3    3.0dtype: float64"
Pandas,Window,pandas.core.window.rolling.Rolling.sum,"pandas.core.window.rolling.Rolling.sum#Rolling.sum(numeric_only=False,engine=None,engine_kwargs=None)[source]#Calculate the rolling sum.Parameters:numeric_onlybool, default FalseInclude only float, int, boolean columns.New in version 1.5.0.enginestr, default None'cython': Runs the operation through C-extensions from cython.'numba': Runs the operation through JIT compiled code from numba.None: Defaults to'cython'or globally settingcompute.use_numbaNew in version 1.3.0.engine_kwargsdict, default NoneFor'cython'engine, there are no acceptedengine_kwargsFor'numba'engine, the engine can acceptnopython,nogilandparalleldictionary keys. The values must either beTrueorFalse. The defaultengine_kwargsfor the'numba'engine is{'nopython':True,'nogil':False,'parallel':False}New in version 1.3.0.Returns:Series or DataFrameReturn type is the same as the original object withnp.float64dtype.See alsopandas.Series.rollingCalling rolling with Series data.pandas.DataFrame.rollingCalling rolling with DataFrames.pandas.Series.sumAggregating sum for Series.pandas.DataFrame.sumAggregating sum for DataFrame.NotesSeeNumba engineandNumba (JIT compilation)for extended documentation and performance considerations for the Numba engine.Examples>>>s=pd.Series([1,2,3,4,5])>>>s0    11    22    33    44    5dtype: int64>>>s.rolling(3).sum()0     NaN1     NaN2     6.03     9.04    12.0dtype: float64>>>s.rolling(3,center=True).sum()0     NaN1     6.02     9.03    12.04     NaNdtype: float64For DataFrame, each sum is computed column-wise.>>>df=pd.DataFrame({""A"":s,""B"":s**2})>>>dfA   B0  1   11  2   42  3   93  4  164  5  25>>>df.rolling(3).sum()A     B0   NaN   NaN1   NaN   NaN2   6.0  14.03   9.0  29.04  12.0  50.0"
Pandas,Window,pandas.core.window.rolling.Rolling.mean,"pandas.core.window.rolling.Rolling.mean#Rolling.mean(numeric_only=False,engine=None,engine_kwargs=None)[source]#Calculate the rolling mean.Parameters:numeric_onlybool, default FalseInclude only float, int, boolean columns.New in version 1.5.0.enginestr, default None'cython': Runs the operation through C-extensions from cython.'numba': Runs the operation through JIT compiled code from numba.None: Defaults to'cython'or globally settingcompute.use_numbaNew in version 1.3.0.engine_kwargsdict, default NoneFor'cython'engine, there are no acceptedengine_kwargsFor'numba'engine, the engine can acceptnopython,nogilandparalleldictionary keys. The values must either beTrueorFalse. The defaultengine_kwargsfor the'numba'engine is{'nopython':True,'nogil':False,'parallel':False}New in version 1.3.0.Returns:Series or DataFrameReturn type is the same as the original object withnp.float64dtype.See alsopandas.Series.rollingCalling rolling with Series data.pandas.DataFrame.rollingCalling rolling with DataFrames.pandas.Series.meanAggregating mean for Series.pandas.DataFrame.meanAggregating mean for DataFrame.NotesSeeNumba engineandNumba (JIT compilation)for extended documentation and performance considerations for the Numba engine.ExamplesThe below examples will show rolling mean calculations with window sizes of
two and three, respectively.>>>s=pd.Series([1,2,3,4])>>>s.rolling(2).mean()0    NaN1    1.52    2.53    3.5dtype: float64>>>s.rolling(3).mean()0    NaN1    NaN2    2.03    3.0dtype: float64"
Pandas,Window,pandas.core.window.rolling.Rolling.median,"pandas.core.window.rolling.Rolling.median#Rolling.median(numeric_only=False,engine=None,engine_kwargs=None)[source]#Calculate the rolling median.Parameters:numeric_onlybool, default FalseInclude only float, int, boolean columns.New in version 1.5.0.enginestr, default None'cython': Runs the operation through C-extensions from cython.'numba': Runs the operation through JIT compiled code from numba.None: Defaults to'cython'or globally settingcompute.use_numbaNew in version 1.3.0.engine_kwargsdict, default NoneFor'cython'engine, there are no acceptedengine_kwargsFor'numba'engine, the engine can acceptnopython,nogilandparalleldictionary keys. The values must either beTrueorFalse. The defaultengine_kwargsfor the'numba'engine is{'nopython':True,'nogil':False,'parallel':False}New in version 1.3.0.Returns:Series or DataFrameReturn type is the same as the original object withnp.float64dtype.See alsopandas.Series.rollingCalling rolling with Series data.pandas.DataFrame.rollingCalling rolling with DataFrames.pandas.Series.medianAggregating median for Series.pandas.DataFrame.medianAggregating median for DataFrame.NotesSeeNumba engineandNumba (JIT compilation)for extended documentation and performance considerations for the Numba engine.ExamplesCompute the rolling median of a series with a window size of 3.>>>s=pd.Series([0,1,2,3,4])>>>s.rolling(3).median()0    NaN1    NaN2    1.03    2.04    3.0dtype: float64"
Pandas,Window,pandas.core.window.rolling.Rolling.var,"pandas.core.window.rolling.Rolling.var#Rolling.var(ddof=1,numeric_only=False,engine=None,engine_kwargs=None)[source]#Calculate the rolling variance.Parameters:ddofint, default 1Delta Degrees of Freedom. The divisor used in calculations
isN-ddof, whereNrepresents the number of elements.numeric_onlybool, default FalseInclude only float, int, boolean columns.New in version 1.5.0.enginestr, default None'cython': Runs the operation through C-extensions from cython.'numba': Runs the operation through JIT compiled code from numba.None: Defaults to'cython'or globally settingcompute.use_numbaNew in version 1.4.0.engine_kwargsdict, default NoneFor'cython'engine, there are no acceptedengine_kwargsFor'numba'engine, the engine can acceptnopython,nogilandparalleldictionary keys. The values must either beTrueorFalse. The defaultengine_kwargsfor the'numba'engine is{'nopython':True,'nogil':False,'parallel':False}New in version 1.4.0.Returns:Series or DataFrameReturn type is the same as the original object withnp.float64dtype.See alsonumpy.varEquivalent method for NumPy array.pandas.Series.rollingCalling rolling with Series data.pandas.DataFrame.rollingCalling rolling with DataFrames.pandas.Series.varAggregating var for Series.pandas.DataFrame.varAggregating var for DataFrame.NotesThe defaultddofof 1 used inSeries.var()is different
than the defaultddofof 0 innumpy.var().A minimum of one period is required for the rolling calculation.Examples>>>s=pd.Series([5,5,6,7,5,5,5])>>>s.rolling(3).var()0         NaN1         NaN2    0.3333333    1.0000004    1.0000005    1.3333336    0.000000dtype: float64"
Pandas,Window,pandas.core.window.rolling.Rolling.std,"pandas.core.window.rolling.Rolling.std#Rolling.std(ddof=1,numeric_only=False,engine=None,engine_kwargs=None)[source]#Calculate the rolling standard deviation.Parameters:ddofint, default 1Delta Degrees of Freedom. The divisor used in calculations
isN-ddof, whereNrepresents the number of elements.numeric_onlybool, default FalseInclude only float, int, boolean columns.New in version 1.5.0.enginestr, default None'cython': Runs the operation through C-extensions from cython.'numba': Runs the operation through JIT compiled code from numba.None: Defaults to'cython'or globally settingcompute.use_numbaNew in version 1.4.0.engine_kwargsdict, default NoneFor'cython'engine, there are no acceptedengine_kwargsFor'numba'engine, the engine can acceptnopython,nogilandparalleldictionary keys. The values must either beTrueorFalse. The defaultengine_kwargsfor the'numba'engine is{'nopython':True,'nogil':False,'parallel':False}New in version 1.4.0.Returns:Series or DataFrameReturn type is the same as the original object withnp.float64dtype.See alsonumpy.stdEquivalent method for NumPy array.pandas.Series.rollingCalling rolling with Series data.pandas.DataFrame.rollingCalling rolling with DataFrames.pandas.Series.stdAggregating std for Series.pandas.DataFrame.stdAggregating std for DataFrame.NotesThe defaultddofof 1 used inSeries.std()is different
than the defaultddofof 0 innumpy.std().A minimum of one period is required for the rolling calculation.Examples>>>s=pd.Series([5,5,6,7,5,5,5])>>>s.rolling(3).std()0         NaN1         NaN2    0.5773503    1.0000004    1.0000005    1.1547016    0.000000dtype: float64"
Pandas,Window,pandas.core.window.rolling.Rolling.min,"pandas.core.window.rolling.Rolling.min#Rolling.min(numeric_only=False,engine=None,engine_kwargs=None)[source]#Calculate the rolling minimum.Parameters:numeric_onlybool, default FalseInclude only float, int, boolean columns.New in version 1.5.0.enginestr, default None'cython': Runs the operation through C-extensions from cython.'numba': Runs the operation through JIT compiled code from numba.None: Defaults to'cython'or globally settingcompute.use_numbaNew in version 1.3.0.engine_kwargsdict, default NoneFor'cython'engine, there are no acceptedengine_kwargsFor'numba'engine, the engine can acceptnopython,nogilandparalleldictionary keys. The values must either beTrueorFalse. The defaultengine_kwargsfor the'numba'engine is{'nopython':True,'nogil':False,'parallel':False}New in version 1.3.0.Returns:Series or DataFrameReturn type is the same as the original object withnp.float64dtype.See alsopandas.Series.rollingCalling rolling with Series data.pandas.DataFrame.rollingCalling rolling with DataFrames.pandas.Series.minAggregating min for Series.pandas.DataFrame.minAggregating min for DataFrame.NotesSeeNumba engineandNumba (JIT compilation)for extended documentation and performance considerations for the Numba engine.ExamplesPerforming a rolling minimum with a window size of 3.>>>s=pd.Series([4,3,5,2,6])>>>s.rolling(3).min()0    NaN1    NaN2    3.03    2.04    2.0dtype: float64"
Pandas,Window,pandas.core.window.rolling.Rolling.max,"pandas.core.window.rolling.Rolling.max#Rolling.max(numeric_only=False,*args,engine=None,engine_kwargs=None,**kwargs)[source]#Calculate the rolling maximum.Parameters:numeric_onlybool, default FalseInclude only float, int, boolean columns.New in version 1.5.0.enginestr, default None'cython': Runs the operation through C-extensions from cython.'numba': Runs the operation through JIT compiled code from numba.None: Defaults to'cython'or globally settingcompute.use_numbaNew in version 1.3.0.engine_kwargsdict, default NoneFor'cython'engine, there are no acceptedengine_kwargsFor'numba'engine, the engine can acceptnopython,nogilandparalleldictionary keys. The values must either beTrueorFalse. The defaultengine_kwargsfor the'numba'engine is{'nopython':True,'nogil':False,'parallel':False}New in version 1.3.0.Returns:Series or DataFrameReturn type is the same as the original object withnp.float64dtype.See alsopandas.Series.rollingCalling rolling with Series data.pandas.DataFrame.rollingCalling rolling with DataFrames.pandas.Series.maxAggregating max for Series.pandas.DataFrame.maxAggregating max for DataFrame.NotesSeeNumba engineandNumba (JIT compilation)for extended documentation and performance considerations for the Numba engine.Examples>>>ser=pd.Series([1,2,3,4])>>>ser.rolling(2).max()0    NaN1    2.02    3.03    4.0dtype: float64"
Pandas,Window,pandas.core.window.rolling.Rolling.corr,"pandas.core.window.rolling.Rolling.corr#Rolling.corr(other=None,pairwise=None,ddof=1,numeric_only=False)[source]#Calculate the rolling correlation.Parameters:otherSeries or DataFrame, optionalIf not supplied then will default to self and produce pairwise
output.pairwisebool, default NoneIf False then only matching columns between self and other will be
used and the output will be a DataFrame.
If True then all pairwise combinations will be calculated and the
output will be a MultiIndexed DataFrame in the case of DataFrame
inputs. In the case of missing elements, only complete pairwise
observations will be used.ddofint, default 1Delta Degrees of Freedom. The divisor used in calculations
isN-ddof, whereNrepresents the number of elements.numeric_onlybool, default FalseInclude only float, int, boolean columns.New in version 1.5.0.Returns:Series or DataFrameReturn type is the same as the original object withnp.float64dtype.See alsocovSimilar method to calculate covariance.numpy.corrcoefNumPy Pearsonfs correlation calculation.pandas.Series.rollingCalling rolling with Series data.pandas.DataFrame.rollingCalling rolling with DataFrames.pandas.Series.corrAggregating corr for Series.pandas.DataFrame.corrAggregating corr for DataFrame.NotesThis function uses Pearsonfs definition of correlation
(https://en.wikipedia.org/wiki/Pearson_correlation_coefficient).Whenotheris not specified, the output will be self correlation (e.g.
all 1fs), except forDataFrameinputs withpairwiseset toTrue.Function will returnNaNfor correlations of equal valued sequences;
this is the result of a 0/0 division error.Whenpairwiseis set toFalse, only matching columns betweenselfandotherwill be used.Whenpairwiseis set toTrue, the output will be a MultiIndex DataFrame
with the original index on the first level, and theotherDataFrame
columns on the second level.In the case of missing elements, only complete pairwise observations
will be used.ExamplesThe below example shows a rolling calculation with a window size of
four matching the equivalent function call usingnumpy.corrcoef().>>>v1=[3,3,3,5,8]>>>v2=[3,4,4,4,8]>>># numpy returns a 2X2 array, the correlation coefficient>>># is the number at entry [0][1]>>>print(f""{np.corrcoef(v1[:-1],v2[:-1])[0][1]:.6f}"")0.333333>>>print(f""{np.corrcoef(v1[1:],v2[1:])[0][1]:.6f}"")0.916949>>>s1=pd.Series(v1)>>>s2=pd.Series(v2)>>>s1.rolling(4).corr(s2)0         NaN1         NaN2         NaN3    0.3333334    0.916949dtype: float64The below example shows a similar rolling calculation on a
DataFrame using the pairwise option.>>>matrix=np.array([[51.,35.],[49.,30.],[47.,32.],[46.,31.],[50.,36.]])>>>print(np.corrcoef(matrix[:-1,0],matrix[:-1,1]).round(7))[[1.         0.6263001][0.6263001  1.       ]]>>>print(np.corrcoef(matrix[1:,0],matrix[1:,1]).round(7))[[1.         0.5553681][0.5553681  1.        ]]>>>df=pd.DataFrame(matrix,columns=['X','Y'])>>>dfX     Y0  51.0  35.01  49.0  30.02  47.0  32.03  46.0  31.04  50.0  36.0>>>df.rolling(4).corr(pairwise=True)X         Y0 X       NaN       NaNY       NaN       NaN1 X       NaN       NaNY       NaN       NaN2 X       NaN       NaNY       NaN       NaN3 X  1.000000  0.626300Y  0.626300  1.0000004 X  1.000000  0.555368Y  0.555368  1.000000"
Pandas,Window,pandas.core.window.rolling.Rolling.cov,"pandas.core.window.rolling.Rolling.cov#Rolling.cov(other=None,pairwise=None,ddof=1,numeric_only=False)[source]#Calculate the rolling sample covariance.Parameters:otherSeries or DataFrame, optionalIf not supplied then will default to self and produce pairwise
output.pairwisebool, default NoneIf False then only matching columns between self and other will be
used and the output will be a DataFrame.
If True then all pairwise combinations will be calculated and the
output will be a MultiIndexed DataFrame in the case of DataFrame
inputs. In the case of missing elements, only complete pairwise
observations will be used.ddofint, default 1Delta Degrees of Freedom. The divisor used in calculations
isN-ddof, whereNrepresents the number of elements.numeric_onlybool, default FalseInclude only float, int, boolean columns.New in version 1.5.0.Returns:Series or DataFrameReturn type is the same as the original object withnp.float64dtype.See alsopandas.Series.rollingCalling rolling with Series data.pandas.DataFrame.rollingCalling rolling with DataFrames.pandas.Series.covAggregating cov for Series.pandas.DataFrame.covAggregating cov for DataFrame.Examples>>>ser1=pd.Series([1,2,3,4])>>>ser2=pd.Series([1,4,5,8])>>>ser1.rolling(2).cov(ser2)0    NaN1    1.52    0.53    1.5dtype: float64"
Pandas,Window,pandas.core.window.rolling.Rolling.skew,"pandas.core.window.rolling.Rolling.skew#Rolling.skew(numeric_only=False)[source]#Calculate the rolling unbiased skewness.Parameters:numeric_onlybool, default FalseInclude only float, int, boolean columns.New in version 1.5.0.Returns:Series or DataFrameReturn type is the same as the original object withnp.float64dtype.See alsoscipy.stats.skewThird moment of a probability density.pandas.Series.rollingCalling rolling with Series data.pandas.DataFrame.rollingCalling rolling with DataFrames.pandas.Series.skewAggregating skew for Series.pandas.DataFrame.skewAggregating skew for DataFrame.NotesA minimum of three periods is required for the rolling calculation.Examples>>>ser=pd.Series([1,5,2,7,12,6])>>>ser.rolling(3).skew().round(6)0         NaN1         NaN2    1.2933433   -0.5855834    0.0000005    1.545393dtype: float64"
Pandas,Window,pandas.core.window.rolling.Rolling.kurt,"pandas.core.window.rolling.Rolling.kurt#Rolling.kurt(numeric_only=False)[source]#Calculate the rolling Fisherfs definition of kurtosis without bias.Parameters:numeric_onlybool, default FalseInclude only float, int, boolean columns.New in version 1.5.0.Returns:Series or DataFrameReturn type is the same as the original object withnp.float64dtype.See alsoscipy.stats.kurtosisReference SciPy method.pandas.Series.rollingCalling rolling with Series data.pandas.DataFrame.rollingCalling rolling with DataFrames.pandas.Series.kurtAggregating kurt for Series.pandas.DataFrame.kurtAggregating kurt for DataFrame.NotesA minimum of four periods is required for the calculation.ExamplesThe example below will show a rolling calculation with a window size of
four matching the equivalent function call usingscipy.stats.>>>arr=[1,2,3,4,999]>>>importscipy.stats>>>print(f""{scipy.stats.kurtosis(arr[:-1],bias=False):.6f}"")-1.200000>>>print(f""{scipy.stats.kurtosis(arr[1:],bias=False):.6f}"")3.999946>>>s=pd.Series(arr)>>>s.rolling(4).kurt()0         NaN1         NaN2         NaN3   -1.2000004    3.999946dtype: float64"
Pandas,Window,pandas.core.window.rolling.Rolling.apply,"pandas.core.window.rolling.Rolling.apply#Rolling.apply(func,raw=False,engine=None,engine_kwargs=None,args=None,kwargs=None)[source]#Calculate the rolling custom aggregation function.Parameters:funcfunctionMust produce a single value from an ndarray input ifraw=Trueor a single value from a Series ifraw=False. Can also accept a
Numba JIT function withengine='numba'specified.rawbool, default FalseFalse: passes each row or column as a Series to the
function.True: the passed function will receive ndarray
objects instead.
If you are just applying a NumPy reduction function this will
achieve much better performance.enginestr, default None'cython': Runs rolling apply through C-extensions from cython.'numba': Runs rolling apply through JIT compiled code from numba.
Only available whenrawis set toTrue.None: Defaults to'cython'or globally settingcompute.use_numbaengine_kwargsdict, default NoneFor'cython'engine, there are no acceptedengine_kwargsFor'numba'engine, the engine can acceptnopython,nogilandparalleldictionary keys. The values must either beTrueorFalse. The defaultengine_kwargsfor the'numba'engine is{'nopython':True,'nogil':False,'parallel':False}and will be
applied to both thefuncand theapplyrolling aggregation.argstuple, default NonePositional arguments to be passed into func.kwargsdict, default NoneKeyword arguments to be passed into func.Returns:Series or DataFrameReturn type is the same as the original object withnp.float64dtype.See alsopandas.Series.rollingCalling rolling with Series data.pandas.DataFrame.rollingCalling rolling with DataFrames.pandas.Series.applyAggregating apply for Series.pandas.DataFrame.applyAggregating apply for DataFrame.Examples>>>ser=pd.Series([1,6,5,4])>>>ser.rolling(2).apply(lambdas:s.sum()-s.min())0    NaN1    6.02    6.03    5.0dtype: float64"
Pandas,Window,pandas.core.window.rolling.Rolling.aggregate,"pandas.core.window.rolling.Rolling.aggregate#Rolling.aggregate(func,*args,**kwargs)[source]#Aggregate using one or more operations over the specified axis.Parameters:funcfunction, str, list or dictFunction to use for aggregating the data. If a function, must either
work when passed a Series/Dataframe or when passed to Series/Dataframe.apply.Accepted combinations are:functionstring function namelist of functions and/or function names, e.g.[np.sum,'mean']dict of axis labels -> functions, function names or list of such.*argsPositional arguments to pass tofunc.**kwargsKeyword arguments to pass tofunc.Returns:scalar, Series or DataFrameThe return can be:scalar : when Series.agg is called with single functionSeries : when DataFrame.agg is called with a single functionDataFrame : when DataFrame.agg is called with several functionsReturn scalar, Series or DataFrame.See alsopandas.Series.rollingCalling object with Series data.pandas.DataFrame.rollingCalling object with DataFrame data.NotesThe aggregation operations are always performed over an axis, either the
index (default) or the column axis. This behavior is different fromnumpyaggregation functions (mean,median,prod,sum,std,var), where the default is to compute the aggregation of the flattened
array, e.g.,numpy.mean(arr_2d)as opposed tonumpy.mean(arr_2d,axis=0).aggis an alias foraggregate. Use the alias.Functions that mutate the passed object can produce unexpected
behavior or errors and are not supported. SeeMutating with User Defined Function (UDF) methodsfor more details.A passed user-defined-function will be passed a Series for evaluation.Examples>>>df=pd.DataFrame({""A"":[1,2,3],""B"":[4,5,6],""C"":[7,8,9]})>>>dfA  B  C0  1  4  71  2  5  82  3  6  9>>>df.rolling(2).sum()A     B     C0  NaN   NaN   NaN1  3.0   9.0  15.02  5.0  11.0  17.0>>>df.rolling(2).agg({""A"":""sum"",""B"":""min""})A    B0  NaN  NaN1  3.0  4.02  5.0  5.0"
Pandas,Window,pandas.core.window.rolling.Rolling.quantile,"pandas.core.window.rolling.Rolling.quantile#Rolling.quantile(q,interpolation='linear',numeric_only=False)[source]#Calculate the rolling quantile.Parameters:quantilefloatQuantile to compute. 0 <= quantile <= 1.Deprecated since version 2.1.0:This will be renamed to eqf in a future version.interpolation{elinearf, elowerf, ehigherf, emidpointf, enearestf}This optional parameter specifies the interpolation method to use,
when the desired quantile lies between two data pointsiandj:linear:i + (j - i) * fraction, wherefractionis the
fractional part of the index surrounded byiandj.lower:i.higher:j.nearest:iorjwhichever is nearest.midpoint: (i+j) / 2.numeric_onlybool, default FalseInclude only float, int, boolean columns.New in version 1.5.0.Returns:Series or DataFrameReturn type is the same as the original object withnp.float64dtype.See alsopandas.Series.rollingCalling rolling with Series data.pandas.DataFrame.rollingCalling rolling with DataFrames.pandas.Series.quantileAggregating quantile for Series.pandas.DataFrame.quantileAggregating quantile for DataFrame.Examples>>>s=pd.Series([1,2,3,4])>>>s.rolling(2).quantile(.4,interpolation='lower')0    NaN1    1.02    2.03    3.0dtype: float64>>>s.rolling(2).quantile(.4,interpolation='midpoint')0    NaN1    1.52    2.53    3.5dtype: float64"
Pandas,Window,pandas.core.window.rolling.Rolling.sem,"pandas.core.window.rolling.Rolling.sem#Rolling.sem(ddof=1,numeric_only=False)[source]#Calculate the rolling standard error of mean.Parameters:ddofint, default 1Delta Degrees of Freedom. The divisor used in calculations
isN-ddof, whereNrepresents the number of elements.numeric_onlybool, default FalseInclude only float, int, boolean columns.New in version 1.5.0.Returns:Series or DataFrameReturn type is the same as the original object withnp.float64dtype.See alsopandas.Series.rollingCalling rolling with Series data.pandas.DataFrame.rollingCalling rolling with DataFrames.pandas.Series.semAggregating sem for Series.pandas.DataFrame.semAggregating sem for DataFrame.NotesA minimum of one period is required for the calculation.Examples>>>s=pd.Series([0,1,2,3])>>>s.rolling(2,min_periods=1).sem()0         NaN1    0.7071072    0.7071073    0.707107dtype: float64"
Pandas,Window,pandas.core.window.rolling.Rolling.rank,"pandas.core.window.rolling.Rolling.rank#Rolling.rank(method='average',ascending=True,pct=False,numeric_only=False)[source]#Calculate the rolling rank.New in version 1.4.0.Parameters:method{eaveragef, eminf, emaxf}, default eaveragefHow to rank the group of records that have the same value (i.e. ties):average: average rank of the groupmin: lowest rank in the groupmax: highest rank in the groupascendingbool, default TrueWhether or not the elements should be ranked in ascending order.pctbool, default FalseWhether or not to display the returned rankings in percentile
form.numeric_onlybool, default FalseInclude only float, int, boolean columns.New in version 1.5.0.Returns:Series or DataFrameReturn type is the same as the original object withnp.float64dtype.See alsopandas.Series.rollingCalling rolling with Series data.pandas.DataFrame.rollingCalling rolling with DataFrames.pandas.Series.rankAggregating rank for Series.pandas.DataFrame.rankAggregating rank for DataFrame.Examples>>>s=pd.Series([1,4,2,3,5,3])>>>s.rolling(3).rank()0    NaN1    NaN2    2.03    2.04    3.05    1.5dtype: float64>>>s.rolling(3).rank(method=""max"")0    NaN1    NaN2    2.03    2.04    3.05    2.0dtype: float64>>>s.rolling(3).rank(method=""min"")0    NaN1    NaN2    2.03    2.04    3.05    1.0dtype: float64"
Pandas,Window,pandas.core.window.rolling.Window.mean,"pandas.core.window.rolling.Window.mean#Window.mean(numeric_only=False,**kwargs)[source]#Calculate the rolling weighted window mean.Parameters:numeric_onlybool, default FalseInclude only float, int, boolean columns.New in version 1.5.0.**kwargsKeyword arguments to configure theSciPyweighted window type.Returns:Series or DataFrameReturn type is the same as the original object withnp.float64dtype.See alsopandas.Series.rollingCalling rolling with Series data.pandas.DataFrame.rollingCalling rolling with DataFrames.pandas.Series.meanAggregating mean for Series.pandas.DataFrame.meanAggregating mean for DataFrame.Examples>>>ser=pd.Series([0,1,5,2,8])To get an instance ofWindowwe need
to pass the parameterwin_type.>>>type(ser.rolling(2,win_type='gaussian'))<class 'pandas.core.window.rolling.Window'>In order to use theSciPyGaussian window we need to provide the parametersMandstd. The parameterMcorresponds to 2 in our example.
We pass the second parameterstdas a parameter of the following method:>>>ser.rolling(2,win_type='gaussian').mean(std=3)0    NaN1    0.52    3.03    3.54    5.0dtype: float64"
Pandas,Window,pandas.core.window.rolling.Window.sum,"pandas.core.window.rolling.Window.sum#Window.sum(numeric_only=False,**kwargs)[source]#Calculate the rolling weighted window sum.Parameters:numeric_onlybool, default FalseInclude only float, int, boolean columns.New in version 1.5.0.**kwargsKeyword arguments to configure theSciPyweighted window type.Returns:Series or DataFrameReturn type is the same as the original object withnp.float64dtype.See alsopandas.Series.rollingCalling rolling with Series data.pandas.DataFrame.rollingCalling rolling with DataFrames.pandas.Series.sumAggregating sum for Series.pandas.DataFrame.sumAggregating sum for DataFrame.Examples>>>ser=pd.Series([0,1,5,2,8])To get an instance ofWindowwe need
to pass the parameterwin_type.>>>type(ser.rolling(2,win_type='gaussian'))<class 'pandas.core.window.rolling.Window'>In order to use theSciPyGaussian window we need to provide the parametersMandstd. The parameterMcorresponds to 2 in our example.
We pass the second parameterstdas a parameter of the following method
(sumin this case):>>>ser.rolling(2,win_type='gaussian').sum(std=3)0         NaN1    0.9862072    5.9172433    6.9034504    9.862071dtype: float64"
Pandas,Window,pandas.core.window.rolling.Window.var,"pandas.core.window.rolling.Window.var#Window.var(ddof=1,numeric_only=False,**kwargs)[source]#Calculate the rolling weighted window variance.Parameters:numeric_onlybool, default FalseInclude only float, int, boolean columns.New in version 1.5.0.**kwargsKeyword arguments to configure theSciPyweighted window type.Returns:Series or DataFrameReturn type is the same as the original object withnp.float64dtype.See alsopandas.Series.rollingCalling rolling with Series data.pandas.DataFrame.rollingCalling rolling with DataFrames.pandas.Series.varAggregating var for Series.pandas.DataFrame.varAggregating var for DataFrame.Examples>>>ser=pd.Series([0,1,5,2,8])To get an instance ofWindowwe need
to pass the parameterwin_type.>>>type(ser.rolling(2,win_type='gaussian'))<class 'pandas.core.window.rolling.Window'>In order to use theSciPyGaussian window we need to provide the parametersMandstd. The parameterMcorresponds to 2 in our example.
We pass the second parameterstdas a parameter of the following method:>>>ser.rolling(2,win_type='gaussian').var(std=3)0     NaN1     0.52     8.03     4.54    18.0dtype: float64"
Pandas,Window,pandas.core.window.rolling.Window.std,"pandas.core.window.rolling.Window.std#Window.std(ddof=1,numeric_only=False,**kwargs)[source]#Calculate the rolling weighted window standard deviation.Parameters:numeric_onlybool, default FalseInclude only float, int, boolean columns.New in version 1.5.0.**kwargsKeyword arguments to configure theSciPyweighted window type.Returns:Series or DataFrameReturn type is the same as the original object withnp.float64dtype.See alsopandas.Series.rollingCalling rolling with Series data.pandas.DataFrame.rollingCalling rolling with DataFrames.pandas.Series.stdAggregating std for Series.pandas.DataFrame.stdAggregating std for DataFrame.Examples>>>ser=pd.Series([0,1,5,2,8])To get an instance ofWindowwe need
to pass the parameterwin_type.>>>type(ser.rolling(2,win_type='gaussian'))<class 'pandas.core.window.rolling.Window'>In order to use theSciPyGaussian window we need to provide the parametersMandstd. The parameterMcorresponds to 2 in our example.
We pass the second parameterstdas a parameter of the following method:>>>ser.rolling(2,win_type='gaussian').std(std=3)0         NaN1    0.7071072    2.8284273    2.1213204    4.242641dtype: float64"
Pandas,Window,pandas.core.window.expanding.Expanding.count,"pandas.core.window.expanding.Expanding.count#Expanding.count(numeric_only=False)[source]#Calculate the expanding count of non NaN observations.Returns:Series or DataFrameReturn type is the same as the original object withnp.float64dtype.See alsopandas.Series.expandingCalling expanding with Series data.pandas.DataFrame.expandingCalling expanding with DataFrames.pandas.Series.countAggregating count for Series.pandas.DataFrame.countAggregating count for DataFrame.Examples>>>ser=pd.Series([1,2,3,4],index=['a','b','c','d'])>>>ser.expanding().count()a    1.0b    2.0c    3.0d    4.0dtype: float64"
Pandas,Window,pandas.core.window.expanding.Expanding.sum,"pandas.core.window.expanding.Expanding.sum#Expanding.sum(numeric_only=False,engine=None,engine_kwargs=None)[source]#Calculate the expanding sum.Parameters:numeric_onlybool, default FalseInclude only float, int, boolean columns.New in version 1.5.0.enginestr, default None'cython': Runs the operation through C-extensions from cython.'numba': Runs the operation through JIT compiled code from numba.None: Defaults to'cython'or globally settingcompute.use_numbaNew in version 1.3.0.engine_kwargsdict, default NoneFor'cython'engine, there are no acceptedengine_kwargsFor'numba'engine, the engine can acceptnopython,nogilandparalleldictionary keys. The values must either beTrueorFalse. The defaultengine_kwargsfor the'numba'engine is{'nopython':True,'nogil':False,'parallel':False}New in version 1.3.0.Returns:Series or DataFrameReturn type is the same as the original object withnp.float64dtype.See alsopandas.Series.expandingCalling expanding with Series data.pandas.DataFrame.expandingCalling expanding with DataFrames.pandas.Series.sumAggregating sum for Series.pandas.DataFrame.sumAggregating sum for DataFrame.NotesSeeNumba engineandNumba (JIT compilation)for extended documentation and performance considerations for the Numba engine.Examples>>>ser=pd.Series([1,2,3,4],index=['a','b','c','d'])>>>ser.expanding().sum()a     1.0b     3.0c     6.0d    10.0dtype: float64"
Pandas,Window,pandas.core.window.expanding.Expanding.mean,"pandas.core.window.expanding.Expanding.mean#Expanding.mean(numeric_only=False,engine=None,engine_kwargs=None)[source]#Calculate the expanding mean.Parameters:numeric_onlybool, default FalseInclude only float, int, boolean columns.New in version 1.5.0.enginestr, default None'cython': Runs the operation through C-extensions from cython.'numba': Runs the operation through JIT compiled code from numba.None: Defaults to'cython'or globally settingcompute.use_numbaNew in version 1.3.0.engine_kwargsdict, default NoneFor'cython'engine, there are no acceptedengine_kwargsFor'numba'engine, the engine can acceptnopython,nogilandparalleldictionary keys. The values must either beTrueorFalse. The defaultengine_kwargsfor the'numba'engine is{'nopython':True,'nogil':False,'parallel':False}New in version 1.3.0.Returns:Series or DataFrameReturn type is the same as the original object withnp.float64dtype.See alsopandas.Series.expandingCalling expanding with Series data.pandas.DataFrame.expandingCalling expanding with DataFrames.pandas.Series.meanAggregating mean for Series.pandas.DataFrame.meanAggregating mean for DataFrame.NotesSeeNumba engineandNumba (JIT compilation)for extended documentation and performance considerations for the Numba engine.Examples>>>ser=pd.Series([1,2,3,4],index=['a','b','c','d'])>>>ser.expanding().mean()a    1.0b    1.5c    2.0d    2.5dtype: float64"
Pandas,Window,pandas.core.window.expanding.Expanding.median,"pandas.core.window.expanding.Expanding.median#Expanding.median(numeric_only=False,engine=None,engine_kwargs=None)[source]#Calculate the expanding median.Parameters:numeric_onlybool, default FalseInclude only float, int, boolean columns.New in version 1.5.0.enginestr, default None'cython': Runs the operation through C-extensions from cython.'numba': Runs the operation through JIT compiled code from numba.None: Defaults to'cython'or globally settingcompute.use_numbaNew in version 1.3.0.engine_kwargsdict, default NoneFor'cython'engine, there are no acceptedengine_kwargsFor'numba'engine, the engine can acceptnopython,nogilandparalleldictionary keys. The values must either beTrueorFalse. The defaultengine_kwargsfor the'numba'engine is{'nopython':True,'nogil':False,'parallel':False}New in version 1.3.0.Returns:Series or DataFrameReturn type is the same as the original object withnp.float64dtype.See alsopandas.Series.expandingCalling expanding with Series data.pandas.DataFrame.expandingCalling expanding with DataFrames.pandas.Series.medianAggregating median for Series.pandas.DataFrame.medianAggregating median for DataFrame.NotesSeeNumba engineandNumba (JIT compilation)for extended documentation and performance considerations for the Numba engine.Examples>>>ser=pd.Series([1,2,3,4],index=['a','b','c','d'])>>>ser.expanding().median()a    1.0b    1.5c    2.0d    2.5dtype: float64"
Pandas,Window,pandas.core.window.expanding.Expanding.var,"pandas.core.window.expanding.Expanding.var#Expanding.var(ddof=1,numeric_only=False,engine=None,engine_kwargs=None)[source]#Calculate the expanding variance.Parameters:ddofint, default 1Delta Degrees of Freedom. The divisor used in calculations
isN-ddof, whereNrepresents the number of elements.numeric_onlybool, default FalseInclude only float, int, boolean columns.New in version 1.5.0.enginestr, default None'cython': Runs the operation through C-extensions from cython.'numba': Runs the operation through JIT compiled code from numba.None: Defaults to'cython'or globally settingcompute.use_numbaNew in version 1.4.0.engine_kwargsdict, default NoneFor'cython'engine, there are no acceptedengine_kwargsFor'numba'engine, the engine can acceptnopython,nogilandparalleldictionary keys. The values must either beTrueorFalse. The defaultengine_kwargsfor the'numba'engine is{'nopython':True,'nogil':False,'parallel':False}New in version 1.4.0.Returns:Series or DataFrameReturn type is the same as the original object withnp.float64dtype.See alsonumpy.varEquivalent method for NumPy array.pandas.Series.expandingCalling expanding with Series data.pandas.DataFrame.expandingCalling expanding with DataFrames.pandas.Series.varAggregating var for Series.pandas.DataFrame.varAggregating var for DataFrame.NotesThe defaultddofof 1 used inSeries.var()is different
than the defaultddofof 0 innumpy.var().A minimum of one period is required for the rolling calculation.Examples>>>s=pd.Series([5,5,6,7,5,5,5])>>>s.expanding(3).var()0         NaN1         NaN2    0.3333333    0.9166674    0.8000005    0.7000006    0.619048dtype: float64"
Pandas,Window,pandas.core.window.expanding.Expanding.std,"pandas.core.window.expanding.Expanding.std#Expanding.std(ddof=1,numeric_only=False,engine=None,engine_kwargs=None)[source]#Calculate the expanding standard deviation.Parameters:ddofint, default 1Delta Degrees of Freedom. The divisor used in calculations
isN-ddof, whereNrepresents the number of elements.numeric_onlybool, default FalseInclude only float, int, boolean columns.New in version 1.5.0.enginestr, default None'cython': Runs the operation through C-extensions from cython.'numba': Runs the operation through JIT compiled code from numba.None: Defaults to'cython'or globally settingcompute.use_numbaNew in version 1.4.0.engine_kwargsdict, default NoneFor'cython'engine, there are no acceptedengine_kwargsFor'numba'engine, the engine can acceptnopython,nogilandparalleldictionary keys. The values must either beTrueorFalse. The defaultengine_kwargsfor the'numba'engine is{'nopython':True,'nogil':False,'parallel':False}New in version 1.4.0.Returns:Series or DataFrameReturn type is the same as the original object withnp.float64dtype.See alsonumpy.stdEquivalent method for NumPy array.pandas.Series.expandingCalling expanding with Series data.pandas.DataFrame.expandingCalling expanding with DataFrames.pandas.Series.stdAggregating std for Series.pandas.DataFrame.stdAggregating std for DataFrame.NotesThe defaultddofof 1 used inSeries.std()is different
than the defaultddofof 0 innumpy.std().A minimum of one period is required for the rolling calculation.Examples>>>s=pd.Series([5,5,6,7,5,5,5])>>>s.expanding(3).std()0         NaN1         NaN2    0.5773503    0.9574274    0.8944275    0.8366606    0.786796dtype: float64"
Pandas,Window,pandas.core.window.expanding.Expanding.min,"pandas.core.window.expanding.Expanding.min#Expanding.min(numeric_only=False,engine=None,engine_kwargs=None)[source]#Calculate the expanding minimum.Parameters:numeric_onlybool, default FalseInclude only float, int, boolean columns.New in version 1.5.0.enginestr, default None'cython': Runs the operation through C-extensions from cython.'numba': Runs the operation through JIT compiled code from numba.None: Defaults to'cython'or globally settingcompute.use_numbaNew in version 1.3.0.engine_kwargsdict, default NoneFor'cython'engine, there are no acceptedengine_kwargsFor'numba'engine, the engine can acceptnopython,nogilandparalleldictionary keys. The values must either beTrueorFalse. The defaultengine_kwargsfor the'numba'engine is{'nopython':True,'nogil':False,'parallel':False}New in version 1.3.0.Returns:Series or DataFrameReturn type is the same as the original object withnp.float64dtype.See alsopandas.Series.expandingCalling expanding with Series data.pandas.DataFrame.expandingCalling expanding with DataFrames.pandas.Series.minAggregating min for Series.pandas.DataFrame.minAggregating min for DataFrame.NotesSeeNumba engineandNumba (JIT compilation)for extended documentation and performance considerations for the Numba engine.Examples>>>ser=pd.Series([2,3,4,1],index=['a','b','c','d'])>>>ser.expanding().min()a    2.0b    2.0c    2.0d    1.0dtype: float64"
Pandas,Window,pandas.core.window.expanding.Expanding.max,"pandas.core.window.expanding.Expanding.max#Expanding.max(numeric_only=False,engine=None,engine_kwargs=None)[source]#Calculate the expanding maximum.Parameters:numeric_onlybool, default FalseInclude only float, int, boolean columns.New in version 1.5.0.enginestr, default None'cython': Runs the operation through C-extensions from cython.'numba': Runs the operation through JIT compiled code from numba.None: Defaults to'cython'or globally settingcompute.use_numbaNew in version 1.3.0.engine_kwargsdict, default NoneFor'cython'engine, there are no acceptedengine_kwargsFor'numba'engine, the engine can acceptnopython,nogilandparalleldictionary keys. The values must either beTrueorFalse. The defaultengine_kwargsfor the'numba'engine is{'nopython':True,'nogil':False,'parallel':False}New in version 1.3.0.Returns:Series or DataFrameReturn type is the same as the original object withnp.float64dtype.See alsopandas.Series.expandingCalling expanding with Series data.pandas.DataFrame.expandingCalling expanding with DataFrames.pandas.Series.maxAggregating max for Series.pandas.DataFrame.maxAggregating max for DataFrame.NotesSeeNumba engineandNumba (JIT compilation)for extended documentation and performance considerations for the Numba engine.Examples>>>ser=pd.Series([3,2,1,4],index=['a','b','c','d'])>>>ser.expanding().max()a    3.0b    3.0c    3.0d    4.0dtype: float64"
Pandas,Window,pandas.core.window.expanding.Expanding.corr,"pandas.core.window.expanding.Expanding.corr#Expanding.corr(other=None,pairwise=None,ddof=1,numeric_only=False)[source]#Calculate the expanding correlation.Parameters:otherSeries or DataFrame, optionalIf not supplied then will default to self and produce pairwise
output.pairwisebool, default NoneIf False then only matching columns between self and other will be
used and the output will be a DataFrame.
If True then all pairwise combinations will be calculated and the
output will be a MultiIndexed DataFrame in the case of DataFrame
inputs. In the case of missing elements, only complete pairwise
observations will be used.numeric_onlybool, default FalseInclude only float, int, boolean columns.New in version 1.5.0.Returns:Series or DataFrameReturn type is the same as the original object withnp.float64dtype.See alsocovSimilar method to calculate covariance.numpy.corrcoefNumPy Pearsonfs correlation calculation.pandas.Series.expandingCalling expanding with Series data.pandas.DataFrame.expandingCalling expanding with DataFrames.pandas.Series.corrAggregating corr for Series.pandas.DataFrame.corrAggregating corr for DataFrame.NotesThis function uses Pearsonfs definition of correlation
(https://en.wikipedia.org/wiki/Pearson_correlation_coefficient).Whenotheris not specified, the output will be self correlation (e.g.
all 1fs), except forDataFrameinputs withpairwiseset toTrue.Function will returnNaNfor correlations of equal valued sequences;
this is the result of a 0/0 division error.Whenpairwiseis set toFalse, only matching columns betweenselfandotherwill be used.Whenpairwiseis set toTrue, the output will be a MultiIndex DataFrame
with the original index on the first level, and theotherDataFrame
columns on the second level.In the case of missing elements, only complete pairwise observations
will be used.Examples>>>ser1=pd.Series([1,2,3,4],index=['a','b','c','d'])>>>ser2=pd.Series([10,11,13,16],index=['a','b','c','d'])>>>ser1.expanding().corr(ser2)a         NaNb    1.000000c    0.981981d    0.975900dtype: float64"
Pandas,Window,pandas.core.window.expanding.Expanding.cov,"pandas.core.window.expanding.Expanding.cov#Expanding.cov(other=None,pairwise=None,ddof=1,numeric_only=False)[source]#Calculate the expanding sample covariance.Parameters:otherSeries or DataFrame, optionalIf not supplied then will default to self and produce pairwise
output.pairwisebool, default NoneIf False then only matching columns between self and other will be
used and the output will be a DataFrame.
If True then all pairwise combinations will be calculated and the
output will be a MultiIndexed DataFrame in the case of DataFrame
inputs. In the case of missing elements, only complete pairwise
observations will be used.ddofint, default 1Delta Degrees of Freedom. The divisor used in calculations
isN-ddof, whereNrepresents the number of elements.numeric_onlybool, default FalseInclude only float, int, boolean columns.New in version 1.5.0.Returns:Series or DataFrameReturn type is the same as the original object withnp.float64dtype.See alsopandas.Series.expandingCalling expanding with Series data.pandas.DataFrame.expandingCalling expanding with DataFrames.pandas.Series.covAggregating cov for Series.pandas.DataFrame.covAggregating cov for DataFrame.Examples>>>ser1=pd.Series([1,2,3,4],index=['a','b','c','d'])>>>ser2=pd.Series([10,11,13,16],index=['a','b','c','d'])>>>ser1.expanding().cov(ser2)a         NaNb    0.500000c    1.500000d    3.333333dtype: float64"
Pandas,Window,pandas.core.window.expanding.Expanding.skew,"pandas.core.window.expanding.Expanding.skew#Expanding.skew(numeric_only=False)[source]#Calculate the expanding unbiased skewness.Parameters:numeric_onlybool, default FalseInclude only float, int, boolean columns.New in version 1.5.0.Returns:Series or DataFrameReturn type is the same as the original object withnp.float64dtype.See alsoscipy.stats.skewThird moment of a probability density.pandas.Series.expandingCalling expanding with Series data.pandas.DataFrame.expandingCalling expanding with DataFrames.pandas.Series.skewAggregating skew for Series.pandas.DataFrame.skewAggregating skew for DataFrame.NotesA minimum of three periods is required for the rolling calculation.Examples>>>ser=pd.Series([-1,0,2,-1,2],index=['a','b','c','d','e'])>>>ser.expanding().skew()a         NaNb         NaNc    0.935220d    1.414214e    0.315356dtype: float64"
Pandas,Window,pandas.core.window.expanding.Expanding.kurt,"pandas.core.window.expanding.Expanding.kurt#Expanding.kurt(numeric_only=False)[source]#Calculate the expanding Fisherfs definition of kurtosis without bias.Parameters:numeric_onlybool, default FalseInclude only float, int, boolean columns.New in version 1.5.0.Returns:Series or DataFrameReturn type is the same as the original object withnp.float64dtype.See alsoscipy.stats.kurtosisReference SciPy method.pandas.Series.expandingCalling expanding with Series data.pandas.DataFrame.expandingCalling expanding with DataFrames.pandas.Series.kurtAggregating kurt for Series.pandas.DataFrame.kurtAggregating kurt for DataFrame.NotesA minimum of four periods is required for the calculation.ExamplesThe example below will show a rolling calculation with a window size of
four matching the equivalent function call usingscipy.stats.>>>arr=[1,2,3,4,999]>>>importscipy.stats>>>print(f""{scipy.stats.kurtosis(arr[:-1],bias=False):.6f}"")-1.200000>>>print(f""{scipy.stats.kurtosis(arr,bias=False):.6f}"")4.999874>>>s=pd.Series(arr)>>>s.expanding(4).kurt()0         NaN1         NaN2         NaN3   -1.2000004    4.999874dtype: float64"
Pandas,Window,pandas.core.window.expanding.Expanding.apply,"pandas.core.window.expanding.Expanding.apply#Expanding.apply(func,raw=False,engine=None,engine_kwargs=None,args=None,kwargs=None)[source]#Calculate the expanding custom aggregation function.Parameters:funcfunctionMust produce a single value from an ndarray input ifraw=Trueor a single value from a Series ifraw=False. Can also accept a
Numba JIT function withengine='numba'specified.rawbool, default FalseFalse: passes each row or column as a Series to the
function.True: the passed function will receive ndarray
objects instead.
If you are just applying a NumPy reduction function this will
achieve much better performance.enginestr, default None'cython': Runs rolling apply through C-extensions from cython.'numba': Runs rolling apply through JIT compiled code from numba.
Only available whenrawis set toTrue.None: Defaults to'cython'or globally settingcompute.use_numbaengine_kwargsdict, default NoneFor'cython'engine, there are no acceptedengine_kwargsFor'numba'engine, the engine can acceptnopython,nogilandparalleldictionary keys. The values must either beTrueorFalse. The defaultengine_kwargsfor the'numba'engine is{'nopython':True,'nogil':False,'parallel':False}and will be
applied to both thefuncand theapplyrolling aggregation.argstuple, default NonePositional arguments to be passed into func.kwargsdict, default NoneKeyword arguments to be passed into func.Returns:Series or DataFrameReturn type is the same as the original object withnp.float64dtype.See alsopandas.Series.expandingCalling expanding with Series data.pandas.DataFrame.expandingCalling expanding with DataFrames.pandas.Series.applyAggregating apply for Series.pandas.DataFrame.applyAggregating apply for DataFrame.Examples>>>ser=pd.Series([1,2,3,4],index=['a','b','c','d'])>>>ser.expanding().apply(lambdas:s.max()-2*s.min())a   -1.0b    0.0c    1.0d    2.0dtype: float64"
Pandas,Window,pandas.core.window.expanding.Expanding.aggregate,"pandas.core.window.expanding.Expanding.aggregate#Expanding.aggregate(func,*args,**kwargs)[source]#Aggregate using one or more operations over the specified axis.Parameters:funcfunction, str, list or dictFunction to use for aggregating the data. If a function, must either
work when passed a Series/Dataframe or when passed to Series/Dataframe.apply.Accepted combinations are:functionstring function namelist of functions and/or function names, e.g.[np.sum,'mean']dict of axis labels -> functions, function names or list of such.*argsPositional arguments to pass tofunc.**kwargsKeyword arguments to pass tofunc.Returns:scalar, Series or DataFrameThe return can be:scalar : when Series.agg is called with single functionSeries : when DataFrame.agg is called with a single functionDataFrame : when DataFrame.agg is called with several functionsReturn scalar, Series or DataFrame.See alsopandas.DataFrame.aggregateSimilar DataFrame method.pandas.Series.aggregateSimilar Series method.NotesThe aggregation operations are always performed over an axis, either the
index (default) or the column axis. This behavior is different fromnumpyaggregation functions (mean,median,prod,sum,std,var), where the default is to compute the aggregation of the flattened
array, e.g.,numpy.mean(arr_2d)as opposed tonumpy.mean(arr_2d,axis=0).aggis an alias foraggregate. Use the alias.Functions that mutate the passed object can produce unexpected
behavior or errors and are not supported. SeeMutating with User Defined Function (UDF) methodsfor more details.A passed user-defined-function will be passed a Series for evaluation.Examples>>>df=pd.DataFrame({""A"":[1,2,3],""B"":[4,5,6],""C"":[7,8,9]})>>>dfA  B  C0  1  4  71  2  5  82  3  6  9>>>df.ewm(alpha=0.5).mean()A         B         C0  1.000000  4.000000  7.0000001  1.666667  4.666667  7.6666672  2.428571  5.428571  8.428571"
Pandas,Window,pandas.core.window.expanding.Expanding.quantile,"pandas.core.window.expanding.Expanding.quantile#Expanding.quantile(q,interpolation='linear',numeric_only=False)[source]#Calculate the expanding quantile.Parameters:quantilefloatQuantile to compute. 0 <= quantile <= 1.Deprecated since version 2.1.0:This will be renamed to eqf in a future version.interpolation{elinearf, elowerf, ehigherf, emidpointf, enearestf}This optional parameter specifies the interpolation method to use,
when the desired quantile lies between two data pointsiandj:linear:i + (j - i) * fraction, wherefractionis the
fractional part of the index surrounded byiandj.lower:i.higher:j.nearest:iorjwhichever is nearest.midpoint: (i+j) / 2.numeric_onlybool, default FalseInclude only float, int, boolean columns.New in version 1.5.0.Returns:Series or DataFrameReturn type is the same as the original object withnp.float64dtype.See alsopandas.Series.expandingCalling expanding with Series data.pandas.DataFrame.expandingCalling expanding with DataFrames.pandas.Series.quantileAggregating quantile for Series.pandas.DataFrame.quantileAggregating quantile for DataFrame.Examples>>>ser=pd.Series([1,2,3,4,5,6],index=['a','b','c','d','e','f'])>>>ser.expanding(min_periods=4).quantile(.25)a     NaNb     NaNc     NaNd    1.75e    2.00f    2.25dtype: float64"
Pandas,Window,pandas.core.window.expanding.Expanding.sem,"pandas.core.window.expanding.Expanding.sem#Expanding.sem(ddof=1,numeric_only=False)[source]#Calculate the expanding standard error of mean.Parameters:ddofint, default 1Delta Degrees of Freedom. The divisor used in calculations
isN-ddof, whereNrepresents the number of elements.numeric_onlybool, default FalseInclude only float, int, boolean columns.New in version 1.5.0.Returns:Series or DataFrameReturn type is the same as the original object withnp.float64dtype.See alsopandas.Series.expandingCalling expanding with Series data.pandas.DataFrame.expandingCalling expanding with DataFrames.pandas.Series.semAggregating sem for Series.pandas.DataFrame.semAggregating sem for DataFrame.NotesA minimum of one period is required for the calculation.Examples>>>s=pd.Series([0,1,2,3])>>>s.expanding().sem()0         NaN1    0.7071072    0.7071073    0.745356dtype: float64"
Pandas,Window,pandas.core.window.expanding.Expanding.rank,"pandas.core.window.expanding.Expanding.rank#Expanding.rank(method='average',ascending=True,pct=False,numeric_only=False)[source]#Calculate the expanding rank.New in version 1.4.0.Parameters:method{eaveragef, eminf, emaxf}, default eaveragefHow to rank the group of records that have the same value (i.e. ties):average: average rank of the groupmin: lowest rank in the groupmax: highest rank in the groupascendingbool, default TrueWhether or not the elements should be ranked in ascending order.pctbool, default FalseWhether or not to display the returned rankings in percentile
form.numeric_onlybool, default FalseInclude only float, int, boolean columns.New in version 1.5.0.Returns:Series or DataFrameReturn type is the same as the original object withnp.float64dtype.See alsopandas.Series.expandingCalling expanding with Series data.pandas.DataFrame.expandingCalling expanding with DataFrames.pandas.Series.rankAggregating rank for Series.pandas.DataFrame.rankAggregating rank for DataFrame.Examples>>>s=pd.Series([1,4,2,3,5,3])>>>s.expanding().rank()0    1.01    2.02    2.03    3.04    5.05    3.5dtype: float64>>>s.expanding().rank(method=""max"")0    1.01    2.02    2.03    3.04    5.05    4.0dtype: float64>>>s.expanding().rank(method=""min"")0    1.01    2.02    2.03    3.04    5.05    3.0dtype: float64"
Pandas,Window,pandas.core.window.ewm.ExponentialMovingWindow.mean,"pandas.core.window.ewm.ExponentialMovingWindow.mean#ExponentialMovingWindow.mean(numeric_only=False,engine=None,engine_kwargs=None)[source]#Calculate the ewm (exponential weighted moment) mean.Parameters:numeric_onlybool, default FalseInclude only float, int, boolean columns.New in version 1.5.0.enginestr, default None'cython': Runs the operation through C-extensions from cython.'numba': Runs the operation through JIT compiled code from numba.None: Defaults to'cython'or globally settingcompute.use_numbaNew in version 1.3.0.engine_kwargsdict, default NoneFor'cython'engine, there are no acceptedengine_kwargsFor'numba'engine, the engine can acceptnopython,nogilandparalleldictionary keys. The values must either beTrueorFalse. The defaultengine_kwargsfor the'numba'engine is{'nopython':True,'nogil':False,'parallel':False}New in version 1.3.0.Returns:Series or DataFrameReturn type is the same as the original object withnp.float64dtype.See alsopandas.Series.ewmCalling ewm with Series data.pandas.DataFrame.ewmCalling ewm with DataFrames.pandas.Series.meanAggregating mean for Series.pandas.DataFrame.meanAggregating mean for DataFrame.NotesSeeNumba engineandNumba (JIT compilation)for extended documentation and performance considerations for the Numba engine.Examples>>>ser=pd.Series([1,2,3,4])>>>ser.ewm(alpha=.2).mean()0    1.0000001    1.5555562    2.1475413    2.775068dtype: float64"
Pandas,Window,pandas.core.window.ewm.ExponentialMovingWindow.sum,"pandas.core.window.ewm.ExponentialMovingWindow.sum#ExponentialMovingWindow.sum(numeric_only=False,engine=None,engine_kwargs=None)[source]#Calculate the ewm (exponential weighted moment) sum.Parameters:numeric_onlybool, default FalseInclude only float, int, boolean columns.New in version 1.5.0.enginestr, default None'cython': Runs the operation through C-extensions from cython.'numba': Runs the operation through JIT compiled code from numba.None: Defaults to'cython'or globally settingcompute.use_numbaNew in version 1.3.0.engine_kwargsdict, default NoneFor'cython'engine, there are no acceptedengine_kwargsFor'numba'engine, the engine can acceptnopython,nogilandparalleldictionary keys. The values must either beTrueorFalse. The defaultengine_kwargsfor the'numba'engine is{'nopython':True,'nogil':False,'parallel':False}New in version 1.3.0.Returns:Series or DataFrameReturn type is the same as the original object withnp.float64dtype.See alsopandas.Series.ewmCalling ewm with Series data.pandas.DataFrame.ewmCalling ewm with DataFrames.pandas.Series.sumAggregating sum for Series.pandas.DataFrame.sumAggregating sum for DataFrame.NotesSeeNumba engineandNumba (JIT compilation)for extended documentation and performance considerations for the Numba engine.Examples>>>ser=pd.Series([1,2,3,4])>>>ser.ewm(alpha=.2).sum()0    1.0001    2.8002    5.2403    8.192dtype: float64"
Pandas,Window,pandas.core.window.ewm.ExponentialMovingWindow.std,"pandas.core.window.ewm.ExponentialMovingWindow.std#ExponentialMovingWindow.std(bias=False,numeric_only=False)[source]#Calculate the ewm (exponential weighted moment) standard deviation.Parameters:biasbool, default FalseUse a standard estimation bias correction.numeric_onlybool, default FalseInclude only float, int, boolean columns.New in version 1.5.0.Returns:Series or DataFrameReturn type is the same as the original object withnp.float64dtype.See alsopandas.Series.ewmCalling ewm with Series data.pandas.DataFrame.ewmCalling ewm with DataFrames.pandas.Series.stdAggregating std for Series.pandas.DataFrame.stdAggregating std for DataFrame.Examples>>>ser=pd.Series([1,2,3,4])>>>ser.ewm(alpha=.2).std()0         NaN1    0.7071072    0.9958933    1.277320dtype: float64"
Pandas,Window,pandas.core.window.ewm.ExponentialMovingWindow.var,"pandas.core.window.ewm.ExponentialMovingWindow.var#ExponentialMovingWindow.var(bias=False,numeric_only=False)[source]#Calculate the ewm (exponential weighted moment) variance.Parameters:biasbool, default FalseUse a standard estimation bias correction.numeric_onlybool, default FalseInclude only float, int, boolean columns.New in version 1.5.0.Returns:Series or DataFrameReturn type is the same as the original object withnp.float64dtype.See alsopandas.Series.ewmCalling ewm with Series data.pandas.DataFrame.ewmCalling ewm with DataFrames.pandas.Series.varAggregating var for Series.pandas.DataFrame.varAggregating var for DataFrame.Examples>>>ser=pd.Series([1,2,3,4])>>>ser.ewm(alpha=.2).var()0         NaN1    0.5000002    0.9918033    1.631547dtype: float64"
Pandas,Window,pandas.core.window.ewm.ExponentialMovingWindow.corr,"pandas.core.window.ewm.ExponentialMovingWindow.corr#ExponentialMovingWindow.corr(other=None,pairwise=None,numeric_only=False)[source]#Calculate the ewm (exponential weighted moment) sample correlation.Parameters:otherSeries or DataFrame, optionalIf not supplied then will default to self and produce pairwise
output.pairwisebool, default NoneIf False then only matching columns between self and other will be
used and the output will be a DataFrame.
If True then all pairwise combinations will be calculated and the
output will be a MultiIndex DataFrame in the case of DataFrame
inputs. In the case of missing elements, only complete pairwise
observations will be used.numeric_onlybool, default FalseInclude only float, int, boolean columns.New in version 1.5.0.Returns:Series or DataFrameReturn type is the same as the original object withnp.float64dtype.See alsopandas.Series.ewmCalling ewm with Series data.pandas.DataFrame.ewmCalling ewm with DataFrames.pandas.Series.corrAggregating corr for Series.pandas.DataFrame.corrAggregating corr for DataFrame.Examples>>>ser1=pd.Series([1,2,3,4])>>>ser2=pd.Series([10,11,13,16])>>>ser1.ewm(alpha=.2).corr(ser2)0         NaN1    1.0000002    0.9828213    0.977802dtype: float64"
Pandas,Window,pandas.core.window.ewm.ExponentialMovingWindow.cov,"pandas.core.window.ewm.ExponentialMovingWindow.cov#ExponentialMovingWindow.cov(other=None,pairwise=None,bias=False,numeric_only=False)[source]#Calculate the ewm (exponential weighted moment) sample covariance.Parameters:otherSeries or DataFrame , optionalIf not supplied then will default to self and produce pairwise
output.pairwisebool, default NoneIf False then only matching columns between self and other will be
used and the output will be a DataFrame.
If True then all pairwise combinations will be calculated and the
output will be a MultiIndex DataFrame in the case of DataFrame
inputs. In the case of missing elements, only complete pairwise
observations will be used.biasbool, default FalseUse a standard estimation bias correction.numeric_onlybool, default FalseInclude only float, int, boolean columns.New in version 1.5.0.Returns:Series or DataFrameReturn type is the same as the original object withnp.float64dtype.See alsopandas.Series.ewmCalling ewm with Series data.pandas.DataFrame.ewmCalling ewm with DataFrames.pandas.Series.covAggregating cov for Series.pandas.DataFrame.covAggregating cov for DataFrame.Examples>>>ser1=pd.Series([1,2,3,4])>>>ser2=pd.Series([10,11,13,16])>>>ser1.ewm(alpha=.2).cov(ser2)0         NaN1    0.5000002    1.5245903    3.408836dtype: float64"
Pandas,Window,pandas.api.indexers.BaseIndexer,"pandas.api.indexers.BaseIndexer#classpandas.api.indexers.BaseIndexer(index_array=None,window_size=0,**kwargs)[source]#Base class for window bounds calculations.Examples>>>frompandas.api.indexersimportBaseIndexer>>>classCustomIndexer(BaseIndexer):...defget_window_bounds(self,num_values,min_periods,center,closed,step):...start=np.empty(num_values,dtype=np.int64)...end=np.empty(num_values,dtype=np.int64)...foriinrange(num_values):...start[i]=i...end[i]=i+self.window_size...returnstart,end>>>df=pd.DataFrame({""values"":range(5)})>>>indexer=CustomIndexer(window_size=2)>>>df.rolling(indexer).sum()values0   1.01   3.02   5.03   7.04   4.0Methodsget_window_bounds([num_values,?min_periods,?...])Computes the bounds of a window."
Pandas,Window,pandas.api.indexers.FixedForwardWindowIndexer,"pandas.api.indexers.FixedForwardWindowIndexer#classpandas.api.indexers.FixedForwardWindowIndexer(index_array=None,window_size=0,**kwargs)[source]#Creates window boundaries for fixed-length windows that include the current row.Examples>>>df=pd.DataFrame({'B':[0,1,2,np.nan,4]})>>>dfB0  0.01  1.02  2.03  NaN4  4.0>>>indexer=pd.api.indexers.FixedForwardWindowIndexer(window_size=2)>>>df.rolling(window=indexer,min_periods=1).sum()B0  1.01  3.02  2.03  4.04  4.0Methodsget_window_bounds([num_values,?min_periods,?...])Computes the bounds of a window."
Pandas,Window,pandas.api.indexers.VariableOffsetWindowIndexer,"pandas.api.indexers.VariableOffsetWindowIndexer#classpandas.api.indexers.VariableOffsetWindowIndexer(index_array=None,window_size=0,index=None,offset=None,**kwargs)[source]#Calculate window boundaries based on a non-fixed offset such as a BusinessDay.Examples>>>frompandas.api.indexersimportVariableOffsetWindowIndexer>>>df=pd.DataFrame(range(10),index=pd.date_range(""2020"",periods=10))>>>offset=pd.offsets.BDay(1)>>>indexer=VariableOffsetWindowIndexer(index=df.index,offset=offset)>>>df02020-01-01  02020-01-02  12020-01-03  22020-01-04  32020-01-05  42020-01-06  52020-01-07  62020-01-08  72020-01-09  82020-01-10  9>>>df.rolling(indexer).sum()02020-01-01   0.02020-01-02   1.02020-01-03   2.02020-01-04   3.02020-01-05   7.02020-01-06  12.02020-01-07   6.02020-01-08   7.02020-01-09   8.02020-01-10   9.0Methodsget_window_bounds([num_values,?min_periods,?...])Computes the bounds of a window."
