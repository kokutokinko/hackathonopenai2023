ライブラリ名,章,節,内容
Pandas,Extensions,pandas.api.extensions.register_extension_dtype,"pandas.api.extensions.register_extension_dtype#pandas.api.extensions.register_extension_dtype(cls)[source]#Register an ExtensionType with pandas as class decorator.This enables operations like.astype(name)for the name
of the ExtensionDtype.Returns:callableA class decorator.Examples>>>frompandas.api.extensionsimportregister_extension_dtype,ExtensionDtype>>>@register_extension_dtype...classMyExtensionDtype(ExtensionDtype):...name=""myextension"""
Pandas,Extensions,pandas.api.extensions.register_dataframe_accessor,"pandas.api.extensions.register_dataframe_accessor#pandas.api.extensions.register_dataframe_accessor(name)[source]#Register a custom accessor on DataFrame objects.Parameters:namestrName under which the accessor should be registered. A warning is issued
if this name conflicts with a preexisting attribute.Returns:callableA class decorator.See alsoregister_dataframe_accessorRegister a custom accessor on DataFrame objects.register_series_accessorRegister a custom accessor on Series objects.register_index_accessorRegister a custom accessor on Index objects.NotesWhen accessed, your accessor will be initialized with the pandas object
the user is interacting with. So the signature must bedef__init__(self,pandas_object):# noqa: E999...For consistency with pandas methods, you should raise anAttributeErrorif the data passed to your accessor has an incorrect dtype.>>>pd.Series(['a','b']).dtTraceback (most recent call last):...AttributeError:Can only use .dt accessor with datetimelike valuesExamplesIn your library code:importpandasaspd@pd.api.extensions.register_dataframe_accessor(""geo"")classGeoAccessor:def__init__(self,pandas_obj):self._obj=pandas_obj@propertydefcenter(self):# return the geographic center point of this DataFramelat=self._obj.latitudelon=self._obj.longitudereturn(float(lon.mean()),float(lat.mean()))defplot(self):# plot this array's data on a map, e.g., using CartopypassBack in an interactive IPython session:In [1]:ds=pd.DataFrame({""longitude"":np.linspace(0,10),...:""latitude"":np.linspace(0,20)})In [2]:ds.geo.centerOut[2]:(5.0, 10.0)In [3]:ds.geo.plot()# plots data on a map"
Pandas,Extensions,pandas.api.extensions.register_series_accessor,"pandas.api.extensions.register_series_accessor#pandas.api.extensions.register_series_accessor(name)[source]#Register a custom accessor on Series objects.Parameters:namestrName under which the accessor should be registered. A warning is issued
if this name conflicts with a preexisting attribute.Returns:callableA class decorator.See alsoregister_dataframe_accessorRegister a custom accessor on DataFrame objects.register_series_accessorRegister a custom accessor on Series objects.register_index_accessorRegister a custom accessor on Index objects.NotesWhen accessed, your accessor will be initialized with the pandas object
the user is interacting with. So the signature must bedef__init__(self,pandas_object):# noqa: E999...For consistency with pandas methods, you should raise anAttributeErrorif the data passed to your accessor has an incorrect dtype.>>>pd.Series(['a','b']).dtTraceback (most recent call last):...AttributeError:Can only use .dt accessor with datetimelike valuesExamplesIn your library code:importpandasaspd@pd.api.extensions.register_dataframe_accessor(""geo"")classGeoAccessor:def__init__(self,pandas_obj):self._obj=pandas_obj@propertydefcenter(self):# return the geographic center point of this DataFramelat=self._obj.latitudelon=self._obj.longitudereturn(float(lon.mean()),float(lat.mean()))defplot(self):# plot this array's data on a map, e.g., using CartopypassBack in an interactive IPython session:In [1]:ds=pd.DataFrame({""longitude"":np.linspace(0,10),...:""latitude"":np.linspace(0,20)})In [2]:ds.geo.centerOut[2]:(5.0, 10.0)In [3]:ds.geo.plot()# plots data on a map"
Pandas,Extensions,pandas.api.extensions.register_index_accessor,"pandas.api.extensions.register_index_accessor#pandas.api.extensions.register_index_accessor(name)[source]#Register a custom accessor on Index objects.Parameters:namestrName under which the accessor should be registered. A warning is issued
if this name conflicts with a preexisting attribute.Returns:callableA class decorator.See alsoregister_dataframe_accessorRegister a custom accessor on DataFrame objects.register_series_accessorRegister a custom accessor on Series objects.register_index_accessorRegister a custom accessor on Index objects.NotesWhen accessed, your accessor will be initialized with the pandas object
the user is interacting with. So the signature must bedef__init__(self,pandas_object):# noqa: E999...For consistency with pandas methods, you should raise anAttributeErrorif the data passed to your accessor has an incorrect dtype.>>>pd.Series(['a','b']).dtTraceback (most recent call last):...AttributeError:Can only use .dt accessor with datetimelike valuesExamplesIn your library code:importpandasaspd@pd.api.extensions.register_dataframe_accessor(""geo"")classGeoAccessor:def__init__(self,pandas_obj):self._obj=pandas_obj@propertydefcenter(self):# return the geographic center point of this DataFramelat=self._obj.latitudelon=self._obj.longitudereturn(float(lon.mean()),float(lat.mean()))defplot(self):# plot this array's data on a map, e.g., using CartopypassBack in an interactive IPython session:In [1]:ds=pd.DataFrame({""longitude"":np.linspace(0,10),...:""latitude"":np.linspace(0,20)})In [2]:ds.geo.centerOut[2]:(5.0, 10.0)In [3]:ds.geo.plot()# plots data on a map"
Pandas,Extensions,pandas.api.extensions.ExtensionDtype,"pandas.api.extensions.ExtensionDtype#classpandas.api.extensions.ExtensionDtype[source]#A custom data type, to be paired with an ExtensionArray.See alsoextensions.register_extension_dtypeRegister an ExtensionType with pandas as class decorator.extensions.ExtensionArrayAbstract base class for custom 1-D array types.NotesThe interface includes the following abstract methods that must
be implemented by subclasses:typenameconstruct_array_typeThe following attributes and methods influence the behavior of the dtype in
pandas operations_is_numeric_is_boolean_get_common_dtypeThena_valueclass attribute can be used to set the default NA value
for this type.numpy.nanis used by default.ExtensionDtypes are required to be hashable. The base class provides
a default implementation, which relies on the_metadataclass
attribute._metadatashould be a tuple containing the strings
that define your data type. For example, withPeriodDtypethat’s
thefreqattribute.If you have a parametrized dtype you should set the ``_metadata``
class property.Ideally, the attributes in_metadatawill match the
parameters to yourExtensionDtype.__init__(if any). If any of
the attributes in_metadatadon’t implement the standard__eq__or__hash__, the default implementations here will not
work.ExamplesFor interaction with Apache Arrow (pyarrow), a__from_arrow__method
can be implemented: this method receives a pyarrow Array or ChunkedArray
as only argument and is expected to return the appropriate pandas
ExtensionArray for this dtype and the passed values:>>>importpyarrow>>>frompandas.api.extensionsimportExtensionArray>>>classExtensionDtype:...def__from_arrow__(...self,...array:pyarrow.Array|pyarrow.ChunkedArray...)->ExtensionArray:......This class does not inherit from ‘abc.ABCMeta’ for performance reasons.
Methods and properties required by the interface raisepandas.errors.AbstractMethodErrorand noregistermethod is
provided for registering virtual subclasses.AttributeskindA character code (one of 'biufcmMOSUV'), default 'O'na_valueDefault NA value to use for this type.nameA string identifying the data type.namesOrdered list of field names, or None if there are no fields.typeThe scalar type for the array, e.g.Methodsconstruct_array_type()Return the array type associated with this dtype.construct_from_string(string)Construct this type from a string.empty(shape)Construct an ExtensionArray of this dtype with the given shape.is_dtype(dtype)Check if we match 'dtype'."
Pandas,Extensions,pandas.api.extensions.ExtensionArray,"pandas.api.extensions.ExtensionArray#classpandas.api.extensions.ExtensionArray[source]#Abstract base class for custom 1-D array types.pandas will recognize instances of this class as proper arrays
with a custom type and will not attempt to coerce them to objects. They
may be stored directly inside aDataFrameorSeries.NotesThe interface includes the following abstract methods that must be
implemented by subclasses:_from_sequence_from_factorized__getitem____len____eq__dtypenbytesisnatakecopy_concat_same_typeinterpolateA default repr displaying the type, (truncated) data, length,
and dtype is provided. It can be customized or replaced by
by overriding:__repr__ : A default repr for the ExtensionArray._formatter : Print scalars inside a Series or DataFrame.Some methods require casting the ExtensionArray to an ndarray of Python
objects withself.astype(object), which may be expensive. When
performance is a concern, we highly recommend overriding the following
methods:fillna_pad_or_backfilldropnauniquefactorize / _values_for_factorizeargsort, argmax, argmin / _values_for_argsortsearchsortedmapThe remaining methods implemented on this class should be performant,
as they only compose abstract methods. Still, a more efficient
implementation may be available, and these methods can be overridden.One can implement methods to handle array accumulations or reductions._accumulate_reduceOne can implement methods to handle parsing from strings that will be used
in methods such aspandas.io.parsers.read_csv._from_sequence_of_stringsThis class does not inherit from ‘abc.ABCMeta’ for performance reasons.
Methods and properties required by the interface raisepandas.errors.AbstractMethodErrorand noregistermethod is
provided for registering virtual subclasses.ExtensionArrays are limited to 1 dimension.They may be backed by none, one, or many NumPy arrays. For example,pandas.Categoricalis an extension array backed by two arrays,
one for codes and one for categories. An array of IPv6 address may
be backed by a NumPy structured array with two fields, one for the
lower 64 bits and one for the upper 64 bits. Or they may be backed
by some other storage type, like Python lists. Pandas makes no
assumptions on how the data are stored, just that it can be converted
to a NumPy array.
The ExtensionArray interface does not impose any rules on how this data
is stored. However, currently, the backing data cannot be stored in
attributes called.valuesor._valuesto ensure full compatibility
with pandas internals. But other names as.data,._data,._items, … can be freely used.If implementing NumPy’s__array_ufunc__interface, pandas expects
thatYou defer by returningNotImplementedwhen any Series are present
ininputs. Pandas will extract the arrays and call the ufunc again.You define a_HANDLED_TYPEStuple as an attribute on the class.
Pandas inspect this to determine whether the ufunc is valid for the
types present.SeeNumPy universal functionsfor more.By default, ExtensionArrays are not hashable. Immutable subclasses may
override this behavior.ExamplesPlease see the following:pandas-dev/pandasAttributesdtypeAn instance of ExtensionDtype.nbytesThe number of bytes needed to store this object in memory.ndimExtension Arrays are only allowed to be 1-dimensional.shapeReturn a tuple of the array dimensions.Methodsargsort(*[, ascending, kind, na_position])Return the indices that would sort this array.astype(dtype[, copy])Cast to a NumPy array or ExtensionArray with 'dtype'.copy()Return a copy of the array.dropna()Return ExtensionArray without NA values.factorize([use_na_sentinel])Encode the extension array as an enumerated type.fillna([value, method, limit, copy])Fill NA/NaN values using the specified method.equals(other)Return if another array is equivalent to this array.insert(loc, item)Insert an item at the given position.interpolate(*, method, axis, index, limit, ...)See DataFrame.interpolate.__doc__.isin(values)Pointwise comparison for set containment in the given values.isna()A 1-D array indicating if each value is missing.ravel([order])Return a flattened view on this array.repeat(repeats[, axis])Repeat elements of a ExtensionArray.searchsorted(value[, side, sorter])Find indices where elements should be inserted to maintain order.shift([periods, fill_value])Shift values by desired number.take(indices, *[, allow_fill, fill_value])Take elements from an array.tolist()Return a list of the values.unique()Compute the ExtensionArray of unique values.view([dtype])Return a view on the array._accumulate(name, *[, skipna])Return an ExtensionArray performing an accumulation operation._concat_same_type(to_concat)Concatenate multiple array of this dtype._formatter([boxed])Formatting function for scalar values._from_factorized(values, original)Reconstruct an ExtensionArray after factorization._from_sequence(scalars, *[, dtype, copy])Construct a new ExtensionArray from a sequence of scalars._from_sequence_of_strings(strings, *[, ...])Construct a new ExtensionArray from a sequence of strings._hash_pandas_object(*, encoding, hash_key, ...)Hook for hash_pandas_object._pad_or_backfill(*, method[, limit, copy])Pad or backfill values, used by Series/DataFrame ffill and bfill._reduce(name, *[, skipna, keepdims])Return a scalar result of performing the reduction operation._values_for_argsort()Return values for sorting._values_for_factorize()Return an array and missing value suitable for factorization."
Pandas,Extensions,pandas.arrays.NumpyExtensionArray,"pandas.arrays.NumpyExtensionArray#classpandas.arrays.NumpyExtensionArray(values,copy=False)[source]#A pandas ExtensionArray for NumPy data.This is mostly for internal compatibility, and is not especially
useful on its own.Parameters:valuesndarrayThe NumPy ndarray to wrap. Must be 1-dimensional.copybool, default FalseWhether to copyvalues.Examples>>>pd.arrays.NumpyExtensionArray(np.array([0,1,2,3]))<NumpyExtensionArray>[0, 1, 2, 3]Length: 4, dtype: int64AttributesNoneMethodsNone"
Pandas,Extensions,pandas.api.indexers.check_array_indexer,"pandas.api.indexers.check_array_indexer#pandas.api.indexers.check_array_indexer(array,indexer)[source]#Check ifindexeris a valid array indexer forarray.For a boolean mask,arrayandindexerare checked to have the same
length. The dtype is validated, and if it is an integer or boolean
ExtensionArray, it is checked if there are missing values present, and
it is converted to the appropriate numpy array. Other dtypes will raise
an error.Non-array indexers (integer, slice, Ellipsis, tuples, ..) are passed
through as is.Parameters:arrayarray-likeThe array that is being indexed (only used for the length).indexerarray-like or list-likeThe array-like that’s used to index. List-like input that is not yet
a numpy array or an ExtensionArray is converted to one. Other input
types are passed through as is.Returns:numpy.ndarrayThe validated indexer as a numpy array that can be used to index.Raises:IndexErrorWhen the lengths don’t match.ValueErrorWhenindexercannot be converted to a numpy ndarray to index
(e.g. presence of missing values).See alsoapi.types.is_bool_dtypeCheck ifkeyis of boolean dtype.ExamplesWhen checking a boolean mask, a boolean ndarray is returned when the
arguments are all valid.>>>mask=pd.array([True,False])>>>arr=pd.array([1,2])>>>pd.api.indexers.check_array_indexer(arr,mask)array([ True, False])An IndexError is raised when the lengths don’t match.>>>mask=pd.array([True,False,True])>>>pd.api.indexers.check_array_indexer(arr,mask)Traceback (most recent call last):...IndexError:Boolean index has wrong length: 3 instead of 2.NA values in a boolean array are treated as False.>>>mask=pd.array([True,pd.NA])>>>pd.api.indexers.check_array_indexer(arr,mask)array([ True, False])A numpy boolean mask will get passed through (if the length is correct):>>>mask=np.array([True,False])>>>pd.api.indexers.check_array_indexer(arr,mask)array([ True, False])Similarly for integer indexers, an integer ndarray is returned when it is
a valid indexer, otherwise an error is (for integer indexers, a matching
length is not required):>>>indexer=pd.array([0,2],dtype=""Int64"")>>>arr=pd.array([1,2,3])>>>pd.api.indexers.check_array_indexer(arr,indexer)array([0, 2])>>>indexer=pd.array([0,pd.NA],dtype=""Int64"")>>>pd.api.indexers.check_array_indexer(arr,indexer)Traceback (most recent call last):...ValueError:Cannot index with an integer indexer containing NA valuesFor non-integer/boolean dtypes, an appropriate error is raised:>>>indexer=np.array([0.,2.],dtype=""float64"")>>>pd.api.indexers.check_array_indexer(arr,indexer)Traceback (most recent call last):...IndexError:arrays used as indices must be of integer or boolean type"
