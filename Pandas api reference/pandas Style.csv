ライブラリ名,章,節,内容
Pandas,Style,pandas.io.formats.style.Styler,"pandas.io.formats.style.Styler#classpandas.io.formats.style.Styler(data,precision=None,table_styles=None,uuid=None,caption=None,table_attributes=None,cell_ids=True,na_rep=None,uuid_len=5,decimal=None,thousands=None,escape=None,formatter=None)[source]#Helps style a DataFrame or Series according to the data with HTML and CSS.Parameters:dataSeries or DataFrameData to be styled - either a Series or DataFrame.precisionint, optionalPrecision to round floats to. If not given defaults topandas.options.styler.format.precision.Changed in version 1.4.0.table_styleslist-like, default NoneList of {selector: (attr, value)} dicts; see Notes.uuidstr, default NoneA unique identifier to avoid CSS collisions; generated automatically.captionstr, tuple, default NoneString caption to attach to the table. Tuple only used for LaTeX dual captions.table_attributesstr, default NoneItems that show up in the opening<table>tag
in addition to automatic (by default) id.cell_idsbool, default TrueIf True, each cell will have anidattribute in their HTML tag.
Theidtakes the formT_<uuid>_row<num_row>_col<num_col>where<uuid>is the unique identifier,<num_row>is the row
number and<num_col>is the column number.na_repstr, optionalRepresentation for missing values.
Ifna_repis None, no special formatting is applied, and falls back topandas.options.styler.format.na_rep.uuid_lenint, default 5Ifuuidis not specified, the length of theuuidto randomly generate
expressed in hex characters, in range [0, 32].New in version 1.2.0.decimalstr, optionalCharacter used as decimal separator for floats, complex and integers. If not
given usespandas.options.styler.format.decimal.New in version 1.3.0.thousandsstr, optional, default NoneCharacter used as thousands separator for floats, complex and integers. If not
given usespandas.options.styler.format.thousands.New in version 1.3.0.escapestr, optionalUse ‘html’ to replace the characters&,<,>,', and""in cell display string with HTML-safe sequences.
Use ‘latex’ to replace the characters&,%,$,#,_,{,},~,^, and\in the cell display string with
LaTeX-safe sequences. Use ‘latex-math’ to replace the characters
the same way as in ‘latex’ mode, except for math substrings,
which either are surrounded by two characters$or start with
the character\(and end with\).
If not given usespandas.options.styler.format.escape.New in version 1.3.0.formatterstr, callable, dict, optionalObject to define how values are displayed. SeeStyler.format. If not given
usespandas.options.styler.format.formatter.New in version 1.4.0.See alsoDataFrame.styleReturn a Styler object containing methods for building a styled HTML representation for the DataFrame.NotesMost styling will be done by passing style functions intoStyler.applyorStyler.map. Style functions should
return values with strings containing CSS'attr:value'that will
be applied to the indicated cells.If using in the Jupyter notebook, Styler has defined a_repr_html_to automatically render itself. Otherwise call Styler.to_html to get
the generated HTML.CSS classes are attached to the generated HTMLIndex and Column names includeindex_nameandlevel<k>wherekis its level in a MultiIndexIndex label cells includerow_headingrow<n>wherenis the numeric position of the rowlevel<k>wherekis the level in a MultiIndexColumn label cells include
*col_heading*col<n>wherenis the numeric position of the column
*level<k>wherekis the level in a MultiIndexBlank cells includeblankData cells includedataTrimmed cells includecol_trimorrow_trim.Any, or all, or these classes can be renamed by using thecss_class_namesargument inStyler.set_table_classes, giving a value such as{“row”: “MY_ROW_CLASS”, “col_trim”: “”, “row_trim”: “”}.Examples>>>df=pd.DataFrame([[1.0,2.0,3.0],[4,5,6]],index=['a','b'],...columns=['A','B','C'])>>>pd.io.formats.style.Styler(df,precision=2,...caption=""My table"")Please see:Table Visualizationfor more examples.Attributesenv(Jinja2 jinja2.Environment)template_html(Jinja2 Template)template_html_table(Jinja2 Template)template_html_style(Jinja2 Template)template_latex(Jinja2 Template)loader(Jinja2 Loader)Methodsapply(func[, axis, subset])Apply a CSS-styling function column-wise, row-wise, or table-wise.apply_index(func[, axis, level])Apply a CSS-styling function to the index or column headers, level-wise.applymap(func[, subset])(DEPRECATED) Apply a CSS-styling function elementwise.applymap_index(func[, axis, level])(DEPRECATED) Apply a CSS-styling function to the index or column headers, elementwise.background_gradient([cmap, low, high, axis, ...])Color the background in a gradient style.bar([subset, axis, color, cmap, width, ...])Draw bar chart in the cell backgrounds.clear()Reset theStyler, removing any previously applied styles.concat(other)Append another Styler to combine the output into a single table.export()Export the styles applied to the current Styler.format([formatter, subset, na_rep, ...])Format the text display value of cells.format_index([formatter, axis, level, ...])Format the text display value of index labels or column headers.from_custom_template(searchpath[, ...])Factory function for creating a subclass ofStyler.hide([subset, axis, level, names])Hide the entire index / column headers, or specific rows / columns from display.highlight_between([subset, color, axis, ...])Highlight a defined range with a style.highlight_max([subset, color, axis, props])Highlight the maximum with a style.highlight_min([subset, color, axis, props])Highlight the minimum with a style.highlight_null([color, subset, props])Highlight missing values with a style.highlight_quantile([subset, color, axis, ...])Highlight values defined by a quantile with a style.map(func[, subset])Apply a CSS-styling function elementwise.map_index(func[, axis, level])Apply a CSS-styling function to the index or column headers, elementwise.pipe(func, *args, **kwargs)Applyfunc(self,*args,**kwargs), and return the result.relabel_index(labels[, axis, level])Relabel the index, or column header, keys to display a set of specified values.set_caption(caption)Set the text added to a<caption>HTML element.set_properties([subset])Set defined CSS-properties to each<td>HTML element for the given subset.set_sticky([axis, pixel_size, levels])Add CSS to permanently display the index or column headers in a scrolling frame.set_table_attributes(attributes)Set the table attributes added to the<table>HTML element.set_table_styles([table_styles, axis, ...])Set the table styles included within the<style>HTML element.set_td_classes(classes)Set theclassattribute of<td>HTML elements.set_tooltips(ttips[, props, css_class])Set the DataFrame of strings onStylergenerating:hovertooltips.set_uuid(uuid)Set the uuid applied toidattributes of HTML elements.text_gradient([cmap, low, high, axis, ...])Color the text in a gradient style.to_excel(excel_writer[, sheet_name, na_rep, ...])Write Styler to an Excel sheet.to_html([buf, table_uuid, table_attributes, ...])Write Styler to a file, buffer or string in HTML-CSS format.to_latex([buf, column_format, position, ...])Write Styler to a file, buffer or string in LaTeX format.to_string([buf, encoding, sparse_index, ...])Write Styler to a file, buffer or string in text format.use(styles)Set the styles on the current Styler."
Pandas,Style,pandas.io.formats.style.Styler.from_custom_template,"pandas.io.formats.style.Styler.from_custom_template#classmethodStyler.from_custom_template(searchpath,html_table=None,html_style=None)[source]#Factory function for creating a subclass ofStyler.Uses custom templates and Jinja environment.Changed in version 1.3.0.Parameters:searchpathstr or listPath or paths of directories containing the templates.html_tablestrName of your custom template to replace the html_table template.New in version 1.3.0.html_stylestrName of your custom template to replace the html_style template.New in version 1.3.0.Returns:MyStylersubclass of StylerHas the correctenv,``template_html``,template_html_tableandtemplate_html_styleclass attributes set.Examples>>>frompandas.io.formats.styleimportStyler>>>EasyStyler=Styler.from_custom_template(""path/to/template"",...""template.tpl"",...)>>>df=pd.DataFrame({""A"":[1,2]})>>>EasyStyler(df)Please see:Table Visualizationfor more examples."
Pandas,Style,pandas.io.formats.style.Styler.env,pandas.io.formats.style.Styler.env#Styler.env=<jinja2.environment.Environmentobject>#
Pandas,Style,pandas.io.formats.style.Styler.template_html,pandas.io.formats.style.Styler.template_html#Styler.template_html=<Template'html.tpl'>#
Pandas,Style,pandas.io.formats.style.Styler.template_html_style,pandas.io.formats.style.Styler.template_html_style#Styler.template_html_style=<Template'html_style.tpl'>#
Pandas,Style,pandas.io.formats.style.Styler.template_html_table,pandas.io.formats.style.Styler.template_html_table#Styler.template_html_table=<Template'html_table.tpl'>#
Pandas,Style,pandas.io.formats.style.Styler.template_latex,pandas.io.formats.style.Styler.template_latex#Styler.template_latex=<Template'latex.tpl'>#
Pandas,Style,pandas.io.formats.style.Styler.template_string,pandas.io.formats.style.Styler.template_string#Styler.template_string=<Template'string.tpl'>#
Pandas,Style,pandas.io.formats.style.Styler.loader,pandas.io.formats.style.Styler.loader#Styler.loader=<jinja2.loaders.PackageLoaderobject>#
Pandas,Style,pandas.io.formats.style.Styler.apply,"pandas.io.formats.style.Styler.apply#Styler.apply(func,axis=0,subset=None,**kwargs)[source]#Apply a CSS-styling function column-wise, row-wise, or table-wise.Updates the HTML representation with the result.Parameters:funcfunctionfuncshould take a Series ifaxisin [0,1] and return a list-like
object of same length, or a Series, not necessarily of same length, with
valid index labels consideringsubset.funcshould take a DataFrame ifaxisisNoneand return either
an ndarray with the same shape or a DataFrame, not necessarily of the same
shape, with valid index and columns labels consideringsubset.Changed in version 1.3.0.Changed in version 1.4.0.axis{0 or ‘index’, 1 or ‘columns’, None}, default 0Apply to each column (axis=0or'index'), to each row
(axis=1or'columns'), or to the entire DataFrame at once
withaxis=None.subsetlabel, array-like, IndexSlice, optionalA valid 2d input toDataFrame.loc[<subset>], or, in the case of a 1d input
or single key, toDataFrame.loc[:, <subset>]where the columns are
prioritised, to limitdatatobeforeapplying the function.**kwargsdictPass along tofunc.Returns:StylerSee alsoStyler.map_indexApply a CSS-styling function to headers elementwise.Styler.apply_indexApply a CSS-styling function to headers level-wise.Styler.mapApply a CSS-styling function elementwise.NotesThe elements of the output offuncshould be CSS styles as strings, in the
format ‘attribute: value; attribute2: value2; …’ or,
if nothing is to be applied to that element, an empty string orNone.This is similar toDataFrame.apply, except thataxis=Noneapplies the function to the entire DataFrame at once,
rather than column-wise or row-wise.Examples>>>defhighlight_max(x,color):...returnnp.where(x==np.nanmax(x.to_numpy()),f""color:{color};"",None)>>>df=pd.DataFrame(np.random.randn(5,2),columns=[""A"",""B""])>>>df.style.apply(highlight_max,color='red')>>>df.style.apply(highlight_max,color='blue',axis=1)>>>df.style.apply(highlight_max,color='green',axis=None)Usingsubsetto restrict application to a single column or multiple columns>>>df.style.apply(highlight_max,color='red',subset=""A"")...>>>df.style.apply(highlight_max,color='red',subset=[""A"",""B""])...Using a 2d input tosubsetto select rows in addition to columns>>>df.style.apply(highlight_max,color='red',subset=([0,1,2],slice(None)))...>>>df.style.apply(highlight_max,color='red',subset=(slice(0,5,2),""A""))...Using a function which returns a Series / DataFrame of unequal length but
containing valid index labels>>>df=pd.DataFrame([[1,2],[3,4],[4,6]],index=[""A1"",""A2"",""Total""])>>>total_style=pd.Series(""font-weight: bold;"",index=[""Total""])>>>df.style.apply(lambdas:total_style)SeeTable Visualizationuser guide for
more details."
Pandas,Style,pandas.io.formats.style.Styler.map,"pandas.io.formats.style.Styler.map#Styler.map(func,subset=None,**kwargs)[source]#Apply a CSS-styling function elementwise.Updates the HTML representation with the result.Parameters:funcfunctionfuncshould take a scalar and return a string.subsetlabel, array-like, IndexSlice, optionalA valid 2d input toDataFrame.loc[<subset>], or, in the case of a 1d input
or single key, toDataFrame.loc[:, <subset>]where the columns are
prioritised, to limitdatatobeforeapplying the function.**kwargsdictPass along tofunc.Returns:StylerSee alsoStyler.map_indexApply a CSS-styling function to headers elementwise.Styler.apply_indexApply a CSS-styling function to headers level-wise.Styler.applyApply a CSS-styling function column-wise, row-wise, or table-wise.NotesThe elements of the output offuncshould be CSS styles as strings, in the
format ‘attribute: value; attribute2: value2; …’ or,
if nothing is to be applied to that element, an empty string orNone.Examples>>>defcolor_negative(v,color):...returnf""color:{color};""ifv<0elseNone>>>df=pd.DataFrame(np.random.randn(5,2),columns=[""A"",""B""])>>>df.style.map(color_negative,color='red')Usingsubsetto restrict application to a single column or multiple columns>>>df.style.map(color_negative,color='red',subset=""A"")...>>>df.style.map(color_negative,color='red',subset=[""A"",""B""])...Using a 2d input tosubsetto select rows in addition to columns>>>df.style.map(color_negative,color='red',...subset=([0,1,2],slice(None)))>>>df.style.map(color_negative,color='red',subset=(slice(0,5,2),""A""))...SeeTable Visualizationuser guide for
more details."
Pandas,Style,pandas.io.formats.style.Styler.apply_index,"pandas.io.formats.style.Styler.apply_index#Styler.apply_index(func,axis=0,level=None,**kwargs)[source]#Apply a CSS-styling function to the index or column headers, level-wise.Updates the HTML representation with the result.New in version 1.4.0.New in version 2.1.0:Styler.applymap_index was deprecated and renamed to Styler.map_index.Parameters:funcfunctionfuncshould take a Series and return a string array of the same length.axis{0, 1, “index”, “columns”}The headers over which to apply the function.levelint, str, list, optionalIf index is MultiIndex the level(s) over which to apply the function.**kwargsdictPass along tofunc.Returns:StylerSee alsoStyler.map_indexApply a CSS-styling function to headers elementwise.Styler.applyApply a CSS-styling function column-wise, row-wise, or table-wise.Styler.mapApply a CSS-styling function elementwise.NotesEach input tofuncwill be the index as a Series, if an Index, or a level of a MultiIndex. The output offuncshould be
an identically sized array of CSS styles as strings, in the format ‘attribute: value; attribute2: value2; …’
or, if nothing is to be applied to that element, an empty string orNone.ExamplesBasic usage to conditionally highlight values in the index.>>>df=pd.DataFrame([[1,2],[3,4]],index=[""A"",""B""])>>>defcolor_b(s):...returnnp.where(s==""B"",""background-color: yellow;"","""")>>>df.style.apply_index(color_b)Selectively applying to specific levels of MultiIndex columns.>>>midx=pd.MultiIndex.from_product([['ix','jy'],[0,1],['x3','z4']])>>>df=pd.DataFrame([np.arange(8)],columns=midx)>>>defhighlight_x(s):...return[""background-color: yellow;""if""x""invelse""""forvins]>>>df.style.apply_index(highlight_x,axis=""columns"",level=[0,2])..."
Pandas,Style,pandas.io.formats.style.Styler.map_index,"pandas.io.formats.style.Styler.map_index#Styler.map_index(func,axis=0,level=None,**kwargs)[source]#Apply a CSS-styling function to the index or column headers, elementwise.Updates the HTML representation with the result.New in version 1.4.0.New in version 2.1.0:Styler.applymap_index was deprecated and renamed to Styler.map_index.Parameters:funcfunctionfuncshould take a scalar and return a string.axis{0, 1, “index”, “columns”}The headers over which to apply the function.levelint, str, list, optionalIf index is MultiIndex the level(s) over which to apply the function.**kwargsdictPass along tofunc.Returns:StylerSee alsoStyler.apply_indexApply a CSS-styling function to headers level-wise.Styler.applyApply a CSS-styling function column-wise, row-wise, or table-wise.Styler.mapApply a CSS-styling function elementwise.NotesEach input tofuncwill be an index value, if an Index, or a level value of a MultiIndex. The output offuncshould be
CSS styles as a string, in the format ‘attribute: value; attribute2: value2; …’
or, if nothing is to be applied to that element, an empty string orNone.ExamplesBasic usage to conditionally highlight values in the index.>>>df=pd.DataFrame([[1,2],[3,4]],index=[""A"",""B""])>>>defcolor_b(s):...return""background-color: yellow;""ifv==""B""elseNone>>>df.style.map_index(color_b)Selectively applying to specific levels of MultiIndex columns.>>>midx=pd.MultiIndex.from_product([['ix','jy'],[0,1],['x3','z4']])>>>df=pd.DataFrame([np.arange(8)],columns=midx)>>>defhighlight_x(v):...return""background-color: yellow;""if""x""invelseNone>>>df.style.map_index(highlight_x,axis=""columns"",level=[0,2])..."
Pandas,Style,pandas.io.formats.style.Styler.format,"pandas.io.formats.style.Styler.format#Styler.format(formatter=None,subset=None,na_rep=None,precision=None,decimal='.',thousands=None,escape=None,hyperlinks=None)[source]#Format the text display value of cells.Parameters:formatterstr, callable, dict or NoneObject to define how values are displayed. See notes.subsetlabel, array-like, IndexSlice, optionalA valid 2d input toDataFrame.loc[<subset>], or, in the case of a 1d input
or single key, toDataFrame.loc[:, <subset>]where the columns are
prioritised, to limitdatatobeforeapplying the function.na_repstr, optionalRepresentation for missing values.
Ifna_repis None, no special formatting is applied.precisionint, optionalFloating point precision to use for display purposes, if not determined by
the specifiedformatter.New in version 1.3.0.decimalstr, default “.”Character used as decimal separator for floats, complex and integers.New in version 1.3.0.thousandsstr, optional, default NoneCharacter used as thousands separator for floats, complex and integers.New in version 1.3.0.escapestr, optionalUse ‘html’ to replace the characters&,<,>,', and""in cell display string with HTML-safe sequences.
Use ‘latex’ to replace the characters&,%,$,#,_,{,},~,^, and\in the cell display string with
LaTeX-safe sequences.
Use ‘latex-math’ to replace the characters the same way as in ‘latex’ mode,
except for math substrings, which either are surrounded
by two characters$or start with the character\(and
end with\). Escaping is done beforeformatter.New in version 1.3.0.hyperlinks{“html”, “latex”}, optionalConvert string patterns containinghttps://,http://,ftp://or www. to
HTML <a> tags as clickable URL hyperlinks if “html”, or LaTeX href
commands if “latex”.New in version 1.4.0.Returns:StylerSee alsoStyler.format_indexFormat the text display value of index labels.NotesThis method assigns a formatting function,formatter, to each cell in the
DataFrame. IfformatterisNone, then the default formatter is used.
If a callable then that function should take a data value as input and return
a displayable representation, such as a string. Ifformatteris
given as a string this is assumed to be a valid Python format specification
and is wrapped to a callable asstring.format(x). If adictis given,
keys should correspond to column names, and values should be string or
callable, as above.The default formatter currently expresses floats and complex numbers with the
pandas display precision unless using theprecisionargument here. The
default formatter does not adjust the representation of missing values unless
thena_repargument is used.Thesubsetargument defines which region to apply the formatting function
to. If theformatterargument is given in dict form but does not include
all columns within the subset then these columns will have the default formatter
applied. Any columns in the formatter dict excluded from the subset will
be ignored.When using aformatterstring the dtypes must be compatible, otherwise aValueErrorwill be raised.When instantiating a Styler, default formatting can be applied be setting thepandas.options:styler.format.formatter: default None.styler.format.na_rep: default None.styler.format.precision: default 6.styler.format.decimal: default “.”.styler.format.thousands: default None.styler.format.escape: default None.WarningStyler.formatis ignored when using the output formatStyler.to_excel,
since Excel and Python have inherrently different formatting structures.
However, it is possible to use thenumber-formatpseudo CSS attribute
to force Excel permissible formatting. See examples.ExamplesUsingna_repandprecisionwith the defaultformatter>>>df=pd.DataFrame([[np.nan,1.0,'A'],[2.0,np.nan,3.0]])>>>df.style.format(na_rep='MISS',precision=3)0       1       20    MISS   1.000       A1   2.000    MISS   3.000Using aformatterspecification on consistent column dtypes>>>df.style.format('{:.2f}',na_rep='MISS',subset=[0,1])0      1          20    MISS   1.00          A1    2.00   MISS   3.000000Using the defaultformatterfor unspecified columns>>>df.style.format({0:'{:.2f}',1:'£{:.1f}'},na_rep='MISS',precision=1)...0      1     20    MISS   £ 1.0     A1    2.00    MISS   3.0Multiplena_reporprecisionspecifications under the defaultformatter.>>>(df.style.format(na_rep='MISS',precision=1,subset=[0])....format(na_rep='PASS',precision=2,subset=[1,2]))0      1      20    MISS   1.00      A1     2.0   PASS   3.00Using a callableformatterfunction.>>>func=lambdas:'STRING'ifisinstance(s,str)else'FLOAT'>>>df.style.format({0:'{:.1f}',2:func},precision=4,na_rep='MISS')...0        1        20    MISS   1.0000   STRING1     2.0     MISS    FLOATUsing aformatterwith HTMLescapeandna_rep.>>>df=pd.DataFrame([['<div></div>','""A&B""',None]])>>>s=df.style.format(...'<a href=""a.com/{0}"">{0}</a>',escape=""html"",na_rep=""NA""...)>>>s.to_html()...<td .. ><a href=""a.com/&lt;div&gt;&lt;/div&gt;"">&lt;div&gt;&lt;/div&gt;</a></td><td .. ><a href=""a.com/&#34;A&amp;B&#34;"">&#34;A&amp;B&#34;</a></td><td .. >NA</td>...Using aformatterwithescapein ‘latex’ mode.>>>df=pd.DataFrame([[""123""],[""~ ^""],[""$%#""]])>>>df.style.format(""\\textbf{{{}}}"",escape=""latex"").to_latex()...\begin{tabular}{ll}& 0 \\0 & \textbf{123} \\1 & \textbf{\textasciitilde \space \textasciicircum } \\2 & \textbf{\$\%\#} \\\end{tabular}Applyingescapein ‘latex-math’ mode. In the example below
we enter math mode using the character$.>>>df=pd.DataFrame([[r""$\sum_{i=1}^{10}a_i$ a~b $\alpha\...= \frac{\beta}{\zeta^2}$""],[""%#^ $ \$x^2 $""]])>>>df.style.format(escape=""latex-math"").to_latex()...\begin{tabular}{ll}& 0 \\0 & $\sum_{i=1}^{10} a_i$ a\textasciitilde b $\alpha = \frac{\beta}{\zeta^2}$ \\1 & \%\#\textasciicircum \space $ \$x^2 $ \\\end{tabular}We can use the character\(to enter math mode and the character\)to close math mode.>>>df=pd.DataFrame([[r""\(\sum_{i=1}^{10}a_i\) a~b \(\alpha\...= \frac{\beta}{\zeta^2}\)""],[""%#^ \( \$x^2 \)""]])>>>df.style.format(escape=""latex-math"").to_latex()...\begin{tabular}{ll}& 0 \\0 & \(\sum_{i=1}^{10} a_i\) a\textasciitilde b \(\alpha= \frac{\beta}{\zeta^2}\) \\1 & \%\#\textasciicircum \space \( \$x^2 \) \\\end{tabular}If we have in one DataFrame cell a combination of both shorthands
for math formulas, the shorthand with the sign$will be applied.>>>df=pd.DataFrame([[r""\( x^2 \)  $x^2$""],\...[r""$\frac{\beta}{\zeta}$ \(\frac{\beta}{\zeta}\)""]])>>>df.style.format(escape=""latex-math"").to_latex()...\begin{tabular}{ll}& 0 \\0 & \textbackslash ( x\textasciicircum 2 \textbackslash )  $x^2$ \\1 & $\frac{\beta}{\zeta}$ \textbackslash (\textbackslashfrac\{\textbackslash beta\}\{\textbackslash zeta\}\textbackslash ) \\\end{tabular}Pandas defines anumber-formatpseudo CSS attribute instead of the.formatmethod to createto_excelpermissible formatting. Note that semi-colons are
CSS protected characters but used as separators in Excel’s format string.
Replace semi-colons with the section separator character (ASCII-245) when
defining the formatting here.>>>df=pd.DataFrame({""A"":[1,0,-1]})>>>pseudo_css=""number-format: 0§[Red](0)§-§@;"">>>filename=""formatted_file.xlsx"">>>df.style.map(lambdav:pseudo_css).to_excel(filename)"
Pandas,Style,pandas.io.formats.style.Styler.format_index,"pandas.io.formats.style.Styler.format_index#Styler.format_index(formatter=None,axis=0,level=None,na_rep=None,precision=None,decimal='.',thousands=None,escape=None,hyperlinks=None)[source]#Format the text display value of index labels or column headers.New in version 1.4.0.Parameters:formatterstr, callable, dict or NoneObject to define how values are displayed. See notes.axis{0, “index”, 1, “columns”}Whether to apply the formatter to the index or column headers.levelint, str, listThe level(s) over which to apply the generic formatter.na_repstr, optionalRepresentation for missing values.
Ifna_repis None, no special formatting is applied.precisionint, optionalFloating point precision to use for display purposes, if not determined by
the specifiedformatter.decimalstr, default “.”Character used as decimal separator for floats, complex and integers.thousandsstr, optional, default NoneCharacter used as thousands separator for floats, complex and integers.escapestr, optionalUse ‘html’ to replace the characters&,<,>,', and""in cell display string with HTML-safe sequences.
Use ‘latex’ to replace the characters&,%,$,#,_,{,},~,^, and\in the cell display string with
LaTeX-safe sequences.
Escaping is done beforeformatter.hyperlinks{“html”, “latex”}, optionalConvert string patterns containinghttps://,http://,ftp://or www. to
HTML <a> tags as clickable URL hyperlinks if “html”, or LaTeX href
commands if “latex”.Returns:StylerSee alsoStyler.formatFormat the text display value of data cells.NotesThis method assigns a formatting function,formatter, to each level label
in the DataFrame’s index or column headers. IfformatterisNone,
then the default formatter is used.
If a callable then that function should take a label value as input and return
a displayable representation, such as a string. Ifformatteris
given as a string this is assumed to be a valid Python format specification
and is wrapped to a callable asstring.format(x). If adictis given,
keys should correspond to MultiIndex level numbers or names, and values should
be string or callable, as above.The default formatter currently expresses floats and complex numbers with the
pandas display precision unless using theprecisionargument here. The
default formatter does not adjust the representation of missing values unless
thena_repargument is used.Thelevelargument defines which levels of a MultiIndex to apply the
method to. If theformatterargument is given in dict form but does
not include all levels within the level argument then these unspecified levels
will have the default formatter applied. Any levels in the formatter dict
specifically excluded from the level argument will be ignored.When using aformatterstring the dtypes must be compatible, otherwise aValueErrorwill be raised.WarningStyler.format_indexis ignored when using the output formatStyler.to_excel, since Excel and Python have inherrently different
formatting structures.
However, it is possible to use thenumber-formatpseudo CSS attribute
to force Excel permissible formatting. See documentation forStyler.format.ExamplesUsingna_repandprecisionwith the defaultformatter>>>df=pd.DataFrame([[1,2,3]],columns=[2.0,np.nan,4.0])>>>df.style.format_index(axis=1,na_rep='MISS',precision=3)2.000    MISS   4.0000       1       2       3Using aformatterspecification on consistent dtypes in a level>>>df.style.format_index('{:.2f}',axis=1,na_rep='MISS')2.00   MISS    4.000       1      2       3Using the defaultformatterfor unspecified levels>>>df=pd.DataFrame([[1,2,3]],...columns=pd.MultiIndex.from_arrays([[""a"",""a"",""b""],[2,np.nan,4]]))>>>df.style.format_index({0:lambdav:v.upper()},axis=1,precision=1)...A       B2.0    nan     4.00       1      2       3Using a callableformatterfunction.>>>func=lambdas:'STRING'ifisinstance(s,str)else'FLOAT'>>>df.style.format_index(func,axis=1,na_rep='MISS')...STRING  STRINGFLOAT   MISS   FLOAT0       1      2       3Using aformatterwith HTMLescapeandna_rep.>>>df=pd.DataFrame([[1,2,3]],columns=['""A""','A&B',None])>>>s=df.style.format_index('${0}',axis=1,escape=""html"",na_rep=""NA"")...<th .. >$ &#34;A&#34;</th><th .. >$ A&amp;B</th><th .. >NA</td>...Using aformatterwith LaTeXescape.>>>df=pd.DataFrame([[1,2,3]],columns=[""123"",""~"",""$%#""])>>>df.style.format_index(""\\textbf{{{}}}"",escape=""latex"",axis=1).to_latex()...\begin{tabular}{lrrr}{} & {\textbf{123}} & {\textbf{\textasciitilde }} & {\textbf{\$\%\#}} \\0 & 1 & 2 & 3 \\\end{tabular}"
Pandas,Style,pandas.io.formats.style.Styler.relabel_index,"pandas.io.formats.style.Styler.relabel_index#Styler.relabel_index(labels,axis=0,level=None)[source]#Relabel the index, or column header, keys to display a set of specified values.New in version 1.5.0.Parameters:labelslist-like or IndexNew labels to display. Must have same length as the underlying values not
hidden.axis{“index”, 0, “columns”, 1}Apply to the index or columns.levelint, str, list, optionalThe level(s) over which to apply the new labels. IfNonewill apply
to all levels of an Index or MultiIndex which are not hidden.Returns:StylerSee alsoStyler.format_indexFormat the text display value of index or column headers.Styler.hideHide the index, column headers, or specified data from display.NotesAs part of Styler, this method allows the display of an index to be
completely user-specified without affecting the underlying DataFrame data,
index, or column headers. This means that the flexibility of indexing is
maintained whilst the final display is customisable.Since Styler is designed to be progressively constructed with method chaining,
this method is adapted to react to thecurrently specified hidden elements.
This is useful because it means one does not have to specify all the new
labels if the majority of an index, or column headers, have already been hidden.
The following produce equivalent display (note the length oflabelsin
each case).# relabel first, then hidedf=pd.DataFrame({""col"":[""a"",""b"",""c""]})df.style.relabel_index([""A"",""B"",""C""]).hide([0,1])# hide first, then relabeldf=pd.DataFrame({""col"":[""a"",""b"",""c""]})df.style.hide([0,1]).relabel_index([""C""])This method should be used, rather thanStyler.format_index(), in one of
the following cases (see examples):A specified set of labels are required which are not a function of the
underlying index keys.The function of the underlying index keys requires a counter variable,
such as those available upon enumeration.ExamplesBasic use>>>df=pd.DataFrame({""col"":[""a"",""b"",""c""]})>>>df.style.relabel_index([""A"",""B"",""C""])colA      aB      bC      cChaining with pre-hidden elements>>>df.style.hide([0,1]).relabel_index([""C""])colC      cUsing a MultiIndex>>>midx=pd.MultiIndex.from_product([[0,1],[0,1],[0,1]])>>>df=pd.DataFrame({""col"":list(range(8))},index=midx)>>>styler=df.stylecol0  0  0     01     11  0     21     31  0  0     41     51  0     61     7>>>styler.hide((midx.get_level_values(0)==0)|(midx.get_level_values(1)==0))...>>>styler.hide(level=[0,1])>>>styler.relabel_index([""binary6"",""binary7""])colbinary6     6binary7     7We can also achieve the above by indexing first and then re-labeling>>>styler=df.loc[[(1,1,0),(1,1,1)]].style>>>styler.hide(level=[0,1]).relabel_index([""binary6"",""binary7""])...colbinary6     6binary7     7Defining a formatting function which uses an enumeration counter. Also note
that the value of the index key is passed in the case of string labels so it
can also be inserted into the label, using curly brackets (or double curly
brackets if the string if pre-formatted),>>>df=pd.DataFrame({""samples"":np.random.rand(10)})>>>styler=df.loc[np.random.randint(0,10,3)].style>>>styler.relabel_index([f""sample{i+1}({{}})""foriinrange(3)])...samplessample1 (5)     0.315811sample2 (0)     0.495941sample3 (2)     0.067946"
Pandas,Style,pandas.io.formats.style.Styler.hide,"pandas.io.formats.style.Styler.hide#Styler.hide(subset=None,axis=0,level=None,names=False)[source]#Hide the entire index / column headers, or specific rows / columns from display.New in version 1.4.0.Parameters:subsetlabel, array-like, IndexSlice, optionalA valid 1d input or single key along the axis withinDataFrame.loc[<subset>, :]orDataFrame.loc[:, <subset>]depending
uponaxis, to limitdatato select hidden rows / columns.axis{“index”, 0, “columns”, 1}Apply to the index or columns.levelint, str, listThe level(s) to hide in a MultiIndex if hiding the entire index / column
headers. Cannot be used simultaneously withsubset.namesboolWhether to hide the level name(s) of the index / columns headers in the case
it (or at least one the levels) remains visible.Returns:StylerNotesWarningThis method only works with the output methodsto_html,to_stringandto_latex.Other output methods, includingto_excel, ignore this hiding method
and will display all data.This method has multiple functionality depending upon the combination
of thesubset,levelandnamesarguments (see examples). Theaxisargument is used only to control whether the method is applied to row
or column headers:Argument combinations#subsetlevelnamesEffectNoneNoneFalseThe axis-Index is hidden entirely.NoneNoneTrueOnly the axis-Index names are hidden.NoneInt, Str, ListFalseSpecified axis-MultiIndex levels are hidden entirely.NoneInt, Str, ListTrueSpecified axis-MultiIndex levels are hidden entirely and the names of
remaining axis-MultiIndex levels.SubsetNoneFalseThe specified data rows/columns are hidden, but the axis-Index itself,
and names, remain unchanged.SubsetNoneTrueThe specified data rows/columns and axis-Index names are hidden, but
the axis-Index itself remains unchanged.SubsetInt, Str, ListBooleanValueError: cannot supplysubsetandlevelsimultaneously.Note this method only hides the identifed elements so can be chained to hide
multiple elements in sequence.ExamplesSimple application hiding specific rows:>>>df=pd.DataFrame([[1,2],[3,4],[5,6]],index=[""a"",""b"",""c""])>>>df.style.hide([""a"",""b""])0    1c    5    6Hide the index and retain the data values:>>>midx=pd.MultiIndex.from_product([[""x"",""y""],[""a"",""b"",""c""]])>>>df=pd.DataFrame(np.random.randn(6,6),index=midx,columns=midx)>>>df.style.format(""{:.1f}"").hide()x                    ya      b      c      a      b      c0.1    0.0    0.4    1.3    0.6   -1.40.7    1.0    1.3    1.5   -0.0   -0.21.4   -0.8    1.6   -0.2   -0.4   -0.30.4    1.0   -0.2   -0.8   -1.2    1.1-0.6    1.2    1.8    1.9    0.3    0.30.8    0.5   -0.3    1.2    2.2   -0.8Hide specific rows in a MultiIndex but retain the index:>>>df.style.format(""{:.1f}"").hide(subset=(slice(None),[""a"",""c""]))...x                    ya      b      c      a      b      cx   b    0.7    1.0    1.3    1.5   -0.0   -0.2y   b   -0.6    1.2    1.8    1.9    0.3    0.3Hide specific rows and the index through chaining:>>>df.style.format(""{:.1f}"").hide(subset=(slice(None),[""a"",""c""])).hide()...x                    ya      b      c      a      b      c0.7    1.0    1.3    1.5   -0.0   -0.2-0.6    1.2    1.8    1.9    0.3    0.3Hide a specific level:>>>df.style.format(""{:,.1f}"").hide(level=1)x                    ya      b      c      a      b      cx    0.1    0.0    0.4    1.3    0.6   -1.40.7    1.0    1.3    1.5   -0.0   -0.21.4   -0.8    1.6   -0.2   -0.4   -0.3y    0.4    1.0   -0.2   -0.8   -1.2    1.1-0.6    1.2    1.8    1.9    0.3    0.30.8    0.5   -0.3    1.2    2.2   -0.8Hiding just the index level names:>>>df.index.names=[""lev0"",""lev1""]>>>df.style.format(""{:,.1f}"").hide(names=True)x                    ya      b      c      a      b      cx   a    0.1    0.0    0.4    1.3    0.6   -1.4b    0.7    1.0    1.3    1.5   -0.0   -0.2c    1.4   -0.8    1.6   -0.2   -0.4   -0.3y   a    0.4    1.0   -0.2   -0.8   -1.2    1.1b   -0.6    1.2    1.8    1.9    0.3    0.3c    0.8    0.5   -0.3    1.2    2.2   -0.8Examples all produce equivalently transposed effects withaxis=""columns""."
Pandas,Style,pandas.io.formats.style.Styler.concat,"pandas.io.formats.style.Styler.concat#Styler.concat(other)[source]#Append another Styler to combine the output into a single table.New in version 1.5.0.Parameters:otherStylerThe other Styler object which has already been styled and formatted. The
data for this Styler must have the same columns as the original, and the
number of index levels must also be the same to render correctly.Returns:StylerNotesThe purpose of this method is to extend existing styled dataframes with other
metrics that may be useful but may not conform to the original’s structure.
For example adding a sub total row, or displaying metrics such as means,
variance or counts.Styles that are applied using theapply,map,apply_indexandmap_index, and formatting applied withformatandformat_indexwill be preserved.WarningOnly the output methodsto_html,to_stringandto_latexcurrently work with concatenated Stylers.Other output methods, includingto_excel,do notwork with
concatenated Stylers.The following should be noted:table_styles,table_attributes,captionanduuidare all
inherited from the original Styler and notother.hidden columns and hidden index levels will be inherited from the
original Stylercsswill be inherited from the original Styler, and the value of
keysdata,row_headingandrowwill be prepended withfoot0_. If more concats are chained, their styles will be prepended
withfoot1_, ‘’foot_2’’, etc., and if a concatenated style have
another concatanated style, the second style will be prepended withfoot{parent}_foot{child}_.A common use case is to concatenate user defined functions withDataFrame.aggor with described statistics viaDataFrame.describe.
See examples.ExamplesA common use case is adding totals rows, or otherwise, via methods calculated
inDataFrame.agg.>>>df=pd.DataFrame([[4,6],[1,9],[3,4],[5,5],[9,6]],...columns=[""Mike"",""Jim""],...index=[""Mon"",""Tue"",""Wed"",""Thurs"",""Fri""])>>>styler=df.style.concat(df.agg([""sum""]).style)Since the concatenated object is a Styler the existing functionality can be
used to conditionally format it as well as the original.>>>descriptors=df.agg([""sum"",""mean"",lambdas:s.dtype])>>>descriptors.index=[""Total"",""Average"",""dtype""]>>>other=(descriptors.style....highlight_max(axis=1,subset=([""Total"",""Average""],slice(None)))....format(subset=(""Average"",slice(None)),precision=2,decimal="","")....map(lambdav:""font-weight: bold;""))>>>styler=(df.style....highlight_max(color=""salmon"")....set_table_styles([{""selector"":"".foot_row0"",...""props"":""border-top: 1px solid black;""}]))>>>styler.concat(other)Whenotherhas fewer index levels than the original Styler it is possible
to extend the index inother, with placeholder levels.>>>df=pd.DataFrame([[1],[2]],...index=pd.MultiIndex.from_product([[0],[1,2]]))>>>descriptors=df.agg([""sum""])>>>descriptors.index=pd.MultiIndex.from_product([[""""],descriptors.index])>>>df.style.concat(descriptors.style)"
Pandas,Style,pandas.io.formats.style.Styler.set_td_classes,"pandas.io.formats.style.Styler.set_td_classes#Styler.set_td_classes(classes)[source]#Set theclassattribute of<td>HTML elements.Parameters:classesDataFrameDataFrame containing strings that will be translated to CSS classes,
mapped by identical column and index key values that must exist on the
underlying Styler data. None, NaN values, and empty strings will
be ignored and not affect the rendered HTML.Returns:StylerSee alsoStyler.set_table_stylesSet the table styles included within the<style>HTML element.Styler.set_table_attributesSet the table attributes added to the<table>HTML element.NotesCan be used in combination withStyler.set_table_stylesto define an
internal CSS solution without reference to external CSS files.Examples>>>df=pd.DataFrame(data=[[1,2,3],[4,5,6]],columns=[""A"",""B"",""C""])>>>classes=pd.DataFrame([...[""min-val red"","""",""blue""],...[""red"",None,""blue max-val""]...],index=df.index,columns=df.columns)>>>df.style.set_td_classes(classes)UsingMultiIndexcolumns and aclassesDataFrameas a subset of the
underlying,>>>df=pd.DataFrame([[1,2],[3,4]],index=[""a"",""b""],...columns=[[""level0"",""level0""],[""level1a"",""level1b""]])>>>classes=pd.DataFrame([""min-val""],index=[""a""],...columns=[[""level0""],[""level1a""]])>>>df.style.set_td_classes(classes)Form of the output with new additional css classes,>>>frompandas.io.formats.styleimportStyler>>>df=pd.DataFrame([[1]])>>>css=pd.DataFrame([[""other-class""]])>>>s=Styler(df,uuid=""_"",cell_ids=False).set_td_classes(css)>>>s.hide(axis=0).to_html()'<style type=""text/css""></style>''<table id=""T__"">''  <thead>''    <tr><th class=""col_heading level0 col0"" >0</th></tr>''  </thead>''  <tbody>''    <tr><td class=""data row0 col0 other-class"" >1</td></tr>''  </tbody>''</table>'"
Pandas,Style,pandas.io.formats.style.Styler.set_table_styles,"pandas.io.formats.style.Styler.set_table_styles#Styler.set_table_styles(table_styles=None,axis=0,overwrite=True,css_class_names=None)[source]#Set the table styles included within the<style>HTML element.This function can be used to style the entire table, columns, rows or
specific HTML selectors.Parameters:table_styleslist or dictIf supplying a list, each individual table_style should be a
dictionary withselectorandpropskeys.selectorshould be a CSS selector that the style will be applied to
(automatically prefixed by the table’s UUID) andpropsshould be a list of tuples with(attribute,value).
If supplying a dict, the dict keys should correspond to
column names or index values, depending upon the specifiedaxisargument. These will be mapped to row or col CSS
selectors. MultiIndex values as dict keys should be
in their respective tuple form. The dict values should be
a list as specified in the form with CSS selectors and
props that will be applied to the specified row or column.Changed in version 1.2.0.axis{0 or ‘index’, 1 or ‘columns’, None}, default 0Apply to each column (axis=0or'index'), to each row
(axis=1or'columns'). Only used iftable_stylesis
dict.New in version 1.2.0.overwritebool, default TrueStyles are replaced ifTrue, or extended ifFalse. CSS
rules are preserved so most recent styles set will dominate
if selectors intersect.New in version 1.2.0.css_class_namesdict, optionalA dict of strings used to replace the default CSS classes described below.New in version 1.4.0.Returns:StylerSee alsoStyler.set_td_classesSet the DataFrame of strings added to theclassattribute of<td>HTML elements.Styler.set_table_attributesSet the table attributes added to the<table>HTML element.NotesThe default CSS classes dict, whose values can be replaced is as follows:css_class_names={""row_heading"":""row_heading"",""col_heading"":""col_heading"",""index_name"":""index_name"",""col"":""col"",""row"":""row"",""col_trim"":""col_trim"",""row_trim"":""row_trim"",""level"":""level"",""data"":""data"",""blank"":""blank"",""foot"":""foot""}Examples>>>df=pd.DataFrame(np.random.randn(10,4),...columns=['A','B','C','D'])>>>df.style.set_table_styles(...[{'selector':'tr:hover',...'props':[('background-color','yellow')]}]...)Or with CSS strings>>>df.style.set_table_styles(...[{'selector':'tr:hover',...'props':'background-color: yellow; font-size: 1em;'}]...)Adding column styling by name>>>df.style.set_table_styles({...'A':[{'selector':'',...'props':[('color','red')]}],...'B':[{'selector':'td',...'props':'color: blue;'}]...},overwrite=False)Adding row styling>>>df.style.set_table_styles({...0:[{'selector':'td:hover',...'props':[('font-size','25px')]}]...},axis=1,overwrite=False)SeeTable Visualizationuser guide for
more details."
Pandas,Style,pandas.io.formats.style.Styler.set_table_attributes,"pandas.io.formats.style.Styler.set_table_attributes#Styler.set_table_attributes(attributes)[source]#Set the table attributes added to the<table>HTML element.These are items in addition to automatic (by default)idattribute.Parameters:attributesstrReturns:StylerSee alsoStyler.set_table_stylesSet the table styles included within the<style>HTML element.Styler.set_td_classesSet the DataFrame of strings added to theclassattribute of<td>HTML elements.Examples>>>df=pd.DataFrame(np.random.randn(10,4))>>>df.style.set_table_attributes('class=""pure-table""')# ... <table class=""pure-table""> ..."
Pandas,Style,pandas.io.formats.style.Styler.set_tooltips,"pandas.io.formats.style.Styler.set_tooltips#Styler.set_tooltips(ttips,props=None,css_class=None)[source]#Set the DataFrame of strings onStylergenerating:hovertooltips.These string based tooltips are only applicable to<td>HTML elements,
and cannot be used for column or index headers.New in version 1.3.0.Parameters:ttipsDataFrameDataFrame containing strings that will be translated to tooltips, mapped
by identical column and index values that must exist on the underlying
Styler data. None, NaN values, and empty strings will be ignored and
not affect the rendered HTML.propslist-like or str, optionalList of (attr, value) tuples or a valid CSS string. IfNoneadopts
the internal default values described in notes.css_classstr, optionalName of the tooltip class used in CSS, should conform to HTML standards.
Only useful if integrating tooltips with external CSS. IfNoneuses the
internal default value ‘pd-t’.Returns:StylerNotesTooltips are created by adding<span class=”pd-t”></span>to each data cell
and then manipulating the table level CSS to attach pseudo hover and pseudo
after selectors to produce the required the results.The default properties for the tooltip CSS class are:visibility: hiddenposition: absolutez-index: 1background-color: blackcolor: whitetransform: translate(-20px, -20px)The property ‘visibility: hidden;’ is a key prerequisite to the hover
functionality, and should always be included in any manual properties
specification, using thepropsargument.Tooltips are not designed to be efficient, and can add large amounts of
additional HTML for larger tables, since they also require thatcell_idsis forced toTrue.ExamplesBasic application>>>df=pd.DataFrame(data=[[0,1],[2,3]])>>>ttips=pd.DataFrame(...data=[[""Min"",""""],[np.nan,""Max""]],columns=df.columns,index=df.index...)>>>s=df.style.set_tooltips(ttips).to_html()Optionally controlling the tooltip visual display>>>df.style.set_tooltips(ttips,css_class='tt-add',props=[...('visibility','hidden'),...('position','absolute'),...('z-index',1)])>>>df.style.set_tooltips(ttips,css_class='tt-add',...props='visibility:hidden; position:absolute; z-index:1;')..."
Pandas,Style,pandas.io.formats.style.Styler.set_caption,"pandas.io.formats.style.Styler.set_caption#Styler.set_caption(caption)[source]#Set the text added to a<caption>HTML element.Parameters:captionstr, tuple, listFor HTML output either the string input is used or the first element of the
tuple. For LaTeX the string input provides a caption and the additional
tuple input allows for full captions and short captions, in that order.Returns:StylerExamples>>>df=pd.DataFrame({'A':[1,2],'B':[3,4]})>>>df.style.set_caption(""test"")Please see:Table Visualizationfor more examples."
Pandas,Style,pandas.io.formats.style.Styler.set_sticky,"pandas.io.formats.style.Styler.set_sticky#Styler.set_sticky(axis=0,pixel_size=None,levels=None)[source]#Add CSS to permanently display the index or column headers in a scrolling frame.Parameters:axis{0 or ‘index’, 1 or ‘columns’}, default 0Whether to make the index or column headers sticky.pixel_sizeint, optionalRequired to configure the width of index cells or the height of column
header cells when sticking a MultiIndex (or with a named Index).
Defaults to 75 and 25 respectively.levelsint, str, list, optionalIfaxisis a MultiIndex the specific levels to stick. IfNonewill
stick all levels.Returns:StylerNotesThis method uses the CSS ‘position: sticky;’ property to display. It is
designed to work with visible axes, therefore both:styler.set_sticky(axis=”index”).hide(axis=”index”)styler.set_sticky(axis=”columns”).hide(axis=”columns”)may produce strange behaviour due to CSS controls with missing elements.Examples>>>df=pd.DataFrame({'A':[1,2],'B':[3,4]})>>>df.style.set_sticky(axis=""index"")Please see:Table Visualizationfor more examples."
Pandas,Style,pandas.io.formats.style.Styler.set_properties,"pandas.io.formats.style.Styler.set_properties#Styler.set_properties(subset=None,**kwargs)[source]#Set defined CSS-properties to each<td>HTML element for the given subset.Parameters:subsetlabel, array-like, IndexSlice, optionalA valid 2d input toDataFrame.loc[<subset>], or, in the case of a 1d input
or single key, toDataFrame.loc[:, <subset>]where the columns are
prioritised, to limitdatatobeforeapplying the function.**kwargsdictA dictionary of property, value pairs to be set for each cell.Returns:StylerNotesThis is a convenience methods which wraps theStyler.map()calling a
function returning the CSS-properties independently of the data.Examples>>>df=pd.DataFrame(np.random.randn(10,4))>>>df.style.set_properties(color=""white"",align=""right"")>>>df.style.set_properties(**{'background-color':'yellow'})SeeTable Visualizationuser guide for
more details."
Pandas,Style,pandas.io.formats.style.Styler.set_uuid,"pandas.io.formats.style.Styler.set_uuid#Styler.set_uuid(uuid)[source]#Set the uuid applied toidattributes of HTML elements.Parameters:uuidstrReturns:StylerNotesAlmost all HTML elements within the table, and including the<table>element
are assignedidattributes. The format isT_uuid_<extra>where<extra>is typically a more specific identifier, such asrow1_col2.Examples>>>df=pd.DataFrame([[1,2],[3,4]],index=['A','B'],columns=['c1','c2'])You can get theidattributes with the following:>>>print((df).style.to_html())To add a title to columnc1, itsidis T_20a7d_level0_col0:>>>df.style.set_uuid(""T_20a7d_level0_col0"")....set_caption(""Test"")Please see:Table visualizationfor more examples."
Pandas,Style,pandas.io.formats.style.Styler.clear,"pandas.io.formats.style.Styler.clear#Styler.clear()[source]#Reset theStyler, removing any previously applied styles.Returns None.Examples>>>df=pd.DataFrame({'A':[1,2],'B':[3,np.nan]})After any added style:>>>df.style.highlight_null(color='yellow')Remove it with:>>>df.style.clear()Please see:Table Visualizationfor more examples."
Pandas,Style,pandas.io.formats.style.Styler.pipe,"pandas.io.formats.style.Styler.pipe#Styler.pipe(func,*args,**kwargs)[source]#Applyfunc(self,*args,**kwargs), and return the result.Parameters:funcfunctionFunction to apply to the Styler. Alternatively, a(callable,keyword)tuple wherekeywordis a string
indicating the keyword ofcallablethat expects the Styler.*argsoptionalArguments passed tofunc.**kwargsoptionalA dictionary of keyword arguments passed intofunc.Returns:objectThe value returned byfunc.See alsoDataFrame.pipeAnalogous method for DataFrame.Styler.applyApply a CSS-styling function column-wise, row-wise, or table-wise.NotesLikeDataFrame.pipe(), this method can simplify the
application of several user-defined functions to a styler. Instead
of writing:f(g(df.style.format(precision=3),arg1=a),arg2=b,arg3=c)users can write:(df.style.format(precision=3).pipe(g,arg1=a).pipe(f,arg2=b,arg3=c))In particular, this allows users to define functions that take a
styler object, along with other parameters, and return the styler after
making styling changes (such as callingStyler.apply()orStyler.set_properties()).ExamplesCommon UseA common usage pattern is to pre-define styling operations which
can be easily applied to a generic styler in a singlepipecall.>>>defsome_highlights(styler,min_color=""red"",max_color=""blue""):...styler.highlight_min(color=min_color,axis=None)...styler.highlight_max(color=max_color,axis=None)...styler.highlight_null()...returnstyler>>>df=pd.DataFrame([[1,2,3,pd.NA],[pd.NA,4,5,6]],dtype=""Int64"")>>>df.style.pipe(some_highlights,min_color=""green"")Since the method returns aStylerobject it can be chained with other
methods as if applying the underlying highlighters directly.>>>(df.style.format(""{:.1f}"")....pipe(some_highlights,min_color=""green"")....highlight_between(left=2,right=5))Advanced UseSometimes it may be necessary to pre-define styling functions, but in the case
where those functions rely on the styler, data or context. SinceStyler.useandStyler.exportare designed to be non-data dependent,
they cannot be used for this purpose. Additionally theStyler.applyandStyler.formattype methods are not context aware, so a solution
is to usepipeto dynamically wrap this functionality.Suppose we want to code a generic styling function that highlights the final
level of a MultiIndex. The number of levels in the Index is dynamic so we
need theStylercontext to define the level.>>>defhighlight_last_level(styler):...returnstyler.apply_index(...lambdav:""background-color: pink; color: yellow"",axis=""columns"",...level=styler.columns.nlevels-1...)>>>df.columns=pd.MultiIndex.from_product([[""A"",""B""],[""X"",""Y""]])>>>df.style.pipe(highlight_last_level)Additionally suppose we want to highlight a column header if there is any
missing data in that column.
In this case we need the data object itself to determine the effect on the
column headers.>>>defhighlight_header_missing(styler,level):...defdynamic_highlight(s):...returnnp.where(...styler.data.isna().any(),""background-color: red;"",""""...)...returnstyler.apply_index(dynamic_highlight,axis=1,level=level)>>>df.style.pipe(highlight_header_missing,level=1)"
Pandas,Style,pandas.io.formats.style.Styler.highlight_null,"pandas.io.formats.style.Styler.highlight_null#Styler.highlight_null(color='red',subset=None,props=None)[source]#Highlight missing values with a style.Parameters:colorstr, default ‘red’Background color to use for highlighting.New in version 1.5.0.subsetlabel, array-like, IndexSlice, optionalA valid 2d input toDataFrame.loc[<subset>], or, in the case of a 1d input
or single key, toDataFrame.loc[:, <subset>]where the columns are
prioritised, to limitdatatobeforeapplying the function.propsstr, default NoneCSS properties to use for highlighting. Ifpropsis given,coloris not used.New in version 1.3.0.Returns:StylerSee alsoStyler.highlight_maxHighlight the maximum with a style.Styler.highlight_minHighlight the minimum with a style.Styler.highlight_betweenHighlight a defined range with a style.Styler.highlight_quantileHighlight values defined by a quantile with a style.Examples>>>df=pd.DataFrame({'A':[1,2],'B':[3,np.nan]})>>>df.style.highlight_null(color='yellow')Please see:Table Visualizationfor more examples."
Pandas,Style,pandas.io.formats.style.Styler.highlight_max,"pandas.io.formats.style.Styler.highlight_max#Styler.highlight_max(subset=None,color='yellow',axis=0,props=None)[source]#Highlight the maximum with a style.Parameters:subsetlabel, array-like, IndexSlice, optionalA valid 2d input toDataFrame.loc[<subset>], or, in the case of a 1d input
or single key, toDataFrame.loc[:, <subset>]where the columns are
prioritised, to limitdatatobeforeapplying the function.colorstr, default ‘yellow’Background color to use for highlighting.axis{0 or ‘index’, 1 or ‘columns’, None}, default 0Apply to each column (axis=0or'index'), to each row
(axis=1or'columns'), or to the entire DataFrame at once
withaxis=None.propsstr, default NoneCSS properties to use for highlighting. Ifpropsis given,coloris not used.New in version 1.3.0.Returns:StylerSee alsoStyler.highlight_nullHighlight missing values with a style.Styler.highlight_minHighlight the minimum with a style.Styler.highlight_betweenHighlight a defined range with a style.Styler.highlight_quantileHighlight values defined by a quantile with a style.Examples>>>df=pd.DataFrame({'A':[2,1],'B':[3,4]})>>>df.style.highlight_max(color='yellow')Please see:Table Visualizationfor more examples."
Pandas,Style,pandas.io.formats.style.Styler.highlight_min,"pandas.io.formats.style.Styler.highlight_min#Styler.highlight_min(subset=None,color='yellow',axis=0,props=None)[source]#Highlight the minimum with a style.Parameters:subsetlabel, array-like, IndexSlice, optionalA valid 2d input toDataFrame.loc[<subset>], or, in the case of a 1d input
or single key, toDataFrame.loc[:, <subset>]where the columns are
prioritised, to limitdatatobeforeapplying the function.colorstr, default ‘yellow’Background color to use for highlighting.axis{0 or ‘index’, 1 or ‘columns’, None}, default 0Apply to each column (axis=0or'index'), to each row
(axis=1or'columns'), or to the entire DataFrame at once
withaxis=None.propsstr, default NoneCSS properties to use for highlighting. Ifpropsis given,coloris not used.New in version 1.3.0.Returns:StylerSee alsoStyler.highlight_nullHighlight missing values with a style.Styler.highlight_maxHighlight the maximum with a style.Styler.highlight_betweenHighlight a defined range with a style.Styler.highlight_quantileHighlight values defined by a quantile with a style.Examples>>>df=pd.DataFrame({'A':[2,1],'B':[3,4]})>>>df.style.highlight_min(color='yellow')Please see:Table Visualizationfor more examples."
Pandas,Style,pandas.io.formats.style.Styler.highlight_between,"pandas.io.formats.style.Styler.highlight_between#Styler.highlight_between(subset=None,color='yellow',axis=0,left=None,right=None,inclusive='both',props=None)[source]#Highlight a defined range with a style.New in version 1.3.0.Parameters:subsetlabel, array-like, IndexSlice, optionalA valid 2d input toDataFrame.loc[<subset>], or, in the case of a 1d input
or single key, toDataFrame.loc[:, <subset>]where the columns are
prioritised, to limitdatatobeforeapplying the function.colorstr, default ‘yellow’Background color to use for highlighting.axis{0 or ‘index’, 1 or ‘columns’, None}, default 0Ifleftorrightgiven as sequence, axis along which to apply those
boundaries. See examples.leftscalar or datetime-like, or sequence or array-like, default NoneLeft bound for defining the range.rightscalar or datetime-like, or sequence or array-like, default NoneRight bound for defining the range.inclusive{‘both’, ‘neither’, ‘left’, ‘right’}Identify whether bounds are closed or open.propsstr, default NoneCSS properties to use for highlighting. Ifpropsis given,coloris not used.Returns:StylerSee alsoStyler.highlight_nullHighlight missing values with a style.Styler.highlight_maxHighlight the maximum with a style.Styler.highlight_minHighlight the minimum with a style.Styler.highlight_quantileHighlight values defined by a quantile with a style.NotesIfleftisNoneonly the right bound is applied.
IfrightisNoneonly the left bound is applied. If both areNoneall values are highlighted.axisis only needed ifleftorrightare provided as a sequence or
an array-like object for aligning the shapes. Ifleftandrightare
both scalars then allaxisinputs will give the same result.This function only works with compatibledtypes. For example a datetime-like
region can only use equivalent datetime-likeleftandrightarguments.
Usesubsetto control regions which have multipledtypes.ExamplesBasic usage>>>df=pd.DataFrame({...'One':[1.2,1.6,1.5],...'Two':[2.9,2.1,2.5],...'Three':[3.1,3.2,3.8],...})>>>df.style.highlight_between(left=2.1,right=2.9)Using a range input sequence along anaxis, in this case setting aleftandrightfor each column individually>>>df.style.highlight_between(left=[1.4,2.4,3.4],right=[1.6,2.6,3.6],...axis=1,color=""#fffd75"")Usingaxis=Noneand providing theleftargument as an array that
matches the input DataFrame, with a constantright>>>df.style.highlight_between(left=[[2,2,3],[2,2,3],[3,3,3]],right=3.5,...axis=None,color=""#fffd75"")Usingpropsinstead of default background coloring>>>df.style.highlight_between(left=1.5,right=3.5,...props='font-weight:bold;color:#e83e8c')"
Pandas,Style,pandas.io.formats.style.Styler.highlight_quantile,"pandas.io.formats.style.Styler.highlight_quantile#Styler.highlight_quantile(subset=None,color='yellow',axis=0,q_left=0.0,q_right=1.0,interpolation='linear',inclusive='both',props=None)[source]#Highlight values defined by a quantile with a style.New in version 1.3.0.Parameters:subsetlabel, array-like, IndexSlice, optionalA valid 2d input toDataFrame.loc[<subset>], or, in the case of a 1d input
or single key, toDataFrame.loc[:, <subset>]where the columns are
prioritised, to limitdatatobeforeapplying the function.colorstr, default ‘yellow’Background color to use for highlighting.axis{0 or ‘index’, 1 or ‘columns’, None}, default 0Axis along which to determine and highlight quantiles. IfNonequantiles
are measured over the entire DataFrame. See examples.q_leftfloat, default 0Left bound, in [0, q_right), for the target quantile range.q_rightfloat, default 1Right bound, in (q_left, 1], for the target quantile range.interpolation{‘linear’, ‘lower’, ‘higher’, ‘midpoint’, ‘nearest’}Argument passed toSeries.quantileorDataFrame.quantilefor
quantile estimation.inclusive{‘both’, ‘neither’, ‘left’, ‘right’}Identify whether quantile bounds are closed or open.propsstr, default NoneCSS properties to use for highlighting. Ifpropsis given,coloris not used.Returns:StylerSee alsoStyler.highlight_nullHighlight missing values with a style.Styler.highlight_maxHighlight the maximum with a style.Styler.highlight_minHighlight the minimum with a style.Styler.highlight_betweenHighlight a defined range with a style.NotesThis function does not work withstrdtypes.ExamplesUsingaxis=Noneand apply a quantile to all collective data>>>df=pd.DataFrame(np.arange(10).reshape(2,5)+1)>>>df.style.highlight_quantile(axis=None,q_left=0.8,color=""#fffd75"")...Or highlight quantiles row-wise or column-wise, in this case by row-wise>>>df.style.highlight_quantile(axis=1,q_left=0.8,color=""#fffd75"")...Usepropsinstead of default background coloring>>>df.style.highlight_quantile(axis=None,q_left=0.2,q_right=0.8,...props='font-weight:bold;color:#e83e8c')"
Pandas,Style,pandas.io.formats.style.Styler.background_gradient,"pandas.io.formats.style.Styler.background_gradient#Styler.background_gradient(cmap='PuBu',low=0,high=0,axis=0,subset=None,text_color_threshold=0.408,vmin=None,vmax=None,gmap=None)[source]#Color the background in a gradient style.The background color is determined according
to the data in each column, row or frame, or by a given
gradient map. Requires matplotlib.Parameters:cmapstr or colormapMatplotlib colormap.lowfloatCompress the color range at the low end. This is a multiple of the data
range to extend below the minimum; good values usually in [0, 1],
defaults to 0.highfloatCompress the color range at the high end. This is a multiple of the data
range to extend above the maximum; good values usually in [0, 1],
defaults to 0.axis{0, 1, “index”, “columns”, None}, default 0Apply to each column (axis=0or'index'), to each row
(axis=1or'columns'), or to the entire DataFrame at once
withaxis=None.subsetlabel, array-like, IndexSlice, optionalA valid 2d input toDataFrame.loc[<subset>], or, in the case of a 1d input
or single key, toDataFrame.loc[:, <subset>]where the columns are
prioritised, to limitdatatobeforeapplying the function.text_color_thresholdfloat or intLuminance threshold for determining text color in [0, 1]. Facilitates textvisibility across varying background colors. All text is dark if 0, andlight if 1, defaults to 0.408.vminfloat, optionalMinimum data value that corresponds to colormap minimum value.
If not specified the minimum value of the data (or gmap) will be used.vmaxfloat, optionalMaximum data value that corresponds to colormap maximum value.
If not specified the maximum value of the data (or gmap) will be used.gmaparray-like, optionalGradient map for determining the background colors. If not supplied
will use the underlying data from rows, columns or frame. If given as an
ndarray or list-like must be an identical shape to the underlying data
consideringaxisandsubset. If given as DataFrame or Series must
have same index and column labels consideringaxisandsubset.
If supplied,vminandvmaxshould be given relative to this
gradient map.New in version 1.3.0.Returns:StylerSee alsoStyler.text_gradientColor the text in a gradient style.NotesWhen usinglowandhighthe range
of the gradient, given by the data ifgmapis not given or bygmap,
is extended at the low end effectively bymap.min - low * map.rangeand at the high end bymap.max + high * map.rangebefore the colors are normalized and determined.If combining withvminandvmaxthemap.min,map.maxandmap.rangeare replaced by values according to the values derived fromvminandvmax.This method will preselect numeric columns and ignore non-numeric columns
unless agmapis supplied in which case no preselection occurs.Examples>>>df=pd.DataFrame(columns=[""City"",""Temp (c)"",""Rain (mm)"",""Wind (m/s)""],...data=[[""Stockholm"",21.6,5.0,3.2],...[""Oslo"",22.4,13.3,3.1],...[""Copenhagen"",24.5,0.0,6.7]])Shading the values column-wise, withaxis=0, preselecting numeric columns>>>df.style.background_gradient(axis=0)Shading all values collectively usingaxis=None>>>df.style.background_gradient(axis=None)Compress the color map from the bothlowandhighends>>>df.style.background_gradient(axis=None,low=0.75,high=1.0)Manually settingvminandvmaxgradient thresholds>>>df.style.background_gradient(axis=None,vmin=6.7,vmax=21.6)Setting agmapand applying to all columns with anothercmap>>>df.style.background_gradient(axis=0,gmap=df['Temp (c)'],cmap='YlOrRd')...Setting the gradient map for a dataframe (i.e.axis=None), we need to
explicitly statesubsetto match thegmapshape>>>gmap=np.array([[1,2,3],[2,3,4],[3,4,5]])>>>df.style.background_gradient(axis=None,gmap=gmap,...cmap='YlOrRd',subset=['Temp (c)','Rain (mm)','Wind (m/s)']...)"
Pandas,Style,pandas.io.formats.style.Styler.text_gradient,"pandas.io.formats.style.Styler.text_gradient#Styler.text_gradient(cmap='PuBu',low=0,high=0,axis=0,subset=None,vmin=None,vmax=None,gmap=None)[source]#Color the text in a gradient style.The text color is determined according
to the data in each column, row or frame, or by a given
gradient map. Requires matplotlib.Parameters:cmapstr or colormapMatplotlib colormap.lowfloatCompress the color range at the low end. This is a multiple of the data
range to extend below the minimum; good values usually in [0, 1],
defaults to 0.highfloatCompress the color range at the high end. This is a multiple of the data
range to extend above the maximum; good values usually in [0, 1],
defaults to 0.axis{0, 1, “index”, “columns”, None}, default 0Apply to each column (axis=0or'index'), to each row
(axis=1or'columns'), or to the entire DataFrame at once
withaxis=None.subsetlabel, array-like, IndexSlice, optionalA valid 2d input toDataFrame.loc[<subset>], or, in the case of a 1d input
or single key, toDataFrame.loc[:, <subset>]where the columns are
prioritised, to limitdatatobeforeapplying the function.vminfloat, optionalMinimum data value that corresponds to colormap minimum value.
If not specified the minimum value of the data (or gmap) will be used.vmaxfloat, optionalMaximum data value that corresponds to colormap maximum value.
If not specified the maximum value of the data (or gmap) will be used.gmaparray-like, optionalGradient map for determining the text colors. If not supplied
will use the underlying data from rows, columns or frame. If given as an
ndarray or list-like must be an identical shape to the underlying data
consideringaxisandsubset. If given as DataFrame or Series must
have same index and column labels consideringaxisandsubset.
If supplied,vminandvmaxshould be given relative to this
gradient map.New in version 1.3.0.Returns:StylerSee alsoStyler.background_gradientColor the background in a gradient style.NotesWhen usinglowandhighthe range
of the gradient, given by the data ifgmapis not given or bygmap,
is extended at the low end effectively bymap.min - low * map.rangeand at the high end bymap.max + high * map.rangebefore the colors are normalized and determined.If combining withvminandvmaxthemap.min,map.maxandmap.rangeare replaced by values according to the values derived fromvminandvmax.This method will preselect numeric columns and ignore non-numeric columns
unless agmapis supplied in which case no preselection occurs.Examples>>>df=pd.DataFrame(columns=[""City"",""Temp (c)"",""Rain (mm)"",""Wind (m/s)""],...data=[[""Stockholm"",21.6,5.0,3.2],...[""Oslo"",22.4,13.3,3.1],...[""Copenhagen"",24.5,0.0,6.7]])Shading the values column-wise, withaxis=0, preselecting numeric columns>>>df.style.text_gradient(axis=0)Shading all values collectively usingaxis=None>>>df.style.text_gradient(axis=None)Compress the color map from the bothlowandhighends>>>df.style.text_gradient(axis=None,low=0.75,high=1.0)Manually settingvminandvmaxgradient thresholds>>>df.style.text_gradient(axis=None,vmin=6.7,vmax=21.6)Setting agmapand applying to all columns with anothercmap>>>df.style.text_gradient(axis=0,gmap=df['Temp (c)'],cmap='YlOrRd')...Setting the gradient map for a dataframe (i.e.axis=None), we need to
explicitly statesubsetto match thegmapshape>>>gmap=np.array([[1,2,3],[2,3,4],[3,4,5]])>>>df.style.text_gradient(axis=None,gmap=gmap,...cmap='YlOrRd',subset=['Temp (c)','Rain (mm)','Wind (m/s)']...)"
Pandas,Style,pandas.io.formats.style.Styler.bar,"pandas.io.formats.style.Styler.bar#Styler.bar(subset=None,axis=0,*,color=None,cmap=None,width=100,height=100,align='mid',vmin=None,vmax=None,props='width:10em;')[source]#Draw bar chart in the cell backgrounds.Changed in version 1.4.0.Parameters:subsetlabel, array-like, IndexSlice, optionalA valid 2d input toDataFrame.loc[<subset>], or, in the case of a 1d input
or single key, toDataFrame.loc[:, <subset>]where the columns are
prioritised, to limitdatatobeforeapplying the function.axis{0 or ‘index’, 1 or ‘columns’, None}, default 0Apply to each column (axis=0or'index'), to each row
(axis=1or'columns'), or to the entire DataFrame at once
withaxis=None.colorstr or 2-tuple/listIf a str is passed, the color is the same for both
negative and positive numbers. If 2-tuple/list is used, the
first element is the color_negative and the second is the
color_positive (eg: [‘#d65f5f’, ‘#5fba7d’]).cmapstr, matplotlib.cm.ColorMapA string name of a matplotlib Colormap, or a Colormap object. Cannot be
used together withcolor.New in version 1.4.0.widthfloat, default 100The percentage of the cell, measured from the left, in which to draw the
bars, in [0, 100].heightfloat, default 100The percentage height of the bar in the cell, centrally aligned, in [0,100].New in version 1.4.0.alignstr, int, float, callable, default ‘mid’How to align the bars within the cells relative to a width adjusted center.
If string must be one of:‘left’ : bars are drawn rightwards from the minimum data value.‘right’ : bars are drawn leftwards from the maximum data value.‘zero’ : a value of zero is located at the center of the cell.‘mid’ : a value of (max-min)/2 is located at the center of the cell,
or if all values are negative (positive) the zero is
aligned at the right (left) of the cell.‘mean’ : the mean value of the data is located at the center of the cell.If a float or integer is given this will indicate the center of the cell.If a callable should take a 1d or 2d array and return a scalar.Changed in version 1.4.0.vminfloat, optionalMinimum bar value, defining the left hand limit
of the bar drawing range, lower values are clipped tovmin.
When None (default): the minimum value of the data will be used.vmaxfloat, optionalMaximum bar value, defining the right hand limit
of the bar drawing range, higher values are clipped tovmax.
When None (default): the maximum value of the data will be used.propsstr, optionalThe base CSS of the cell that is extended to add the bar chart. Defaults to“width: 10em;”.New in version 1.4.0.Returns:StylerNotesThis section of the user guide:Table Visualizationgives
a number of examples for different settings and color coordination.Examples>>>df=pd.DataFrame({'A':[1,2,3,4],'B':[3,4,5,6]})>>>df.style.bar(subset=['A'],color='gray')"
Pandas,Style,pandas.io.formats.style.Styler.to_html,"pandas.io.formats.style.Styler.to_html#Styler.to_html(buf=None,*,table_uuid=None,table_attributes=None,sparse_index=None,sparse_columns=None,bold_headers=False,caption=None,max_rows=None,max_columns=None,encoding=None,doctype_html=False,exclude_styles=False,**kwargs)[source]#Write Styler to a file, buffer or string in HTML-CSS format.New in version 1.3.0.Parameters:bufstr, path object, file-like object, optionalString, path object (implementingos.PathLike[str]), or file-like
object implementing a stringwrite()function. IfNone, the result is
returned as a string.table_uuidstr, optionalId attribute assigned to the <table> HTML element in the format:<tableid=""T_<table_uuid>""..>If not given uses Styler’s initially assigned value.table_attributesstr, optionalAttributes to assign within the<table>HTML element in the format:<table..<table_attributes>>If not given defaults to Styler’s preexisting value.sparse_indexbool, optionalWhether to sparsify the display of a hierarchical index. Setting to False
will display each explicit level element in a hierarchical key for each row.
Defaults topandas.options.styler.sparse.indexvalue.New in version 1.4.0.sparse_columnsbool, optionalWhether to sparsify the display of a hierarchical index. Setting to False
will display each explicit level element in a hierarchical key for each
column. Defaults topandas.options.styler.sparse.columnsvalue.New in version 1.4.0.bold_headersbool, optionalAdds “font-weight: bold;” as a CSS property to table style header cells.New in version 1.4.0.captionstr, optionalSet, or overwrite, the caption on Styler before rendering.New in version 1.4.0.max_rowsint, optionalThe maximum number of rows that will be rendered. Defaults topandas.options.styler.render.max_rows/max_columns.New in version 1.4.0.max_columnsint, optionalThe maximum number of columns that will be rendered. Defaults topandas.options.styler.render.max_columns, which is None.Rows and columns may be reduced if the number of total elements is
large. This value is set topandas.options.styler.render.max_elements,
which is 262144 (18 bit browser rendering).New in version 1.4.0.encodingstr, optionalCharacter encoding setting for file output (and meta tags if available).
Defaults topandas.options.styler.render.encodingvalue of “utf-8”.doctype_htmlbool, default FalseWhether to output a fully structured HTML file including all
HTML elements, or just the core<style>and<table>elements.exclude_stylesbool, default FalseWhether to include the<style>element and all associated elementclassandididentifiers, or solely the<table>element without
styling identifiers.**kwargsAny additional keyword arguments are passed through to the jinja2self.template.renderprocess. This is useful when you need to provide
additional variables for a custom template.Returns:str or NoneIfbufis None, returns the result as a string. Otherwise returnsNone.See alsoDataFrame.to_htmlWrite a DataFrame to a file, buffer or string in HTML format.Examples>>>df=pd.DataFrame({'A':[1,2],'B':[3,4]})>>>print(df.style.to_html())<style type=""text/css""></style><table id=""T_1e78e""><thead><tr><th class=""blank level0"" >&nbsp;</th><th id=""T_1e78e_level0_col0"" class=""col_heading level0 col0"" >A</th><th id=""T_1e78e_level0_col1"" class=""col_heading level0 col1"" >B</th></tr>..."
Pandas,Style,pandas.io.formats.style.Styler.to_latex,"pandas.io.formats.style.Styler.to_latex#Styler.to_latex(buf=None,*,column_format=None,position=None,position_float=None,hrules=None,clines=None,label=None,caption=None,sparse_index=None,sparse_columns=None,multirow_align=None,multicol_align=None,siunitx=False,environment=None,encoding=None,convert_css=False)[source]#Write Styler to a file, buffer or string in LaTeX format.New in version 1.3.0.Parameters:bufstr, path object, file-like object, or None, default NoneString, path object (implementingos.PathLike[str]), or file-like
object implementing a stringwrite()function. If None, the result is
returned as a string.column_formatstr, optionalThe LaTeX column specification placed in location:\begin{tabular}{<column_format>}Defaults to ‘l’ for index and
non-numeric data columns, and, for numeric data columns,
to ‘r’ by default, or ‘S’ ifsiunitxisTrue.positionstr, optionalThe LaTeX positional argument (e.g. ‘h!’) for tables, placed in location:\\begin{table}[<position>].position_float{“centering”, “raggedleft”, “raggedright”}, optionalThe LaTeX float command placed in location:\begin{table}[<position>]\<position_float>Cannot be used ifenvironmentis “longtable”.hrulesboolSet toTrueto add \toprule, \midrule and \bottomrule from the
{booktabs} LaTeX package.
Defaults topandas.options.styler.latex.hrules, which isFalse.Changed in version 1.4.0.clinesstr, optionalUse to control adding \cline commands for the index labels separation.
Possible values are:None: no cline commands are added (default).“all;data”: a cline is added for every index value extending the
width of the table, including data entries.“all;index”: as above with lines extending only the width of the
index entries.“skip-last;data”: a cline is added for each index value except the
last level (which is never sparsified), extending the widtn of the
table.“skip-last;index”: as above with lines extending only the width of the
index entries.New in version 1.4.0.labelstr, optionalThe LaTeX label included as: \label{<label>}.
This is used with \ref{<label>} in the main .tex file.captionstr, tuple, optionalIf string, the LaTeX table caption included as: \caption{<caption>}.
If tuple, i.e (“full caption”, “short caption”), the caption included
as: \caption[<caption[1]>]{<caption[0]>}.sparse_indexbool, optionalWhether to sparsify the display of a hierarchical index. Setting to False
will display each explicit level element in a hierarchical key for each row.
Defaults topandas.options.styler.sparse.index, which isTrue.sparse_columnsbool, optionalWhether to sparsify the display of a hierarchical index. Setting to False
will display each explicit level element in a hierarchical key for each
column. Defaults topandas.options.styler.sparse.columns, which
isTrue.multirow_align{“c”, “t”, “b”, “naive”}, optionalIf sparsifying hierarchical MultiIndexes whether to align text centrally,
at the top or bottom using the multirow package. If not given defaults topandas.options.styler.latex.multirow_align, which is“c”.
If “naive” is given renders without multirow.Changed in version 1.4.0.multicol_align{“r”, “c”, “l”, “naive-l”, “naive-r”}, optionalIf sparsifying hierarchical MultiIndex columns whether to align text at
the left, centrally, or at the right. If not given defaults topandas.options.styler.latex.multicol_align, which is “r”.
If a naive option is given renders without multicol.
Pipe decorators can also be added to non-naive values to draw vertical
rules, e.g. “|r” will draw a rule on the left side of right aligned merged
cells.Changed in version 1.4.0.siunitxbool, default FalseSet toTrueto structure LaTeX compatible with the {siunitx} package.environmentstr, optionalIf given, the environment that will replace ‘table’ in\\begin{table}.
If ‘longtable’ is specified then a more suitable template is
rendered. If not given defaults topandas.options.styler.latex.environment, which isNone.New in version 1.4.0.encodingstr, optionalCharacter encoding setting. Defaults
topandas.options.styler.render.encoding, which is “utf-8”.convert_cssbool, default FalseConvert simple cell-styles from CSS to LaTeX format. Any CSS not found in
conversion table is dropped. A style can be forced by adding option–latex. See notes.Returns:str or NoneIfbufis None, returns the result as a string. Otherwise returnsNone.See alsoStyler.formatFormat the text display value of cells.NotesLatex PackagesFor the following features we recommend the following LaTeX inclusions:FeatureInclusionsparse columnsnone: included within default {tabular} environmentsparse rows\usepackage{multirow}hrules\usepackage{booktabs}colors\usepackage[table]{xcolor}siunitx\usepackage{siunitx}bold (with siunitx)\usepackage{etoolbox}\robustify\bfseries\sisetup{detect-all = true}(within {document})italic (with siunitx)\usepackage{etoolbox}\robustify\itshape\sisetup{detect-all = true}(within {document})environment\usepackage{longtable} if arg is “longtable”
| or any other relevant environment packagehyperlinks\usepackage{hyperref}Cell StylesLaTeX styling can only be rendered if the accompanying styling functions have
been constructed with appropriate LaTeX commands. All styling
functionality is built around the concept of a CSS(<attribute>,<value>)pair (seeTable Visualization), and this
should be replaced by a LaTeX(<command>,<options>)approach. Each cell will be styled individually
using nested LaTeX commands with their accompanied options.For example the following code will highlight and bold a cell in HTML-CSS:>>>df=pd.DataFrame([[1,2],[3,4]])>>>s=df.style.highlight_max(axis=None,...props='background-color:red; font-weight:bold;')>>>s.to_html()The equivalent using LaTeX only commands is the following:>>>s=df.style.highlight_max(axis=None,...props='cellcolor:{red}; bfseries: ;')>>>s.to_latex()Internally these structured LaTeX(<command>,<options>)pairs
are translated to thedisplay_valuewith the default structure:\<command><options><display_value>.
Where there are multiple commands the latter is nested recursively, so that
the above example highlighted cell is rendered as\cellcolor{red}\bfseries4.Occasionally this format does not suit the applied command, or
combination of LaTeX packages that is in use, so additional flags can be
added to the<options>, within the tuple, to result in different
positions of required braces (thedefaultbeing the same as--nowrap):Tuple FormatOutput Structure(<command>,<options>)\<command><options> <display_value>(<command>,<options>--nowrap)\<command><options> <display_value>(<command>,<options>--rwrap)\<command><options>{<display_value>}(<command>,<options>--wrap){\<command><options> <display_value>}(<command>,<options>--lwrap){\<command><options>} <display_value>(<command>,<options>--dwrap){\<command><options>}{<display_value>}For example thetextbfcommand for font-weight
should always be used with–rwrapso('textbf','--rwrap')will render a
working cell, wrapped with braces, as\textbf{<display_value>}.A more comprehensive example is as follows:>>>df=pd.DataFrame([[1,2.2,""dogs""],[3,4.4,""cats""],[2,6.6,""cows""]],...index=[""ix1"",""ix2"",""ix3""],...columns=[""Integers"",""Floats"",""Strings""])>>>s=df.style.highlight_max(...props='cellcolor:[HTML]{FFFF00}; color:{red};'...'textit:--rwrap; textbf:--rwrap;'...)>>>s.to_latex()Table StylesInternally Styler uses itstable_stylesobject to parse thecolumn_format,position,position_float, andlabelinput arguments. These arguments are added to table styles in the format:set_table_styles([{""selector"":""column_format"",""props"":f"":{column_format};""},{""selector"":""position"",""props"":f"":{position};""},{""selector"":""position_float"",""props"":f"":{position_float};""},{""selector"":""label"",""props"":f"":{{{label.replace(':','§')}}};""}],overwrite=False)Exception is made for thehrulesargument which, in fact, controls all three
commands:toprule,bottomruleandmidrulesimultaneously. Instead of
settinghrulestoTrue, it is also possible to set each
individual rule definition, by manually setting thetable_styles,
for example below we set a regulartoprule, set anhlineforbottomruleand exclude themidrule:set_table_styles([{'selector':'toprule','props':':toprule;'},{'selector':'bottomrule','props':':hline;'},],overwrite=False)If othercommandsare added to table styles they will be detected, and
positioned immediately above the ‘\begin{tabular}’ command. For example to
add odd and even row coloring, from the {colortbl} package, in format\rowcolors{1}{pink}{red}, use:set_table_styles([{'selector':'rowcolors','props':':{1}{pink}{red};'}],overwrite=False)A more comprehensive example using these arguments is as follows:>>>df.columns=pd.MultiIndex.from_tuples([...(""Numeric"",""Integers""),...(""Numeric"",""Floats""),...(""Non-Numeric"",""Strings"")...])>>>df.index=pd.MultiIndex.from_tuples([...(""L0"",""ix1""),(""L0"",""ix2""),(""L1"",""ix3"")...])>>>s=df.style.highlight_max(...props='cellcolor:[HTML]{FFFF00}; color:{red}; itshape:; bfseries:;'...)>>>s.to_latex(...column_format=""rrrrr"",position=""h"",position_float=""centering"",...hrules=True,label=""table:5"",caption=""Styled LaTeX Table"",...multirow_align=""t"",multicol_align=""r""...)FormattingTo format valuesStyler.format()should be used prior to callingStyler.to_latex, as well as other methods such asStyler.hide()for example:>>>s.clear()>>>s.table_styles=[]>>>s.caption=None>>>s.format({...(""Numeric"",""Integers""):'\${}',...(""Numeric"",""Floats""):'{:.3f}',...(""Non-Numeric"",""Strings""):str.upper...})Numeric      Non-NumericIntegers   Floats    StringsL0    ix1       $1   2.200      DOGSix2       $3   4.400      CATSL1    ix3       $2   6.600      COWS>>>s.to_latex()\begin{tabular}{llrrl}{} & {} & \multicolumn{2}{r}{Numeric} & {Non-Numeric} \\{} & {} & {Integers} & {Floats} & {Strings} \\\multirow[c]{2}{*}{L0} & ix1 & \\$1 & 2.200 & DOGS \\& ix2 & \$3 & 4.400 & CATS \\L1 & ix3 & \$2 & 6.600 & COWS \\\end{tabular}CSS ConversionThis method can convert a Styler constructured with HTML-CSS to LaTeX using
the following limited conversions.CSS AttributeCSS valueLaTeX CommandLaTeX Optionsfont-weightboldbolderbfseriesbfseriesfont-styleitalicobliqueitshapeslshapebackground-colorred#fe01ea#f0ergb(128,255,0)rgba(128,0,0,0.5)rgb(25%,255,50%)cellcolor{red}–lwrap[HTML]{FE01EA}–lwrap[HTML]{FF00EE}–lwrap[rgb]{0.5,1,0}–lwrap[rgb]{0.5,0,0}–lwrap[rgb]{0.25,1,0.5}–lwrapcolorred#fe01ea#f0ergb(128,255,0)rgba(128,0,0,0.5)rgb(25%,255,50%)color{red}[HTML]{FE01EA}[HTML]{FF00EE}[rgb]{0.5,1,0}[rgb]{0.5,0,0}[rgb]{0.25,1,0.5}It is also possible to add user-defined LaTeX only styles to a HTML-CSS Styler
using the--latexflag, and to add LaTeX parsing options that the
converter will detect within a CSS-comment.>>>df=pd.DataFrame([[1]])>>>df.style.set_properties(...**{""font-weight"":""bold /* --dwrap */"",""Huge"":""--latex--rwrap""}...).to_latex(convert_css=True)\begin{tabular}{lr}{} & {0} \\0 & {\bfseries}{\Huge{1}} \\\end{tabular}ExamplesBelow we give a complete step by step example adding some advanced features
and noting some common gotchas.First we create the DataFrame and Styler as usual, including MultiIndex rows
and columns, which allow for more advanced formatting options:>>>cidx=pd.MultiIndex.from_arrays([...[""Equity"",""Equity"",""Equity"",""Equity"",...""Stats"",""Stats"",""Stats"",""Stats"",""Rating""],...[""Energy"",""Energy"",""Consumer"",""Consumer"","""","""","""","""",""""],...[""BP"",""Shell"",""H&M"",""Unilever"",...""Std Dev"",""Variance"",""52w High"",""52w Low"",""""]...])>>>iidx=pd.MultiIndex.from_arrays([...[""Equity"",""Equity"",""Equity"",""Equity""],...[""Energy"",""Energy"",""Consumer"",""Consumer""],...[""BP"",""Shell"",""H&M"",""Unilever""]...])>>>styler=pd.DataFrame([...[1,0.8,0.66,0.72,32.1678,32.1678**2,335.12,240.89,""Buy""],...[0.8,1.0,0.69,0.79,1.876,1.876**2,14.12,19.78,""Hold""],...[0.66,0.69,1.0,0.86,7,7**2,210.9,140.6,""Buy""],...[0.72,0.79,0.86,1.0,213.76,213.76**2,2807,3678,""Sell""],...],columns=cidx,index=iidx).styleSecond we will format the display and, since our table is quite wide, will
hide the repeated level-0 of the index:>>>(styler.format(subset=""Equity"",precision=2)....format(subset=""Stats"",precision=1,thousands="","")....format(subset=""Rating"",formatter=str.upper)....format_index(escape=""latex"",axis=1)....format_index(escape=""latex"",axis=0)....hide(level=0,axis=0))Note that one of the string entries of the index and column headers is “H&M”.
Without applying theescape=”latex”option to theformat_indexmethod the
resultant LaTeX will fail to render, and the error returned is quite
difficult to debug. Using the appropriate escape the “&” is converted to “\&”.Thirdly we will apply some (CSS-HTML) styles to our object. We will use a
builtin method and also define our own method to highlight the stock
recommendation:>>>defrating_color(v):...ifv==""Buy"":color=""#33ff85""...elifv==""Sell"":color=""#ff5933""...else:color=""#ffdd33""...returnf""color:{color}; font-weight: bold;"">>>(styler.background_gradient(cmap=""inferno"",subset=""Equity"",vmin=0,vmax=1)....map(rating_color,subset=""Rating""))All the above styles will work with HTML (see below) and LaTeX upon conversion:However, we finally want to add one LaTeX only style
(from the {graphicx} package), that is not easy to convert from CSS and
pandas does not support it. Notice the–latexflag used here,
as well as–rwrapto ensure this is formatted correctly and
not ignored upon conversion.>>>styler.map_index(...lambdav:""rotatebox:{45}--rwrap--latex;"",level=2,axis=1...)Finally we render our LaTeX adding in other options as required:>>>styler.to_latex(...caption=""Selected stock correlation and simple statistics."",...clines=""skip-last;data"",...convert_css=True,...position_float=""centering"",...multicol_align=""|c|"",...hrules=True,...)\begin{table}\centering\caption{Selected stock correlation and simple statistics.}\begin{tabular}{llrrrrrrrrl}\toprule&  & \multicolumn{4}{|c|}{Equity} & \multicolumn{4}{|c|}{Stats} & Rating \\&  & \multicolumn{2}{|c|}{Energy} & \multicolumn{2}{|c|}{Consumer} &\multicolumn{4}{|c|}{} &  \\&  & \rotatebox{45}{BP} & \rotatebox{45}{Shell} & \rotatebox{45}{H\&M} &\rotatebox{45}{Unilever} & \rotatebox{45}{Std Dev} & \rotatebox{45}{Variance} &\rotatebox{45}{52w High} & \rotatebox{45}{52w Low} & \rotatebox{45}{} \\\midrule\multirow[c]{2}{*}{Energy} & BP & {\cellcolor[HTML]{FCFFA4}}\color[HTML]{000000} 1.00 & {\cellcolor[HTML]{FCA50A}} \color[HTML]{000000}0.80 & {\cellcolor[HTML]{EB6628}} \color[HTML]{F1F1F1} 0.66 &{\cellcolor[HTML]{F68013}} \color[HTML]{F1F1F1} 0.72 & 32.2 & 1,034.8 & 335.1& 240.9 & \color[HTML]{33FF85} \bfseries BUY \\& Shell & {\cellcolor[HTML]{FCA50A}} \color[HTML]{000000} 0.80 &{\cellcolor[HTML]{FCFFA4}} \color[HTML]{000000} 1.00 &{\cellcolor[HTML]{F1731D}} \color[HTML]{F1F1F1} 0.69 &{\cellcolor[HTML]{FCA108}} \color[HTML]{000000} 0.79 & 1.9 & 3.5 & 14.1 &19.8 & \color[HTML]{FFDD33} \bfseries HOLD \\\cline{1-11}\multirow[c]{2}{*}{Consumer} & H\&M & {\cellcolor[HTML]{EB6628}}\color[HTML]{F1F1F1} 0.66 & {\cellcolor[HTML]{F1731D}} \color[HTML]{F1F1F1}0.69 & {\cellcolor[HTML]{FCFFA4}} \color[HTML]{000000} 1.00 &{\cellcolor[HTML]{FAC42A}} \color[HTML]{000000} 0.86 & 7.0 & 49.0 & 210.9 &140.6 & \color[HTML]{33FF85} \bfseries BUY \\& Unilever & {\cellcolor[HTML]{F68013}} \color[HTML]{F1F1F1} 0.72 &{\cellcolor[HTML]{FCA108}} \color[HTML]{000000} 0.79 &{\cellcolor[HTML]{FAC42A}} \color[HTML]{000000} 0.86 &{\cellcolor[HTML]{FCFFA4}} \color[HTML]{000000} 1.00 & 213.8 & 45,693.3 &2,807.0 & 3,678.0 & \color[HTML]{FF5933} \bfseries SELL \\\cline{1-11}\bottomrule\end{tabular}\end{table}"
Pandas,Style,pandas.io.formats.style.Styler.to_excel,"pandas.io.formats.style.Styler.to_excel#Styler.to_excel(excel_writer,sheet_name='Sheet1',na_rep='',float_format=None,columns=None,header=True,index=True,index_label=None,startrow=0,startcol=0,engine=None,merge_cells=True,encoding=None,inf_rep='inf',verbose=True,freeze_panes=None,storage_options=None)[source]#Write Styler to an Excel sheet.To write a single Styler to an Excel .xlsx file it is only necessary to
specify a target file name. To write to multiple sheets it is necessary to
create anExcelWriterobject with a target file name, and specify a sheet
in the file to write to.Multiple sheets may be written to by specifying uniquesheet_name.
With all data written to the file it is necessary to save the changes.
Note that creating anExcelWriterobject with a file name that already
exists will result in the contents of the existing file being erased.Parameters:excel_writerpath-like, file-like, or ExcelWriter objectFile path or existing ExcelWriter.sheet_namestr, default ‘Sheet1’Name of sheet which will contain DataFrame.na_repstr, default ‘’Missing data representation.float_formatstr, optionalFormat string for floating point numbers. For examplefloat_format=""%.2f""will format 0.1234 to 0.12.columnssequence or list of str, optionalColumns to write.headerbool or list of str, default TrueWrite out the column names. If a list of string is given it is
assumed to be aliases for the column names.indexbool, default TrueWrite row names (index).index_labelstr or sequence, optionalColumn label for index column(s) if desired. If not specified, andheaderandindexare True, then the index names are used. A
sequence should be given if the DataFrame uses MultiIndex.startrowint, default 0Upper left cell row to dump data frame.startcolint, default 0Upper left cell column to dump data frame.enginestr, optionalWrite engine to use, ‘openpyxl’ or ‘xlsxwriter’. You can also set this
via the optionsio.excel.xlsx.writerorio.excel.xlsm.writer.merge_cellsbool, default TrueWrite MultiIndex and Hierarchical Rows as merged cells.inf_repstr, default ‘inf’Representation for infinity (there is no native representation for
infinity in Excel).freeze_panestuple of int (length 2), optionalSpecifies the one-based bottommost row and rightmost column that
is to be frozen.storage_optionsdict, optionalExtra options that make sense for a particular storage connection, e.g.
host, port, username, password, etc. For HTTP(S) URLs the key-value pairs
are forwarded tourllib.request.Requestas header options. For other
URLs (e.g. starting with “s3://”, and “gcs://”) the key-value pairs are
forwarded tofsspec.open. Please seefsspecandurllibfor more
details, and for more examples on storage options referhere.New in version 1.5.0.engine_kwargsdict, optionalArbitrary keyword arguments passed to excel engine.See alsoto_csvWrite DataFrame to a comma-separated values (csv) file.ExcelWriterClass for writing DataFrame objects into excel sheets.read_excelRead an Excel file into a pandas DataFrame.read_csvRead a comma-separated values (csv) file into DataFrame.io.formats.style.Styler.to_excelAdd styles to Excel sheet.NotesFor compatibility withto_csv(),
to_excel serializes lists and dicts to strings before writing.Once a workbook has been saved it is not possible to write further
data without rewriting the whole workbook.ExamplesCreate, write to and save a workbook:>>>df1=pd.DataFrame([['a','b'],['c','d']],...index=['row 1','row 2'],...columns=['col 1','col 2'])>>>df1.to_excel(""output.xlsx"")To specify the sheet name:>>>df1.to_excel(""output.xlsx"",...sheet_name='Sheet_name_1')If you wish to write to more than one sheet in the workbook, it is
necessary to specify an ExcelWriter object:>>>df2=df1.copy()>>>withpd.ExcelWriter('output.xlsx')aswriter:...df1.to_excel(writer,sheet_name='Sheet_name_1')...df2.to_excel(writer,sheet_name='Sheet_name_2')ExcelWriter can also be used to append to an existing Excel file:>>>withpd.ExcelWriter('output.xlsx',...mode='a')aswriter:...df1.to_excel(writer,sheet_name='Sheet_name_3')To set the library that is used to write the Excel file,
you can pass theenginekeyword (the default engine is
automatically chosen depending on the file extension):>>>df1.to_excel('output1.xlsx',engine='xlsxwriter')"
Pandas,Style,pandas.io.formats.style.Styler.to_string,"pandas.io.formats.style.Styler.to_string#Styler.to_string(buf=None,*,encoding=None,sparse_index=None,sparse_columns=None,max_rows=None,max_columns=None,delimiter='')[source]#Write Styler to a file, buffer or string in text format.New in version 1.5.0.Parameters:bufstr, path object, file-like object, optionalString, path object (implementingos.PathLike[str]), or file-like
object implementing a stringwrite()function. IfNone, the result is
returned as a string.encodingstr, optionalCharacter encoding setting for file output (and meta tags if available).
Defaults topandas.options.styler.render.encodingvalue of “utf-8”.sparse_indexbool, optionalWhether to sparsify the display of a hierarchical index. Setting to False
will display each explicit level element in a hierarchical key for each row.
Defaults topandas.options.styler.sparse.indexvalue.sparse_columnsbool, optionalWhether to sparsify the display of a hierarchical index. Setting to False
will display each explicit level element in a hierarchical key for each
column. Defaults topandas.options.styler.sparse.columnsvalue.max_rowsint, optionalThe maximum number of rows that will be rendered. Defaults topandas.options.styler.render.max_rows, which is None.max_columnsint, optionalThe maximum number of columns that will be rendered. Defaults topandas.options.styler.render.max_columns, which is None.Rows and columns may be reduced if the number of total elements is
large. This value is set topandas.options.styler.render.max_elements,
which is 262144 (18 bit browser rendering).delimiterstr, default single spaceThe separator between data elements.Returns:str or NoneIfbufis None, returns the result as a string. Otherwise returnsNone.Examples>>>df=pd.DataFrame({'A':[1,2],'B':[3,4]})>>>df.style.to_string()' A B\n0 1 3\n1 2 4\n'"
Pandas,Style,pandas.io.formats.style.Styler.export,"pandas.io.formats.style.Styler.export#Styler.export()[source]#Export the styles applied to the current Styler.Can be applied to a second Styler withStyler.use.Returns:dictSee alsoStyler.useSet the styles on the current Styler.Styler.copyCreate a copy of the current Styler.NotesThis method is designed to copy non-data dependent attributes of
one Styler to another. It differs fromStyler.copywhere data and
data dependent attributes are also copied.The following items are exported since they are not generally data dependent:Styling functions added by theapplyandmapWhether axes and names are hidden from the display, if unambiguous.Table attributesTable stylesThe following attributes are considered data dependent and therefore not
exported:CaptionUUIDTooltipsAny hidden rows or columns identified by Index labelsAny formatting applied usingStyler.formatAny CSS classes added usingStyler.set_td_classesExamples>>>styler=pd.DataFrame([[1,2],[3,4]]).style>>>styler2=pd.DataFrame([[9,9,9]]).style>>>styler.hide(axis=0).highlight_max(axis=1)>>>export=styler.export()>>>styler2.use(export)"
Pandas,Style,pandas.io.formats.style.Styler.use,"pandas.io.formats.style.Styler.use#Styler.use(styles)[source]#Set the styles on the current Styler.Possibly uses styles fromStyler.export.Parameters:stylesdict(str, Any)List of attributes to add to Styler. Dict keys should contain only:“apply”: list of styler functions, typically added withapplyormap.“table_attributes”: HTML attributes, typically added withset_table_attributes.“table_styles”: CSS selectors and properties, typically added withset_table_styles.“hide_index”: whether the index is hidden, typically added withhide_index, or a boolean list for hidden levels.“hide_columns”: whether column headers are hidden, typically added withhide_columns, or a boolean list for hidden levels.“hide_index_names”: whether index names are hidden.“hide_column_names”: whether column header names are hidden.“css”: the css class names used.Returns:StylerSee alsoStyler.exportExport the non data dependent attributes to the current Styler.Examples>>>styler=pd.DataFrame([[1,2],[3,4]]).style>>>styler2=pd.DataFrame([[9,9,9]]).style>>>styler.hide(axis=0).highlight_max(axis=1)>>>export=styler.export()>>>styler2.use(export)"
