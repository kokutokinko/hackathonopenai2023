ライブラリ名,章,節,内容
Pandas,Index objects,pandas.Index,"pandas.Index#classpandas.Index(data=None,dtype=None,copy=False,name=None,tupleize_cols=True)[source]#Immutable sequence used for indexing and alignment.The basic object storing axis labels for all pandas objects.Changed in version 2.0.0:Index can hold all numpy numeric dtypes (except float16). Previously only
int64/uint64/float64 dtypes were accepted.Parameters:dataarray-like (1-dimensional)dtypeNumPy dtype (default: object)If dtype is None, we find the dtype that best fits the data.
If an actual dtype is provided, we coerce to that dtype if it’s safe.
Otherwise, an error will be raised.copyboolMake a copy of input ndarray.nameobjectName to be stored in the index.tupleize_colsbool (default: True)When True, attempt to create a MultiIndex if possible.See alsoRangeIndexIndex implementing a monotonic integer range.CategoricalIndexIndex ofCategoricals.MultiIndexA multi-level, or hierarchical Index.IntervalIndexAn Index ofIntervals.DatetimeIndexIndex of datetime64 data.TimedeltaIndexIndex of timedelta64 data.PeriodIndexIndex of Period data.NotesAn Index instance canonlycontain hashable objects.
An Index instancecan nothold numpy float16 dtype.Examples>>>pd.Index([1,2,3])Index([1, 2, 3], dtype='int64')>>>pd.Index(list('abc'))Index(['a', 'b', 'c'], dtype='object')>>>pd.Index([1,2,3],dtype=""uint8"")Index([1, 2, 3], dtype='uint8')AttributesTReturn the transpose, which is by definition self.arrayThe ExtensionArray of the data backing this Series or Index.dtypeReturn the dtype object of the underlying data.has_duplicatesCheck if the Index has duplicate values.hasnansReturn True if there are any NaNs.inferred_typeReturn a string of the type inferred from the values.is_monotonic_decreasingReturn a boolean if the values are equal or decreasing.is_monotonic_increasingReturn a boolean if the values are equal or increasing.is_uniqueReturn if the index has unique values.nameReturn Index or MultiIndex name.nbytesReturn the number of bytes in the underlying data.ndimNumber of dimensions of the underlying data, by definition 1.nlevelsNumber of levels.shapeReturn a tuple of the shape of the underlying data.sizeReturn the number of elements in the underlying data.valuesReturn an array representing the data in the Index.emptynamesMethodsall(*args, **kwargs)Return whether all elements are Truthy.any(*args, **kwargs)Return whether any element is Truthy.append(other)Append a collection of Index options together.argmax([axis, skipna])Return int position of the largest value in the Series.argmin([axis, skipna])Return int position of the smallest value in the Series.argsort(*args, **kwargs)Return the integer indices that would sort the index.asof(label)Return the label from the index, or, if not present, the previous one.asof_locs(where, mask)Return the locations (indices) of labels in the index.astype(dtype[, copy])Create an Index with values cast to dtypes.copy([name, deep])Make a copy of this object.delete(loc)Make new Index with passed location(-s) deleted.diff([periods])Computes the difference between consecutive values in the Index object.difference(other[, sort])Return a new Index with elements of index not inother.drop(labels[, errors])Make new Index with passed list of labels deleted.drop_duplicates(*[, keep])Return Index with duplicate values removed.droplevel([level])Return index with requested level(s) removed.dropna([how])Return Index without NA/NaN values.duplicated([keep])Indicate duplicate index values.equals(other)Determine if two Index object are equal.factorize([sort, use_na_sentinel])Encode the object as an enumerated type or categorical variable.fillna([value, downcast])Fill NA/NaN values with the specified value.format([name, formatter, na_rep])Render a string representation of the Index.get_indexer(target[, method, limit, tolerance])Compute indexer and mask for new index given the current index.get_indexer_for(target)Guaranteed return of an indexer even when non-unique.get_indexer_non_unique(target)Compute indexer and mask for new index given the current index.get_level_values(level)Return an Index of values for requested level.get_loc(key)Get integer location, slice or boolean mask for requested label.get_slice_bound(label, side)Calculate slice bound that corresponds to given label.groupby(values)Group the index labels by a given array of values.holds_integer()(DEPRECATED) Whether the type is an integer type.identical(other)Similar to equals, but checks that object attributes and types are also equal.infer_objects([copy])If we have an object dtype, try to infer a non-object dtype.insert(loc, item)Make new Index inserting new item at location.intersection(other[, sort])Form the intersection of two Index objects.is_(other)More flexible, faster check likeisbut that works through views.is_boolean()(DEPRECATED) Check if the Index only consists of booleans.is_categorical()(DEPRECATED) Check if the Index holds categorical data.is_floating()(DEPRECATED) Check if the Index is a floating type.is_integer()(DEPRECATED) Check if the Index only consists of integers.is_interval()(DEPRECATED) Check if the Index holds Interval objects.is_numeric()(DEPRECATED) Check if the Index only consists of numeric data.is_object()(DEPRECATED) Check if the Index is of the object dtype.isin(values[, level])Return a boolean array where the index values are invalues.isna()Detect missing values.isnull()Detect missing values.item()Return the first element of the underlying data as a Python scalar.join(other, *[, how, level, ...])Compute join_index and indexers to conform data structures to the new index.map(mapper[, na_action])Map values using an input mapping or function.max([axis, skipna])Return the maximum value of the Index.memory_usage([deep])Memory usage of the values.min([axis, skipna])Return the minimum value of the Index.notna()Detect existing (non-missing) values.notnull()Detect existing (non-missing) values.nunique([dropna])Return number of unique elements in the object.putmask(mask, value)Return a new Index of the values set with the mask.ravel([order])Return a view on self.reindex(target[, method, level, limit, ...])Create index with target's values.rename(name[, inplace])Alter Index or MultiIndex name.repeat(repeats[, axis])Repeat elements of a Index.round([decimals])Round each value in the Index to the given number of decimals.searchsorted(value[, side, sorter])Find indices where elements should be inserted to maintain order.set_names(names, *[, level, inplace])Set Index or MultiIndex name.shift([periods, freq])Shift index by desired number of time frequency increments.slice_indexer([start, end, step])Compute the slice indexer for input labels and step.slice_locs([start, end, step])Compute slice locations for input labels.sort(*args, **kwargs)Use sort_values instead.sort_values([return_indexer, ascending, ...])Return a sorted copy of the index.sortlevel([level, ascending, ...])For internal compatibility with the Index API.stralias ofStringMethodssymmetric_difference(other[, result_name, sort])Compute the symmetric difference of two Index objects.take(indices[, axis, allow_fill, fill_value])Return a new Index of the values selected by the indices.to_flat_index()Identity method.to_frame([index, name])Create a DataFrame with a column containing the Index.to_list()Return a list of the values.to_numpy([dtype, copy, na_value])A NumPy ndarray representing the values in this Series or Index.to_series([index, name])Create a Series with both index and values equal to the index keys.tolist()Return a list of the values.transpose(*args, **kwargs)Return the transpose, which is by definition self.union(other[, sort])Form the union of two Index objects.unique([level])Return unique values in the index.value_counts([normalize, sort, ascending, ...])Return a Series containing counts of unique values.where(cond[, other])Replace values where the condition is False.view"
Pandas,Index objects,pandas.Index.values,"pandas.Index.values#propertyIndex.values[source]#Return an array representing the data in the Index.WarningWe recommend usingIndex.arrayorIndex.to_numpy(), depending on whether you need
a reference to the underlying data or a NumPy array.Returns:array: numpy.ndarray or ExtensionArraySee alsoIndex.arrayReference to the underlying data.Index.to_numpyA NumPy array representing the underlying data.ExamplesForpandas.Index:>>>idx=pd.Index([1,2,3])>>>idxIndex([1, 2, 3], dtype='int64')>>>idx.valuesarray([1, 2, 3])Forpandas.IntervalIndex:>>>idx=pd.interval_range(start=0,end=5)>>>idx.values<IntervalArray>[(0, 1], (1, 2], (2, 3], (3, 4], (4, 5]]Length: 5, dtype: interval[int64, right]"
Pandas,Index objects,pandas.Index.is_monotonic_increasing,"pandas.Index.is_monotonic_increasing#propertyIndex.is_monotonic_increasing[source]#Return a boolean if the values are equal or increasing.Returns:boolSee alsoIndex.is_monotonic_decreasingCheck if the values are equal or decreasing.Examples>>>pd.Index([1,2,3]).is_monotonic_increasingTrue>>>pd.Index([1,2,2]).is_monotonic_increasingTrue>>>pd.Index([1,3,2]).is_monotonic_increasingFalse"
Pandas,Index objects,pandas.Index.is_monotonic_decreasing,"pandas.Index.is_monotonic_decreasing#propertyIndex.is_monotonic_decreasing[source]#Return a boolean if the values are equal or decreasing.Returns:boolSee alsoIndex.is_monotonic_increasingCheck if the values are equal or increasing.Examples>>>pd.Index([3,2,1]).is_monotonic_decreasingTrue>>>pd.Index([3,2,2]).is_monotonic_decreasingTrue>>>pd.Index([3,1,2]).is_monotonic_decreasingFalse"
Pandas,Index objects,pandas.Index.is_unique,"pandas.Index.is_unique#Index.is_unique[source]#Return if the index has unique values.Returns:boolSee alsoIndex.has_duplicatesInverse method that checks if it has duplicate values.Examples>>>idx=pd.Index([1,5,7,7])>>>idx.is_uniqueFalse>>>idx=pd.Index([1,5,7])>>>idx.is_uniqueTrue>>>idx=pd.Index([""Watermelon"",""Orange"",""Apple"",...""Watermelon""]).astype(""category"")>>>idx.is_uniqueFalse>>>idx=pd.Index([""Orange"",""Apple"",...""Watermelon""]).astype(""category"")>>>idx.is_uniqueTrue"
Pandas,Index objects,pandas.Index.has_duplicates,"pandas.Index.has_duplicates#propertyIndex.has_duplicates[source]#Check if the Index has duplicate values.Returns:boolWhether or not the Index has duplicate values.See alsoIndex.is_uniqueInverse method that checks if it has unique values.Examples>>>idx=pd.Index([1,5,7,7])>>>idx.has_duplicatesTrue>>>idx=pd.Index([1,5,7])>>>idx.has_duplicatesFalse>>>idx=pd.Index([""Watermelon"",""Orange"",""Apple"",...""Watermelon""]).astype(""category"")>>>idx.has_duplicatesTrue>>>idx=pd.Index([""Orange"",""Apple"",...""Watermelon""]).astype(""category"")>>>idx.has_duplicatesFalse"
Pandas,Index objects,pandas.Index.hasnans,"pandas.Index.hasnans#Index.hasnans[source]#Return True if there are any NaNs.Enables various performance speedups.Returns:boolExamples>>>s=pd.Series([1,2,3],index=['a','b',None])>>>sa    1b    2None 3dtype: int64>>>s.index.hasnansTrue"
Pandas,Index objects,pandas.Index.dtype,"pandas.Index.dtype#Index.dtype[source]#Return the dtype object of the underlying data.Examples>>>idx=pd.Index([1,2,3])>>>idxIndex([1, 2, 3], dtype='int64')>>>idx.dtypedtype('int64')"
Pandas,Index objects,pandas.Index.inferred_type,"pandas.Index.inferred_type#Index.inferred_type[source]#Return a string of the type inferred from the values.Examples>>>idx=pd.Index([1,2,3])>>>idxIndex([1, 2, 3], dtype='int64')>>>idx.inferred_type'integer'"
Pandas,Index objects,pandas.Index.shape,"pandas.Index.shape#propertyIndex.shape[source]#Return a tuple of the shape of the underlying data.Examples>>>idx=pd.Index([1,2,3])>>>idxIndex([1, 2, 3], dtype='int64')>>>idx.shape(3,)"
Pandas,Index objects,pandas.Index.name,"pandas.Index.name#propertyIndex.name[source]#Return Index or MultiIndex name.Examples>>>idx=pd.Index([1,2,3],name='x')>>>idxIndex([1, 2, 3], dtype='int64',  name='x')>>>idx.name'x'"
Pandas,Index objects,pandas.Index.names,pandas.Index.names#propertyIndex.names[source]#
Pandas,Index objects,pandas.Index.nbytes,"pandas.Index.nbytes#propertyIndex.nbytes[source]#Return the number of bytes in the underlying data.ExamplesFor Series:>>>s=pd.Series(['Ant','Bear','Cow'])>>>s0     Ant1    Bear2     Cowdtype: object>>>s.nbytes24For Index:>>>idx=pd.Index([1,2,3])>>>idxIndex([1, 2, 3], dtype='int64')>>>idx.nbytes24"
Pandas,Index objects,pandas.Index.ndim,"pandas.Index.ndim#propertyIndex.ndim[source]#Number of dimensions of the underlying data, by definition 1.Examples>>>s=pd.Series(['Ant','Bear','Cow'])>>>s0     Ant1    Bear2     Cowdtype: object>>>s.ndim1For Index:>>>idx=pd.Index([1,2,3])>>>idxIndex([1, 2, 3], dtype='int64')>>>idx.ndim1"
Pandas,Index objects,pandas.Index.size,"pandas.Index.size#propertyIndex.size[source]#Return the number of elements in the underlying data.ExamplesFor Series:>>>s=pd.Series(['Ant','Bear','Cow'])>>>s0     Ant1    Bear2     Cowdtype: object>>>s.size3For Index:>>>idx=pd.Index([1,2,3])>>>idxIndex([1, 2, 3], dtype='int64')>>>idx.size3"
Pandas,Index objects,pandas.Index.empty,pandas.Index.empty#propertyIndex.empty[source]#
Pandas,Index objects,pandas.Index.T,"pandas.Index.T#propertyIndex.T[source]#Return the transpose, which is by definition self.ExamplesFor Series:>>>s=pd.Series(['Ant','Bear','Cow'])>>>s0     Ant1    Bear2     Cowdtype: object>>>s.T0     Ant1    Bear2     Cowdtype: objectFor Index:>>>idx=pd.Index([1,2,3])>>>idx.TIndex([1, 2, 3], dtype='int64')"
Pandas,Index objects,pandas.Index.memory_usage,"pandas.Index.memory_usage#Index.memory_usage(deep=False)[source]#Memory usage of the values.Parameters:deepbool, default FalseIntrospect the data deeply, interrogateobjectdtypes for system-level memory consumption.Returns:bytes usedSee alsonumpy.ndarray.nbytesTotal bytes consumed by the elements of the array.NotesMemory usage does not include memory consumed by elements that
are not components of the array if deep=False or if used on PyPyExamples>>>idx=pd.Index([1,2,3])>>>idx.memory_usage()24"
Pandas,Index objects,pandas.Index.all,"pandas.Index.all#Index.all(*args,**kwargs)[source]#Return whether all elements are Truthy.Parameters:*argsRequired for compatibility with numpy.**kwargsRequired for compatibility with numpy.Returns:bool or array-like (if axis is specified)A single element array-like may be converted to bool.See alsoIndex.anyReturn whether any element in an Index is True.Series.anyReturn whether any element in a Series is True.Series.allReturn whether all elements in a Series are True.NotesNot a Number (NaN), positive infinity and negative infinity
evaluate to True because these are not equal to zero.ExamplesTrue, because nonzero integers are considered True.>>>pd.Index([1,2,3]).all()TrueFalse, because0is considered False.>>>pd.Index([0,1,2]).all()False"
Pandas,Index objects,pandas.Index.any,"pandas.Index.any#Index.any(*args,**kwargs)[source]#Return whether any element is Truthy.Parameters:*argsRequired for compatibility with numpy.**kwargsRequired for compatibility with numpy.Returns:bool or array-like (if axis is specified)A single element array-like may be converted to bool.See alsoIndex.allReturn whether all elements are True.Series.allReturn whether all elements are True.NotesNot a Number (NaN), positive infinity and negative infinity
evaluate to True because these are not equal to zero.Examples>>>index=pd.Index([0,1,2])>>>index.any()True>>>index=pd.Index([0,0,0])>>>index.any()False"
Pandas,Index objects,pandas.Index.argmin,"pandas.Index.argmin#Index.argmin(axis=None,skipna=True,*args,**kwargs)[source]#Return int position of the smallest value in the Series.If the minimum is achieved in multiple locations,
the first row position is returned.Parameters:axis{None}Unused. Parameter needed for compatibility with DataFrame.skipnabool, default TrueExclude NA/null values when showing the result.*args, **kwargsAdditional arguments and keywords for compatibility with NumPy.Returns:intRow position of the minimum value.See alsoSeries.argminReturn position of the minimum value.Series.argmaxReturn position of the maximum value.numpy.ndarray.argminEquivalent method for numpy arrays.Series.idxmaxReturn index label of the maximum values.Series.idxminReturn index label of the minimum values.ExamplesConsider dataset containing cereal calories>>>s=pd.Series({'Corn Flakes':100.0,'Almond Delight':110.0,...'Cinnamon Toast Crunch':120.0,'Cocoa Puff':110.0})>>>sCorn Flakes              100.0Almond Delight           110.0Cinnamon Toast Crunch    120.0Cocoa Puff               110.0dtype: float64>>>s.argmax()2>>>s.argmin()0The maximum cereal calories is the third element and
the minimum cereal calories is the first element,
since series is zero-indexed."
Pandas,Index objects,pandas.Index.argmax,"pandas.Index.argmax#Index.argmax(axis=None,skipna=True,*args,**kwargs)[source]#Return int position of the largest value in the Series.If the maximum is achieved in multiple locations,
the first row position is returned.Parameters:axis{None}Unused. Parameter needed for compatibility with DataFrame.skipnabool, default TrueExclude NA/null values when showing the result.*args, **kwargsAdditional arguments and keywords for compatibility with NumPy.Returns:intRow position of the maximum value.See alsoSeries.argmaxReturn position of the maximum value.Series.argminReturn position of the minimum value.numpy.ndarray.argmaxEquivalent method for numpy arrays.Series.idxmaxReturn index label of the maximum values.Series.idxminReturn index label of the minimum values.ExamplesConsider dataset containing cereal calories>>>s=pd.Series({'Corn Flakes':100.0,'Almond Delight':110.0,...'Cinnamon Toast Crunch':120.0,'Cocoa Puff':110.0})>>>sCorn Flakes              100.0Almond Delight           110.0Cinnamon Toast Crunch    120.0Cocoa Puff               110.0dtype: float64>>>s.argmax()2>>>s.argmin()0The maximum cereal calories is the third element and
the minimum cereal calories is the first element,
since series is zero-indexed."
Pandas,Index objects,pandas.Index.copy,"pandas.Index.copy#Index.copy(name=None,deep=False)[source]#Make a copy of this object.Name is set on the new object.Parameters:nameLabel, optionalSet name for new object.deepbool, default FalseReturns:IndexIndex refer to new object which is a copy of this object.NotesIn most cases, there should be no functional difference from usingdeep, but ifdeepis passed it will attempt to deepcopy.Examples>>>idx=pd.Index(['a','b','c'])>>>new_idx=idx.copy()>>>idxisnew_idxFalse"
Pandas,Index objects,pandas.Index.delete,"pandas.Index.delete#Index.delete(loc)[source]#Make new Index with passed location(-s) deleted.Parameters:locint or list of intLocation of item(-s) which will be deleted.
Use a list of locations to delete more than one value at the same time.Returns:IndexWill be same type as self, except for RangeIndex.See alsonumpy.deleteDelete any rows and column from NumPy array (ndarray).Examples>>>idx=pd.Index(['a','b','c'])>>>idx.delete(1)Index(['a', 'c'], dtype='object')>>>idx=pd.Index(['a','b','c'])>>>idx.delete([0,2])Index(['b'], dtype='object')"
Pandas,Index objects,pandas.Index.drop,"pandas.Index.drop#Index.drop(labels,errors='raise')[source]#Make new Index with passed list of labels deleted.Parameters:labelsarray-like or scalarerrors{‘ignore’, ‘raise’}, default ‘raise’If ‘ignore’, suppress error and existing labels are dropped.Returns:IndexWill be same type as self, except for RangeIndex.Raises:KeyErrorIf not all of the labels are found in the selected axisExamples>>>idx=pd.Index(['a','b','c'])>>>idx.drop(['a'])Index(['b', 'c'], dtype='object')"
Pandas,Index objects,pandas.Index.drop_duplicates,"pandas.Index.drop_duplicates#Index.drop_duplicates(*,keep='first')[source]#Return Index with duplicate values removed.Parameters:keep{‘first’, ‘last’,False}, default ‘first’‘first’ : Drop duplicates except for the first occurrence.‘last’ : Drop duplicates except for the last occurrence.False: Drop all duplicates.Returns:IndexSee alsoSeries.drop_duplicatesEquivalent method on Series.DataFrame.drop_duplicatesEquivalent method on DataFrame.Index.duplicatedRelated method on Index, indicating duplicate Index values.ExamplesGenerate an pandas.Index with duplicate values.>>>idx=pd.Index(['lama','cow','lama','beetle','lama','hippo'])Thekeepparameter controls which duplicate values are removed.
The value ‘first’ keeps the first occurrence for each
set of duplicated entries. The default value of keep is ‘first’.>>>idx.drop_duplicates(keep='first')Index(['lama', 'cow', 'beetle', 'hippo'], dtype='object')The value ‘last’ keeps the last occurrence for each set of duplicated
entries.>>>idx.drop_duplicates(keep='last')Index(['cow', 'beetle', 'lama', 'hippo'], dtype='object')The valueFalsediscards all sets of duplicated entries.>>>idx.drop_duplicates(keep=False)Index(['cow', 'beetle', 'hippo'], dtype='object')"
Pandas,Index objects,pandas.Index.duplicated,"pandas.Index.duplicated#Index.duplicated(keep='first')[source]#Indicate duplicate index values.Duplicated values are indicated asTruevalues in the resulting
array. Either all duplicates, all except the first, or all except the
last occurrence of duplicates can be indicated.Parameters:keep{‘first’, ‘last’, False}, default ‘first’The value or values in a set of duplicates to mark as missing.‘first’ : Mark duplicates asTrueexcept for the first
occurrence.‘last’ : Mark duplicates asTrueexcept for the last
occurrence.False: Mark all duplicates asTrue.Returns:np.ndarray[bool]See alsoSeries.duplicatedEquivalent method on pandas.Series.DataFrame.duplicatedEquivalent method on pandas.DataFrame.Index.drop_duplicatesRemove duplicate values from Index.ExamplesBy default, for each set of duplicated values, the first occurrence is
set to False and all others to True:>>>idx=pd.Index(['lama','cow','lama','beetle','lama'])>>>idx.duplicated()array([False, False,  True, False,  True])which is equivalent to>>>idx.duplicated(keep='first')array([False, False,  True, False,  True])By using ‘last’, the last occurrence of each set of duplicated values
is set on False and all others on True:>>>idx.duplicated(keep='last')array([ True, False,  True, False, False])By setting keep onFalse, all duplicates are True:>>>idx.duplicated(keep=False)array([ True, False,  True, False,  True])"
Pandas,Index objects,pandas.Index.equals,"pandas.Index.equals#Index.equals(other)[source]#Determine if two Index object are equal.The things that are being compared are:The elements inside the Index object.The order of the elements inside the Index object.Parameters:otherAnyThe other object to compare against.Returns:boolTrue if “other” is an Index and it has the same elements and order
as the calling index; False otherwise.Examples>>>idx1=pd.Index([1,2,3])>>>idx1Index([1, 2, 3], dtype='int64')>>>idx1.equals(pd.Index([1,2,3]))TrueThe elements inside are compared>>>idx2=pd.Index([""1"",""2"",""3""])>>>idx2Index(['1', '2', '3'], dtype='object')>>>idx1.equals(idx2)FalseThe order is compared>>>ascending_idx=pd.Index([1,2,3])>>>ascending_idxIndex([1, 2, 3], dtype='int64')>>>descending_idx=pd.Index([3,2,1])>>>descending_idxIndex([3, 2, 1], dtype='int64')>>>ascending_idx.equals(descending_idx)FalseThe dtype isnotcompared>>>int64_idx=pd.Index([1,2,3],dtype='int64')>>>int64_idxIndex([1, 2, 3], dtype='int64')>>>uint64_idx=pd.Index([1,2,3],dtype='uint64')>>>uint64_idxIndex([1, 2, 3], dtype='uint64')>>>int64_idx.equals(uint64_idx)True"
Pandas,Index objects,pandas.Index.factorize,"pandas.Index.factorize#Index.factorize(sort=False,use_na_sentinel=True)[source]#Encode the object as an enumerated type or categorical variable.This method is useful for obtaining a numeric representation of an
array when all that matters is identifying distinct values.factorizeis available as both a top-level functionpandas.factorize(),
and as a methodSeries.factorize()andIndex.factorize().Parameters:sortbool, default FalseSortuniquesand shufflecodesto maintain the
relationship.use_na_sentinelbool, default TrueIf True, the sentinel -1 will be used for NaN values. If False,
NaN values will be encoded as non-negative integers and will not drop the
NaN from the uniques of the values.New in version 1.5.0.Returns:codesndarrayAn integer ndarray that’s an indexer intouniques.uniques.take(codes)will have the same values asvalues.uniquesndarray, Index, or CategoricalThe unique valid values. Whenvaluesis Categorical,uniquesis a Categorical. Whenvaluesis some other pandas object, anIndexis returned. Otherwise, a 1-D ndarray is returned.NoteEven if there’s a missing value invalues,uniqueswillnotcontain an entry for it.See alsocutDiscretize continuous-valued array.uniqueFind the unique value in an array.NotesReferencethe user guidefor more examples.ExamplesThese examples all show factorize as a top-level method likepd.factorize(values). The results are identical for methods likeSeries.factorize().>>>codes,uniques=pd.factorize(np.array(['b','b','a','c','b'],dtype=""O""))>>>codesarray([0, 0, 1, 2, 0])>>>uniquesarray(['b', 'a', 'c'], dtype=object)Withsort=True, theuniqueswill be sorted, andcodeswill be
shuffled so that the relationship is the maintained.>>>codes,uniques=pd.factorize(np.array(['b','b','a','c','b'],dtype=""O""),...sort=True)>>>codesarray([1, 1, 0, 2, 1])>>>uniquesarray(['a', 'b', 'c'], dtype=object)Whenuse_na_sentinel=True(the default), missing values are indicated in
thecodeswith the sentinel value-1and missing values are not
included inuniques.>>>codes,uniques=pd.factorize(np.array(['b',None,'a','c','b'],dtype=""O""))>>>codesarray([ 0, -1,  1,  2,  0])>>>uniquesarray(['b', 'a', 'c'], dtype=object)Thus far, we’ve only factorized lists (which are internally coerced to
NumPy arrays). When factorizing pandas objects, the type ofuniqueswill differ. For Categoricals, aCategoricalis returned.>>>cat=pd.Categorical(['a','a','c'],categories=['a','b','c'])>>>codes,uniques=pd.factorize(cat)>>>codesarray([0, 0, 1])>>>uniques['a', 'c']Categories (3, object): ['a', 'b', 'c']Notice that'b'is inuniques.categories, despite not being
present incat.values.For all other pandas objects, an Index of the appropriate type is
returned.>>>cat=pd.Series(['a','a','c'])>>>codes,uniques=pd.factorize(cat)>>>codesarray([0, 0, 1])>>>uniquesIndex(['a', 'c'], dtype='object')If NaN is in the values, and we want to include NaN in the uniques of the
values, it can be achieved by settinguse_na_sentinel=False.>>>values=np.array([1,2,1,np.nan])>>>codes,uniques=pd.factorize(values)# default: use_na_sentinel=True>>>codesarray([ 0,  1,  0, -1])>>>uniquesarray([1., 2.])>>>codes,uniques=pd.factorize(values,use_na_sentinel=False)>>>codesarray([0, 1, 0, 2])>>>uniquesarray([ 1.,  2., nan])"
Pandas,Index objects,pandas.Index.identical,"pandas.Index.identical#finalIndex.identical(other)[source]#Similar to equals, but checks that object attributes and types are also equal.Returns:boolIf two Index objects have equal elements and same type True,
otherwise False.Examples>>>idx1=pd.Index(['1','2','3'])>>>idx2=pd.Index(['1','2','3'])>>>idx2.identical(idx1)True>>>idx1=pd.Index(['1','2','3'],name=""A"")>>>idx2=pd.Index(['1','2','3'],name=""B"")>>>idx2.identical(idx1)False"
Pandas,Index objects,pandas.Index.insert,"pandas.Index.insert#Index.insert(loc,item)[source]#Make new Index inserting new item at location.Follows Python numpy.insert semantics for negative values.Parameters:locintitemobjectReturns:IndexExamples>>>idx=pd.Index(['a','b','c'])>>>idx.insert(1,'x')Index(['a', 'x', 'b', 'c'], dtype='object')"
Pandas,Index objects,pandas.Index.is_,"pandas.Index.is_#finalIndex.is_(other)[source]#More flexible, faster check likeisbut that works through views.Note: this isnotthe same asIndex.identical(), which checks
that metadata is also the same.Parameters:otherobjectOther object to compare against.Returns:boolTrue if both have same underlying data, False otherwise.See alsoIndex.identicalWorks likeIndex.is_but also checks metadata.Examples>>>idx1=pd.Index(['1','2','3'])>>>idx1.is_(idx1.view())True>>>idx1.is_(idx1.copy())False"
Pandas,Index objects,pandas.Index.is_boolean,"pandas.Index.is_boolean#finalIndex.is_boolean()[source]#Check if the Index only consists of booleans.Deprecated since version 2.0.0:Usepandas.api.types.is_bool_dtypeinstead.Returns:boolWhether or not the Index only consists of booleans.See alsois_integerCheck if the Index only consists of integers (deprecated).is_floatingCheck if the Index is a floating type (deprecated).is_numericCheck if the Index only consists of numeric data (deprecated).is_objectCheck if the Index is of the object dtype (deprecated).is_categoricalCheck if the Index holds categorical data.is_intervalCheck if the Index holds Interval objects (deprecated).Examples>>>idx=pd.Index([True,False,True])>>>idx.is_boolean()True>>>idx=pd.Index([""True"",""False"",""True""])>>>idx.is_boolean()False>>>idx=pd.Index([True,False,""True""])>>>idx.is_boolean()False"
Pandas,Index objects,pandas.Index.is_categorical,"pandas.Index.is_categorical#finalIndex.is_categorical()[source]#Check if the Index holds categorical data.Deprecated since version 2.0.0:Useisinstance(index.dtype, pd.CategoricalDtype)instead.Returns:boolTrue if the Index is categorical.See alsoCategoricalIndexIndex for categorical data.is_booleanCheck if the Index only consists of booleans (deprecated).is_integerCheck if the Index only consists of integers (deprecated).is_floatingCheck if the Index is a floating type (deprecated).is_numericCheck if the Index only consists of numeric data (deprecated).is_objectCheck if the Index is of the object dtype. (deprecated).is_intervalCheck if the Index holds Interval objects (deprecated).Examples>>>idx=pd.Index([""Watermelon"",""Orange"",""Apple"",...""Watermelon""]).astype(""category"")>>>idx.is_categorical()True>>>idx=pd.Index([1,3,5,7])>>>idx.is_categorical()False>>>s=pd.Series([""Peter"",""Victor"",""Elisabeth"",""Mar""])>>>s0        Peter1       Victor2    Elisabeth3          Mardtype: object>>>s.index.is_categorical()False"
Pandas,Index objects,pandas.Index.is_floating,"pandas.Index.is_floating#finalIndex.is_floating()[source]#Check if the Index is a floating type.Deprecated since version 2.0.0:Usepandas.api.types.is_float_dtypeinsteadThe Index may consist of only floats, NaNs, or a mix of floats,
integers, or NaNs.Returns:boolWhether or not the Index only consists of only consists of floats, NaNs, or
a mix of floats, integers, or NaNs.See alsois_booleanCheck if the Index only consists of booleans (deprecated).is_integerCheck if the Index only consists of integers (deprecated).is_numericCheck if the Index only consists of numeric data (deprecated).is_objectCheck if the Index is of the object dtype. (deprecated).is_categoricalCheck if the Index holds categorical data (deprecated).is_intervalCheck if the Index holds Interval objects (deprecated).Examples>>>idx=pd.Index([1.0,2.0,3.0,4.0])>>>idx.is_floating()True>>>idx=pd.Index([1.0,2.0,np.nan,4.0])>>>idx.is_floating()True>>>idx=pd.Index([1,2,3,4,np.nan])>>>idx.is_floating()True>>>idx=pd.Index([1,2,3,4])>>>idx.is_floating()False"
Pandas,Index objects,pandas.Index.is_integer,"pandas.Index.is_integer#finalIndex.is_integer()[source]#Check if the Index only consists of integers.Deprecated since version 2.0.0:Usepandas.api.types.is_integer_dtypeinstead.Returns:boolWhether or not the Index only consists of integers.See alsois_booleanCheck if the Index only consists of booleans (deprecated).is_floatingCheck if the Index is a floating type (deprecated).is_numericCheck if the Index only consists of numeric data (deprecated).is_objectCheck if the Index is of the object dtype. (deprecated).is_categoricalCheck if the Index holds categorical data (deprecated).is_intervalCheck if the Index holds Interval objects (deprecated).Examples>>>idx=pd.Index([1,2,3,4])>>>idx.is_integer()True>>>idx=pd.Index([1.0,2.0,3.0,4.0])>>>idx.is_integer()False>>>idx=pd.Index([""Apple"",""Mango"",""Watermelon""])>>>idx.is_integer()False"
Pandas,Index objects,pandas.Index.is_interval,"pandas.Index.is_interval#finalIndex.is_interval()[source]#Check if the Index holds Interval objects.Deprecated since version 2.0.0:Useisinstance(index.dtype, pd.IntervalDtype)instead.Returns:boolWhether or not the Index holds Interval objects.See alsoIntervalIndexIndex for Interval objects.is_booleanCheck if the Index only consists of booleans (deprecated).is_integerCheck if the Index only consists of integers (deprecated).is_floatingCheck if the Index is a floating type (deprecated).is_numericCheck if the Index only consists of numeric data (deprecated).is_objectCheck if the Index is of the object dtype. (deprecated).is_categoricalCheck if the Index holds categorical data (deprecated).Examples>>>idx=pd.Index([pd.Interval(left=0,right=5),...pd.Interval(left=5,right=10)])>>>idx.is_interval()True>>>idx=pd.Index([1,3,5,7])>>>idx.is_interval()False"
Pandas,Index objects,pandas.Index.is_numeric,"pandas.Index.is_numeric#finalIndex.is_numeric()[source]#Check if the Index only consists of numeric data.Deprecated since version 2.0.0:Usepandas.api.types.is_numeric_dtypeinstead.Returns:boolWhether or not the Index only consists of numeric data.See alsois_booleanCheck if the Index only consists of booleans (deprecated).is_integerCheck if the Index only consists of integers (deprecated).is_floatingCheck if the Index is a floating type (deprecated).is_objectCheck if the Index is of the object dtype. (deprecated).is_categoricalCheck if the Index holds categorical data (deprecated).is_intervalCheck if the Index holds Interval objects (deprecated).Examples>>>idx=pd.Index([1.0,2.0,3.0,4.0])>>>idx.is_numeric()True>>>idx=pd.Index([1,2,3,4.0])>>>idx.is_numeric()True>>>idx=pd.Index([1,2,3,4])>>>idx.is_numeric()True>>>idx=pd.Index([1,2,3,4.0,np.nan])>>>idx.is_numeric()True>>>idx=pd.Index([1,2,3,4.0,np.nan,""Apple""])>>>idx.is_numeric()False"
Pandas,Index objects,pandas.Index.is_object,"pandas.Index.is_object#finalIndex.is_object()[source]#Check if the Index is of the object dtype.Deprecated since version 2.0.0:Usepandas.api.types.is_object_dtypeinstead.Returns:boolWhether or not the Index is of the object dtype.See alsois_booleanCheck if the Index only consists of booleans (deprecated).is_integerCheck if the Index only consists of integers (deprecated).is_floatingCheck if the Index is a floating type (deprecated).is_numericCheck if the Index only consists of numeric data (deprecated).is_categoricalCheck if the Index holds categorical data (deprecated).is_intervalCheck if the Index holds Interval objects (deprecated).Examples>>>idx=pd.Index([""Apple"",""Mango"",""Watermelon""])>>>idx.is_object()True>>>idx=pd.Index([""Apple"",""Mango"",2.0])>>>idx.is_object()True>>>idx=pd.Index([""Watermelon"",""Orange"",""Apple"",...""Watermelon""]).astype(""category"")>>>idx.is_object()False>>>idx=pd.Index([1.0,2.0,3.0,4.0])>>>idx.is_object()False"
Pandas,Index objects,pandas.Index.min,"pandas.Index.min#Index.min(axis=None,skipna=True,*args,**kwargs)[source]#Return the minimum value of the Index.Parameters:axis{None}Dummy argument for consistency with Series.skipnabool, default TrueExclude NA/null values when showing the result.*args, **kwargsAdditional arguments and keywords for compatibility with NumPy.Returns:scalarMinimum value.See alsoIndex.maxReturn the maximum value of the object.Series.minReturn the minimum value in a Series.DataFrame.minReturn the minimum values in a DataFrame.Examples>>>idx=pd.Index([3,2,1])>>>idx.min()1>>>idx=pd.Index(['c','b','a'])>>>idx.min()'a'For a MultiIndex, the minimum is determined lexicographically.>>>idx=pd.MultiIndex.from_product([('a','b'),(2,1)])>>>idx.min()('a', 1)"
Pandas,Index objects,pandas.Index.max,"pandas.Index.max#Index.max(axis=None,skipna=True,*args,**kwargs)[source]#Return the maximum value of the Index.Parameters:axisint, optionalFor compatibility with NumPy. Only 0 or None are allowed.skipnabool, default TrueExclude NA/null values when showing the result.*args, **kwargsAdditional arguments and keywords for compatibility with NumPy.Returns:scalarMaximum value.See alsoIndex.minReturn the minimum value in an Index.Series.maxReturn the maximum value in a Series.DataFrame.maxReturn the maximum values in a DataFrame.Examples>>>idx=pd.Index([3,2,1])>>>idx.max()3>>>idx=pd.Index(['c','b','a'])>>>idx.max()'c'For a MultiIndex, the maximum is determined lexicographically.>>>idx=pd.MultiIndex.from_product([('a','b'),(2,1)])>>>idx.max()('b', 2)"
Pandas,Index objects,pandas.Index.reindex,"pandas.Index.reindex#Index.reindex(target,method=None,level=None,limit=None,tolerance=None)[source]#Create index with target’s values.Parameters:targetan iterablemethod{None, ‘pad’/’ffill’, ‘backfill’/’bfill’, ‘nearest’}, optionaldefault: exact matches only.pad / ffill: find the PREVIOUS index value if no exact match.backfill / bfill: use NEXT index value if no exact matchnearest: use the NEAREST index value if no exact match. Tied
distances are broken by preferring the larger index value.levelint, optionalLevel of multiindex.limitint, optionalMaximum number of consecutive labels intargetto match for
inexact matches.toleranceint or float, optionalMaximum distance between original and new labels for inexact
matches. The values of the index at the matching locations must
satisfy the equationabs(index[indexer]-target)<=tolerance.Tolerance may be a scalar value, which applies the same tolerance
to all values, or list-like, which applies variable tolerance per
element. List-like includes list, tuple, array, Series, and must be
the same size as the index and its dtype must exactly match the
index’s type.Returns:new_indexpd.IndexResulting index.indexernp.ndarray[np.intp] or NoneIndices of output values in original index.Raises:TypeErrorIfmethodpassed along withlevel.ValueErrorIf non-unique multi-indexValueErrorIf non-unique index andmethodorlimitpassed.See alsoSeries.reindexConform Series to new index with optional filling logic.DataFrame.reindexConform DataFrame to new index with optional filling logic.Examples>>>idx=pd.Index(['car','bike','train','tractor'])>>>idxIndex(['car', 'bike', 'train', 'tractor'], dtype='object')>>>idx.reindex(['car','bike'])(Index(['car', 'bike'], dtype='object'), array([0, 1]))"
Pandas,Index objects,pandas.Index.rename,"pandas.Index.rename#Index.rename(name,inplace=False)[source]#Alter Index or MultiIndex name.Able to set new names without level. Defaults to returning new index.
Length of names must match number of levels in MultiIndex.Parameters:namelabel or list of labelsName(s) to set.inplacebool, default FalseModifies the object directly, instead of creating a new Index or
MultiIndex.Returns:Index or NoneThe same type as the caller or None ifinplace=True.See alsoIndex.set_namesAble to set new names partially and by level.Examples>>>idx=pd.Index(['A','C','A','B'],name='score')>>>idx.rename('grade')Index(['A', 'C', 'A', 'B'], dtype='object', name='grade')>>>idx=pd.MultiIndex.from_product([['python','cobra'],...[2018,2019]],...names=['kind','year'])>>>idxMultiIndex([('python', 2018),('python', 2019),( 'cobra', 2018),( 'cobra', 2019)],names=['kind', 'year'])>>>idx.rename(['species','year'])MultiIndex([('python', 2018),('python', 2019),( 'cobra', 2018),( 'cobra', 2019)],names=['species', 'year'])>>>idx.rename('species')Traceback (most recent call last):TypeError:Must pass list-like as `names`."
Pandas,Index objects,pandas.Index.repeat,"pandas.Index.repeat#Index.repeat(repeats,axis=None)[source]#Repeat elements of a Index.Returns a new Index where each element of the current Index
is repeated consecutively a given number of times.Parameters:repeatsint or array of intsThe number of repetitions for each element. This should be a
non-negative integer. Repeating 0 times will return an empty
Index.axisNoneMust beNone. Has no effect but is accepted for compatibility
with numpy.Returns:IndexNewly created Index with repeated elements.See alsoSeries.repeatEquivalent function for Series.numpy.repeatSimilar method fornumpy.ndarray.Examples>>>idx=pd.Index(['a','b','c'])>>>idxIndex(['a', 'b', 'c'], dtype='object')>>>idx.repeat(2)Index(['a', 'a', 'b', 'b', 'c', 'c'], dtype='object')>>>idx.repeat([1,2,3])Index(['a', 'b', 'b', 'c', 'c', 'c'], dtype='object')"
Pandas,Index objects,pandas.Index.where,"pandas.Index.where#finalIndex.where(cond,other=None)[source]#Replace values where the condition is False.The replacement is taken from other.Parameters:condbool array-like with the same length as selfCondition to select the values on.otherscalar, or array-like, default NoneReplacement if the condition is False.Returns:pandas.IndexA copy of self with values replaced from other
where the condition is False.See alsoSeries.whereSame method for Series.DataFrame.whereSame method for DataFrame.Examples>>>idx=pd.Index(['car','bike','train','tractor'])>>>idxIndex(['car', 'bike', 'train', 'tractor'], dtype='object')>>>idx.where(idx.isin(['car','train']),'other')Index(['car', 'other', 'train', 'other'], dtype='object')"
Pandas,Index objects,pandas.Index.take,"pandas.Index.take#Index.take(indices,axis=0,allow_fill=True,fill_value=None,**kwargs)[source]#Return a new Index of the values selected by the indices.For internal compatibility with numpy arrays.Parameters:indicesarray-likeIndices to be taken.axisint, optionalThe axis over which to select values, always 0.allow_fillbool, default Truefill_valuescalar, default NoneIf allow_fill=True and fill_value is not None, indices specified by
-1 are regarded as NA. If Index doesn’t hold NA, raise ValueError.Returns:IndexAn index formed of elements at the given indices. Will be the same
type as self, except for RangeIndex.See alsonumpy.ndarray.takeReturn an array formed from the elements of a at the given indices.Examples>>>idx=pd.Index(['a','b','c'])>>>idx.take([2,2,1,2])Index(['c', 'c', 'b', 'c'], dtype='object')"
Pandas,Index objects,pandas.Index.putmask,"pandas.Index.putmask#Index.putmask(mask,value)[source]#Return a new Index of the values set with the mask.Returns:IndexSee alsonumpy.ndarray.putmaskChanges elements of an array based on conditional and input values.Examples>>>idx1=pd.Index([1,2,3])>>>idx2=pd.Index([5,6,7])>>>idx1.putmask([True,False,False],idx2)Index([5, 2, 3], dtype='int64')"
Pandas,Index objects,pandas.Index.unique,"pandas.Index.unique#Index.unique(level=None)[source]#Return unique values in the index.Unique values are returned in order of appearance, this does NOT sort.Parameters:levelint or hashable, optionalOnly return values from specified level (for MultiIndex).
If int, gets the level by integer position, else by level name.Returns:IndexSee alsouniqueNumpy array of unique values in that column.Series.uniqueReturn unique values of Series object.Examples>>>idx=pd.Index([1,1,2,3,3])>>>idx.unique()Index([1, 2, 3], dtype='int64')"
Pandas,Index objects,pandas.Index.nunique,"pandas.Index.nunique#Index.nunique(dropna=True)[source]#Return number of unique elements in the object.Excludes NA values by default.Parameters:dropnabool, default TrueDon’t include NaN in the count.Returns:intSee alsoDataFrame.nuniqueMethod nunique for DataFrame.Series.countCount non-NA/null observations in the Series.Examples>>>s=pd.Series([1,3,5,7,7])>>>s0    11    32    53    74    7dtype: int64>>>s.nunique()4"
Pandas,Index objects,pandas.Index.value_counts,"pandas.Index.value_counts#Index.value_counts(normalize=False,sort=True,ascending=False,bins=None,dropna=True)[source]#Return a Series containing counts of unique values.The resulting object will be in descending order so that the
first element is the most frequently-occurring element.
Excludes NA values by default.Parameters:normalizebool, default FalseIf True then the object returned will contain the relative
frequencies of the unique values.sortbool, default TrueSort by frequencies when True. Preserve the order of the data when False.ascendingbool, default FalseSort in ascending order.binsint, optionalRather than count values, group them into half-open bins,
a convenience forpd.cut, only works with numeric data.dropnabool, default TrueDon’t include counts of NaN.Returns:SeriesSee alsoSeries.countNumber of non-NA elements in a Series.DataFrame.countNumber of non-NA elements in a DataFrame.DataFrame.value_countsEquivalent method on DataFrames.Examples>>>index=pd.Index([3,1,2,3,4,np.nan])>>>index.value_counts()3.0    21.0    12.0    14.0    1Name: count, dtype: int64Withnormalizeset toTrue, returns the relative frequency by
dividing all values by the sum of values.>>>s=pd.Series([3,1,2,3,4,np.nan])>>>s.value_counts(normalize=True)3.0    0.41.0    0.22.0    0.24.0    0.2Name: proportion, dtype: float64binsBins can be useful for going from a continuous variable to a
categorical variable; instead of counting unique
apparitions of values, divide the index in the specified
number of half-open bins.>>>s.value_counts(bins=3)(0.996, 2.0]    2(2.0, 3.0]      2(3.0, 4.0]      1Name: count, dtype: int64dropnaWithdropnaset toFalsewe can also see NaN index values.>>>s.value_counts(dropna=False)3.0    21.0    12.0    14.0    1NaN    1Name: count, dtype: int64"
Pandas,Index objects,pandas.Index.set_names,"pandas.Index.set_names#Index.set_names(names,*,level=None,inplace=False)[source]#Set Index or MultiIndex name.Able to set new names partially and by level.Parameters:nameslabel or list of label or dict-like for MultiIndexName(s) to set.Changed in version 1.3.0.levelint, label or list of int or label, optionalIf the index is a MultiIndex and names is not dict-like, level(s) to set
(None for all levels). Otherwise level must be None.Changed in version 1.3.0.inplacebool, default FalseModifies the object directly, instead of creating a new Index or
MultiIndex.Returns:Index or NoneThe same type as the caller or None ifinplace=True.See alsoIndex.renameAble to set new names without level.Examples>>>idx=pd.Index([1,2,3,4])>>>idxIndex([1, 2, 3, 4], dtype='int64')>>>idx.set_names('quarter')Index([1, 2, 3, 4], dtype='int64', name='quarter')>>>idx=pd.MultiIndex.from_product([['python','cobra'],...[2018,2019]])>>>idxMultiIndex([('python', 2018),('python', 2019),( 'cobra', 2018),( 'cobra', 2019)],)>>>idx=idx.set_names(['kind','year'])>>>idx.set_names('species',level=0)MultiIndex([('python', 2018),('python', 2019),( 'cobra', 2018),( 'cobra', 2019)],names=['species', 'year'])When renaming levels with a dict, levels can not be passed.>>>idx.set_names({'kind':'snake'})MultiIndex([('python', 2018),('python', 2019),( 'cobra', 2018),( 'cobra', 2019)],names=['snake', 'year'])"
Pandas,Index objects,pandas.Index.droplevel,"pandas.Index.droplevel#finalIndex.droplevel(level=0)[source]#Return index with requested level(s) removed.If resulting index has only 1 level left, the result will be
of Index type, not MultiIndex. The original index is not modified inplace.Parameters:levelint, str, or list-like, default 0If a string is given, must be the name of a level
If list-like, elements must be names or indexes of levels.Returns:Index or MultiIndexExamples>>>mi=pd.MultiIndex.from_arrays(...[[1,2],[3,4],[5,6]],names=['x','y','z'])>>>miMultiIndex([(1, 3, 5),(2, 4, 6)],names=['x', 'y', 'z'])>>>mi.droplevel()MultiIndex([(3, 5),(4, 6)],names=['y', 'z'])>>>mi.droplevel(2)MultiIndex([(1, 3),(2, 4)],names=['x', 'y'])>>>mi.droplevel('z')MultiIndex([(1, 3),(2, 4)],names=['x', 'y'])>>>mi.droplevel(['x','y'])Index([5, 6], dtype='int64', name='z')"
Pandas,Index objects,pandas.Index.fillna,"pandas.Index.fillna#Index.fillna(value=None,downcast=_NoDefault.no_default)[source]#Fill NA/NaN values with the specified value.Parameters:valuescalarScalar value to use to fill holes (e.g. 0).
This value cannot be a list-likes.downcastdict, default is NoneA dict of item->dtype of what to downcast if possible,
or the string ‘infer’ which will try to downcast to an appropriate
equal type (e.g. float64 to int64 if possible).Deprecated since version 2.1.0.Returns:IndexSee alsoDataFrame.fillnaFill NaN values of a DataFrame.Series.fillnaFill NaN Values of a Series.Examples>>>idx=pd.Index([np.nan,np.nan,3])>>>idx.fillna(0)Index([0.0, 0.0, 3.0], dtype='float64')"
Pandas,Index objects,pandas.Index.dropna,"pandas.Index.dropna#Index.dropna(how='any')[source]#Return Index without NA/NaN values.Parameters:how{‘any’, ‘all’}, default ‘any’If the Index is a MultiIndex, drop the value when any or all levels
are NaN.Returns:IndexExamples>>>idx=pd.Index([1,np.nan,3])>>>idx.dropna()Index([1.0, 3.0], dtype='float64')"
Pandas,Index objects,pandas.Index.isna,"pandas.Index.isna#finalIndex.isna()[source]#Detect missing values.Return a boolean same-sized object indicating if the values are NA.
NA values, such asNone,numpy.NaNorpd.NaT, get
mapped toTruevalues.
Everything else get mapped toFalsevalues. Characters such as
empty strings‘’ornumpy.infare not considered NA values.Returns:numpy.ndarray[bool]A boolean array of whether my values are NA.See alsoIndex.notnaBoolean inverse of isna.Index.dropnaOmit entries with missing values.isnaTop-level isna.Series.isnaDetect missing values in Series object.ExamplesShow which entries in a pandas.Index are NA. The result is an
array.>>>idx=pd.Index([5.2,6.0,np.nan])>>>idxIndex([5.2, 6.0, nan], dtype='float64')>>>idx.isna()array([False, False,  True])Empty strings are not considered NA values. None is considered an NA
value.>>>idx=pd.Index(['black','','red',None])>>>idxIndex(['black', '', 'red', None], dtype='object')>>>idx.isna()array([False, False, False,  True])For datetimes,NaT(Not a Time) is considered as an NA value.>>>idx=pd.DatetimeIndex([pd.Timestamp('1940-04-25'),...pd.Timestamp(''),None,pd.NaT])>>>idxDatetimeIndex(['1940-04-25', 'NaT', 'NaT', 'NaT'],dtype='datetime64[ns]', freq=None)>>>idx.isna()array([False,  True,  True,  True])"
Pandas,Index objects,pandas.Index.notna,"pandas.Index.notna#finalIndex.notna()[source]#Detect existing (non-missing) values.Return a boolean same-sized object indicating if the values are not NA.
Non-missing values get mapped toTrue. Characters such as empty
strings''ornumpy.infare not considered NA values.
NA values, such as None ornumpy.NaN, get mapped toFalsevalues.Returns:numpy.ndarray[bool]Boolean array to indicate which entries are not NA.See alsoIndex.notnullAlias of notna.Index.isnaInverse of notna.notnaTop-level notna.ExamplesShow which entries in an Index are not NA. The result is an
array.>>>idx=pd.Index([5.2,6.0,np.nan])>>>idxIndex([5.2, 6.0, nan], dtype='float64')>>>idx.notna()array([ True,  True, False])Empty strings are not considered NA values. None is considered a NA
value.>>>idx=pd.Index(['black','','red',None])>>>idxIndex(['black', '', 'red', None], dtype='object')>>>idx.notna()array([ True,  True,  True, False])"
Pandas,Index objects,pandas.Index.astype,"pandas.Index.astype#Index.astype(dtype,copy=True)[source]#Create an Index with values cast to dtypes.The class of a new Index is determined by dtype. When conversion is
impossible, a TypeError exception is raised.Parameters:dtypenumpy dtype or pandas typeNote that any signed integerdtypeis treated as'int64',
and any unsigned integerdtypeis treated as'uint64',
regardless of the size.copybool, default TrueBy default, astype always returns a newly allocated object.
If copy is set to False and internal requirements on dtype are
satisfied, the original data is used to create a new Index
or the original Index is returned.Returns:IndexIndex with values cast to specified dtype.Examples>>>idx=pd.Index([1,2,3])>>>idxIndex([1, 2, 3], dtype='int64')>>>idx.astype('float')Index([1.0, 2.0, 3.0], dtype='float64')"
Pandas,Index objects,pandas.Index.item,"pandas.Index.item#Index.item()[source]#Return the first element of the underlying data as a Python scalar.Returns:scalarThe first element of Series or Index.Raises:ValueErrorIf the data is not length = 1.Examples>>>s=pd.Series([1])>>>s.item()1For an index:>>>s=pd.Series([1],index=['a'])>>>s.index.item()'a'"
Pandas,Index objects,pandas.Index.map,"pandas.Index.map#Index.map(mapper,na_action=None)[source]#Map values using an input mapping or function.Parameters:mapperfunction, dict, or SeriesMapping correspondence.na_action{None, ‘ignore’}If ‘ignore’, propagate NA values, without passing them to the
mapping correspondence.Returns:Union[Index, MultiIndex]The output of the mapping function applied to the index.
If the function returns a tuple with more than one element
a MultiIndex will be returned.Examples>>>idx=pd.Index([1,2,3])>>>idx.map({1:'a',2:'b',3:'c'})Index(['a', 'b', 'c'], dtype='object')Usingmapwith a function:>>>idx=pd.Index([1,2,3])>>>idx.map('I am a{}'.format)Index(['I am a 1', 'I am a 2', 'I am a 3'], dtype='object')>>>idx=pd.Index(['a','b','c'])>>>idx.map(lambdax:x.upper())Index(['A', 'B', 'C'], dtype='object')"
Pandas,Index objects,pandas.Index.ravel,"pandas.Index.ravel#finalIndex.ravel(order='C')[source]#Return a view on self.Returns:IndexSee alsonumpy.ndarray.ravelReturn a flattened array.Examples>>>s=pd.Series([1,2,3],index=['a','b','c'])>>>s.index.ravel()Index(['a', 'b', 'c'], dtype='object')"
Pandas,Index objects,pandas.Index.to_list,"pandas.Index.to_list#Index.to_list()[source]#Return a list of the values.These are each a scalar type, which is a Python scalar
(for str, int, float) or a pandas scalar
(for Timestamp/Timedelta/Interval/Period)Returns:listSee alsonumpy.ndarray.tolistReturn the array as an a.ndim-levels deep nested list of Python scalars.ExamplesFor Series>>>s=pd.Series([1,2,3])>>>s.to_list()[1, 2, 3]For Index:>>>idx=pd.Index([1,2,3])>>>idxIndex([1, 2, 3], dtype='int64')>>>idx.to_list()[1, 2, 3]"
Pandas,Index objects,pandas.Index.to_series,"pandas.Index.to_series#finalIndex.to_series(index=None,name=None)[source]#Create a Series with both index and values equal to the index keys.Useful with map for returning an indexer based on an index.Parameters:indexIndex, optionalIndex of resulting Series. If None, defaults to original index.namestr, optionalName of resulting Series. If None, defaults to name of original
index.Returns:SeriesThe dtype will be based on the type of the Index values.See alsoIndex.to_frameConvert an Index to a DataFrame.Series.to_frameConvert Series to DataFrame.Examples>>>idx=pd.Index(['Ant','Bear','Cow'],name='animal')By default, the original index and original name is reused.>>>idx.to_series()animalAnt      AntBear    BearCow      CowName: animal, dtype: objectTo enforce a new index, specify new labels toindex:>>>idx.to_series(index=[0,1,2])0     Ant1    Bear2     CowName: animal, dtype: objectTo override the name of the resulting column, specifyname:>>>idx.to_series(name='zoo')animalAnt      AntBear    BearCow      CowName: zoo, dtype: object"
Pandas,Index objects,pandas.Index.to_frame,"pandas.Index.to_frame#Index.to_frame(index=True,name=_NoDefault.no_default)[source]#Create a DataFrame with a column containing the Index.Parameters:indexbool, default TrueSet the index of the returned DataFrame as the original Index.nameobject, defaults to index.nameThe passed name should substitute for the index name (if it has
one).Returns:DataFrameDataFrame containing the original Index data.See alsoIndex.to_seriesConvert an Index to a Series.Series.to_frameConvert Series to DataFrame.Examples>>>idx=pd.Index(['Ant','Bear','Cow'],name='animal')>>>idx.to_frame()animalanimalAnt       AntBear     BearCow       CowBy default, the original Index is reused. To enforce a new Index:>>>idx.to_frame(index=False)animal0   Ant1  Bear2   CowTo override the name of the resulting column, specifyname:>>>idx.to_frame(index=False,name='zoo')zoo0   Ant1  Bear2   Cow"
Pandas,Index objects,pandas.Index.view,pandas.Index.view#Index.view(cls=None)[source]#
Pandas,Index objects,pandas.Index.argsort,"pandas.Index.argsort#Index.argsort(*args,**kwargs)[source]#Return the integer indices that would sort the index.Parameters:*argsPassed tonumpy.ndarray.argsort.**kwargsPassed tonumpy.ndarray.argsort.Returns:np.ndarray[np.intp]Integer indices that would sort the index if used as
an indexer.See alsonumpy.argsortSimilar method for NumPy arrays.Index.sort_valuesReturn sorted copy of Index.Examples>>>idx=pd.Index(['b','a','d','c'])>>>idxIndex(['b', 'a', 'd', 'c'], dtype='object')>>>order=idx.argsort()>>>orderarray([1, 0, 3, 2])>>>idx[order]Index(['a', 'b', 'c', 'd'], dtype='object')"
Pandas,Index objects,pandas.Index.searchsorted,"pandas.Index.searchsorted#Index.searchsorted(value,side='left',sorter=None)[source]#Find indices where elements should be inserted to maintain order.Find the indices into a sorted Indexselfsuch that, if the
corresponding elements invaluewere inserted before the indices,
the order ofselfwould be preserved.NoteThe Indexmustbe monotonically sorted, otherwise
wrong locations will likely be returned. Pandas doesnotcheck this for you.Parameters:valuearray-like or scalarValues to insert intoself.side{‘left’, ‘right’}, optionalIf ‘left’, the index of the first suitable location found is given.
If ‘right’, return the last such index. If there is no suitable
index, return either 0 or N (where N is the length ofself).sorter1-D array-like, optionalOptional array of integer indices that sortselfinto ascending
order. They are typically the result ofnp.argsort.Returns:int or array of intA scalar or array of insertion points with the
same shape asvalue.See alsosort_valuesSort by the values along either axis.numpy.searchsortedSimilar method from NumPy.NotesBinary search is used to find the required insertion points.Examples>>>ser=pd.Series([1,2,3])>>>ser0    11    22    3dtype: int64>>>ser.searchsorted(4)3>>>ser.searchsorted([0,4])array([0, 3])>>>ser.searchsorted([1,3],side='left')array([0, 2])>>>ser.searchsorted([1,3],side='right')array([1, 3])>>>ser=pd.Series(pd.to_datetime(['3/11/2000','3/12/2000','3/13/2000']))>>>ser0   2000-03-111   2000-03-122   2000-03-13dtype: datetime64[ns]>>>ser.searchsorted('3/14/2000')3>>>ser=pd.Categorical(...['apple','bread','bread','cheese','milk'],ordered=True...)>>>ser['apple', 'bread', 'bread', 'cheese', 'milk']Categories (4, object): ['apple' < 'bread' < 'cheese' < 'milk']>>>ser.searchsorted('bread')1>>>ser.searchsorted(['bread'],side='right')array([3])If the values are not monotonically sorted, wrong locations
may be returned:>>>ser=pd.Series([2,1,3])>>>ser0    21    12    3dtype: int64>>>ser.searchsorted(1)0  # wrong result, correct would be 1"
Pandas,Index objects,pandas.Index.sort_values,"pandas.Index.sort_values#Index.sort_values(return_indexer=False,ascending=True,na_position='last',key=None)[source]#Return a sorted copy of the index.Return a sorted copy of the index, and optionally return the indices
that sorted the index itself.Parameters:return_indexerbool, default FalseShould the indices that would sort the index be returned.ascendingbool, default TrueShould the index values be sorted in an ascending order.na_position{‘first’ or ‘last’}, default ‘last’Argument ‘first’ puts NaNs at the beginning, ‘last’ puts NaNs at
the end.New in version 1.2.0.keycallable, optionalIf not None, apply the key function to the index values
before sorting. This is similar to thekeyargument in the
builtinsorted()function, with the notable difference that
thiskeyfunction should bevectorized. It should expect anIndexand return anIndexof the same shape.Returns:sorted_indexpandas.IndexSorted copy of the index.indexernumpy.ndarray, optionalThe indices that the index itself was sorted by.See alsoSeries.sort_valuesSort values of a Series.DataFrame.sort_valuesSort values in a DataFrame.Examples>>>idx=pd.Index([10,100,1,1000])>>>idxIndex([10, 100, 1, 1000], dtype='int64')Sort values in ascending order (default behavior).>>>idx.sort_values()Index([1, 10, 100, 1000], dtype='int64')Sort values in descending order, and also get the indicesidxwas
sorted by.>>>idx.sort_values(ascending=False,return_indexer=True)(Index([1000, 100, 10, 1], dtype='int64'), array([3, 1, 0, 2]))"
Pandas,Index objects,pandas.Index.shift,"pandas.Index.shift#Index.shift(periods=1,freq=None)[source]#Shift index by desired number of time frequency increments.This method is for shifting the values of datetime-like indexes
by a specified time increment a given number of times.Parameters:periodsint, default 1Number of periods (or increments) to shift by,
can be positive or negative.freqpandas.DateOffset, pandas.Timedelta or str, optionalFrequency increment to shift by.
If None, the index is shifted by its ownfreqattribute.
Offset aliases are valid strings, e.g., ‘D’, ‘W’, ‘M’ etc.Returns:pandas.IndexShifted index.See alsoSeries.shiftShift values of Series.NotesThis method is only implemented for datetime-like index classes,
i.e., DatetimeIndex, PeriodIndex and TimedeltaIndex.ExamplesPut the first 5 month starts of 2011 into an index.>>>month_starts=pd.date_range('1/1/2011',periods=5,freq='MS')>>>month_startsDatetimeIndex(['2011-01-01', '2011-02-01', '2011-03-01', '2011-04-01','2011-05-01'],dtype='datetime64[ns]', freq='MS')Shift the index by 10 days.>>>month_starts.shift(10,freq='D')DatetimeIndex(['2011-01-11', '2011-02-11', '2011-03-11', '2011-04-11','2011-05-11'],dtype='datetime64[ns]', freq=None)The default value offreqis thefreqattribute of the index,
which is ‘MS’ (month start) in this example.>>>month_starts.shift(10)DatetimeIndex(['2011-11-01', '2011-12-01', '2012-01-01', '2012-02-01','2012-03-01'],dtype='datetime64[ns]', freq='MS')"
Pandas,Index objects,pandas.Index.append,"pandas.Index.append#Index.append(other)[source]#Append a collection of Index options together.Parameters:otherIndex or list/tuple of indicesReturns:IndexExamples>>>idx=pd.Index([1,2,3])>>>idx.append(pd.Index([4]))Index([1, 2, 3, 4], dtype='int64')"
Pandas,Index objects,pandas.Index.join,"pandas.Index.join#finalIndex.join(other,*,how='left',level=None,return_indexers=False,sort=False)[source]#Compute join_index and indexers to conform data structures to the new index.Parameters:otherIndexhow{‘left’, ‘right’, ‘inner’, ‘outer’}levelint or level name, default Nonereturn_indexersbool, default Falsesortbool, default FalseSort the join keys lexicographically in the result Index. If False,
the order of the join keys depends on the join type (how keyword).Returns:join_index, (left_indexer, right_indexer)Examples>>>idx1=pd.Index([1,2,3])>>>idx2=pd.Index([4,5,6])>>>idx1.join(idx2,how='outer')Index([1, 2, 3, 4, 5, 6], dtype='int64')"
Pandas,Index objects,pandas.Index.intersection,"pandas.Index.intersection#finalIndex.intersection(other,sort=False)[source]#Form the intersection of two Index objects.This returns a new Index with elements common to the index andother.Parameters:otherIndex or array-likesortTrue, False or None, default FalseWhether to sort the resulting index.None : sort the result, except whenselfandotherare equal
or when the values cannot be compared.False : do not sort the result.True : Sort the result (which may raise TypeError).Returns:IndexExamples>>>idx1=pd.Index([1,2,3,4])>>>idx2=pd.Index([3,4,5,6])>>>idx1.intersection(idx2)Index([3, 4], dtype='int64')"
Pandas,Index objects,pandas.Index.union,"pandas.Index.union#finalIndex.union(other,sort=None)[source]#Form the union of two Index objects.If the Index objects are incompatible, both Index objects will be
cast to dtype(‘object’) first.Parameters:otherIndex or array-likesortbool or None, default NoneWhether to sort the resulting Index.None : Sort the result, except whenselfandotherare equal.selforotherhas length 0.Some values inselforothercannot be compared.
A RuntimeWarning is issued in this case.False : do not sort the result.True : Sort the result (which may raise TypeError).Returns:IndexExamplesUnion matching dtypes>>>idx1=pd.Index([1,2,3,4])>>>idx2=pd.Index([3,4,5,6])>>>idx1.union(idx2)Index([1, 2, 3, 4, 5, 6], dtype='int64')Union mismatched dtypes>>>idx1=pd.Index(['a','b','c','d'])>>>idx2=pd.Index([1,2,3,4])>>>idx1.union(idx2)Index(['a', 'b', 'c', 'd', 1, 2, 3, 4], dtype='object')MultiIndex case>>>idx1=pd.MultiIndex.from_arrays(...[[1,1,2,2],[""Red"",""Blue"",""Red"",""Blue""]]...)>>>idx1MultiIndex([(1,  'Red'),(1, 'Blue'),(2,  'Red'),(2, 'Blue')],)>>>idx2=pd.MultiIndex.from_arrays(...[[3,3,2,2],[""Red"",""Green"",""Red"",""Green""]]...)>>>idx2MultiIndex([(3,   'Red'),(3, 'Green'),(2,   'Red'),(2, 'Green')],)>>>idx1.union(idx2)MultiIndex([(1,  'Blue'),(1,   'Red'),(2,  'Blue'),(2, 'Green'),(2,   'Red'),(3, 'Green'),(3,   'Red')],)>>>idx1.union(idx2,sort=False)MultiIndex([(1,   'Red'),(1,  'Blue'),(2,   'Red'),(2,  'Blue'),(3,   'Red'),(3, 'Green'),(2, 'Green')],)"
Pandas,Index objects,pandas.Index.difference,"pandas.Index.difference#finalIndex.difference(other,sort=None)[source]#Return a new Index with elements of index not inother.This is the set difference of two Index objects.Parameters:otherIndex or array-likesortbool or None, default NoneWhether to sort the resulting index. By default, the
values are attempted to be sorted, but any TypeError from
incomparable elements is caught by pandas.None : Attempt to sort the result, but catch any TypeErrors
from comparing incomparable elements.False : Do not sort the result.True : Sort the result (which may raise TypeError).Returns:IndexExamples>>>idx1=pd.Index([2,1,3,4])>>>idx2=pd.Index([3,4,5,6])>>>idx1.difference(idx2)Index([1, 2], dtype='int64')>>>idx1.difference(idx2,sort=False)Index([2, 1], dtype='int64')"
Pandas,Index objects,pandas.Index.symmetric_difference,"pandas.Index.symmetric_difference#Index.symmetric_difference(other,result_name=None,sort=None)[source]#Compute the symmetric difference of two Index objects.Parameters:otherIndex or array-likeresult_namestrsortbool or None, default NoneWhether to sort the resulting index. By default, the
values are attempted to be sorted, but any TypeError from
incomparable elements is caught by pandas.None : Attempt to sort the result, but catch any TypeErrors
from comparing incomparable elements.False : Do not sort the result.True : Sort the result (which may raise TypeError).Returns:IndexNotessymmetric_differencecontains elements that appear in eitheridx1oridx2but not both. Equivalent to the Index created byidx1.difference(idx2)|idx2.difference(idx1)with duplicates
dropped.Examples>>>idx1=pd.Index([1,2,3,4])>>>idx2=pd.Index([2,3,4,5])>>>idx1.symmetric_difference(idx2)Index([1, 5], dtype='int64')"
Pandas,Index objects,pandas.Index.asof,"pandas.Index.asof#finalIndex.asof(label)[source]#Return the label from the index, or, if not present, the previous one.Assuming that the index is sorted, return the passed index label if it
is in the index, or return the previous index label if the passed one
is not in the index.Parameters:labelobjectThe label up to which the method returns the latest index label.Returns:objectThe passed label if it is in the index. The previous label if the
passed label is not in the sorted index orNaNif there is no
such label.See alsoSeries.asofReturn the latest value in a Series up to the passed index.merge_asofPerform an asof merge (similar to left join but it matches on nearest key rather than equal key).Index.get_locAnasofis a thin wrapper aroundget_locwith method=’pad’.ExamplesIndex.asofreturns the latest index label up to the passed label.>>>idx=pd.Index(['2013-12-31','2014-01-02','2014-01-03'])>>>idx.asof('2014-01-01')'2013-12-31'If the label is in the index, the method returns the passed label.>>>idx.asof('2014-01-02')'2014-01-02'If all of the labels in the index are later than the passed label,
NaN is returned.>>>idx.asof('1999-01-02')nanIf the index is not sorted, an error is raised.>>>idx_not_sorted=pd.Index(['2013-12-31','2015-01-02',...'2014-01-03'])>>>idx_not_sorted.asof('2013-12-31')Traceback (most recent call last):ValueError:index must be monotonic increasing or decreasing"
Pandas,Index objects,pandas.Index.asof_locs,"pandas.Index.asof_locs#Index.asof_locs(where,mask)[source]#Return the locations (indices) of labels in the index.As in thepandas.Index.asof(), if the label (a particular entry inwhere) is not in the index, the latest index label up to the
passed label is chosen and its index returned.If all of the labels in the index are later than a label inwhere,
-1 is returned.maskis used to ignoreNAvalues in the index during calculation.Parameters:whereIndexAn Index consisting of an array of timestamps.masknp.ndarray[bool]Array of booleans denoting where values in the original
data are notNA.Returns:np.ndarray[np.intp]An array of locations (indices) of the labels from the index
which correspond to the return values ofpandas.Index.asof()for every element inwhere.See alsoIndex.asofReturn the label from the index, or, if not present, the previous one.Examples>>>idx=pd.date_range('2023-06-01',periods=3,freq='D')>>>where=pd.DatetimeIndex(['2023-05-30 00:12:00','2023-06-01 00:00:00',...'2023-06-02 23:59:59'])>>>mask=np.ones(3,dtype=bool)>>>idx.asof_locs(where,mask)array([-1,  0,  1])We can usemaskto ignore certain values in the index during calculation.>>>mask[1]=False>>>idx.asof_locs(where,mask)array([-1,  0,  0])"
Pandas,Index objects,pandas.Index.get_indexer,"pandas.Index.get_indexer#finalIndex.get_indexer(target,method=None,limit=None,tolerance=None)[source]#Compute indexer and mask for new index given the current index.The indexer should be then used as an input to ndarray.take to align the
current data to the new index.Parameters:targetIndexmethod{None, ‘pad’/’ffill’, ‘backfill’/’bfill’, ‘nearest’}, optionaldefault: exact matches only.pad / ffill: find the PREVIOUS index value if no exact match.backfill / bfill: use NEXT index value if no exact matchnearest: use the NEAREST index value if no exact match. Tied
distances are broken by preferring the larger index value.limitint, optionalMaximum number of consecutive labels intargetto match for
inexact matches.toleranceoptionalMaximum distance between original and new labels for inexact
matches. The values of the index at the matching locations must
satisfy the equationabs(index[indexer]-target)<=tolerance.Tolerance may be a scalar value, which applies the same tolerance
to all values, or list-like, which applies variable tolerance per
element. List-like includes list, tuple, array, Series, and must be
the same size as the index and its dtype must exactly match the
index’s type.Returns:np.ndarray[np.intp]Integers from 0 to n - 1 indicating that the index at these
positions matches the corresponding target values. Missing values
in the target are marked by -1.NotesReturns -1 for unmatched values, for further explanation see the
example below.Examples>>>index=pd.Index(['c','a','b'])>>>index.get_indexer(['a','b','x'])array([ 1,  2, -1])Notice that the return value is an array of locations inindexandxis marked by -1, as it is not inindex."
Pandas,Index objects,pandas.Index.get_indexer_for,"pandas.Index.get_indexer_for#finalIndex.get_indexer_for(target)[source]#Guaranteed return of an indexer even when non-unique.This dispatches to get_indexer or get_indexer_non_unique
as appropriate.Returns:np.ndarray[np.intp]List of indices.Examples>>>idx=pd.Index([np.nan,'var1',np.nan])>>>idx.get_indexer_for([np.nan])array([0, 2])"
Pandas,Index objects,pandas.Index.get_indexer_non_unique,"pandas.Index.get_indexer_non_unique#Index.get_indexer_non_unique(target)[source]#Compute indexer and mask for new index given the current index.The indexer should be then used as an input to ndarray.take to align the
current data to the new index.Parameters:targetIndexReturns:indexernp.ndarray[np.intp]Integers from 0 to n - 1 indicating that the index at these
positions matches the corresponding target values. Missing values
in the target are marked by -1.missingnp.ndarray[np.intp]An indexer into the target of the values not found.
These correspond to the -1 in the indexer array.Examples>>>index=pd.Index(['c','b','a','b','b'])>>>index.get_indexer_non_unique(['b','b'])(array([1, 3, 4, 1, 3, 4]), array([], dtype=int64))In the example below there are no matched values.>>>index=pd.Index(['c','b','a','b','b'])>>>index.get_indexer_non_unique(['q','r','t'])(array([-1, -1, -1]), array([0, 1, 2]))For this reason, the returnedindexercontains only integers equal to -1.
It demonstrates that there’s no match between the index and thetargetvalues at these positions. The mask [0, 1, 2] in the return value shows that
the first, second, and third elements are missing.Notice that the return value is a tuple contains two items. In the example
below the first item is an array of locations inindex. The second
item is a mask shows that the first and third elements are missing.>>>index=pd.Index(['c','b','a','b','b'])>>>index.get_indexer_non_unique(['f','b','s'])(array([-1,  1,  3,  4, -1]), array([0, 2]))"
Pandas,Index objects,pandas.Index.get_level_values,"pandas.Index.get_level_values#Index.get_level_values(level)[source]#Return an Index of values for requested level.This is primarily useful to get an individual level of values from a
MultiIndex, but is provided on Index as well for compatibility.Parameters:levelint or strIt is either the integer position or the name of the level.Returns:IndexCalling object, as there is only one level in the Index.See alsoMultiIndex.get_level_valuesGet values for a level of a MultiIndex.NotesFor Index, level should be 0, since there are no multiple levels.Examples>>>idx=pd.Index(list('abc'))>>>idxIndex(['a', 'b', 'c'], dtype='object')Get level values by supplyinglevelas integer:>>>idx.get_level_values(0)Index(['a', 'b', 'c'], dtype='object')"
Pandas,Index objects,pandas.Index.get_loc,"pandas.Index.get_loc#Index.get_loc(key)[source]#Get integer location, slice or boolean mask for requested label.Parameters:keylabelReturns:int if unique index, slice if monotonic index, else maskExamples>>>unique_index=pd.Index(list('abc'))>>>unique_index.get_loc('b')1>>>monotonic_index=pd.Index(list('abbc'))>>>monotonic_index.get_loc('b')slice(1, 3, None)>>>non_monotonic_index=pd.Index(list('abcb'))>>>non_monotonic_index.get_loc('b')array([False,  True, False,  True])"
Pandas,Index objects,pandas.Index.get_slice_bound,"pandas.Index.get_slice_bound#Index.get_slice_bound(label,side)[source]#Calculate slice bound that corresponds to given label.Returns leftmost (one-past-the-rightmost ifside=='right') position
of given label.Parameters:labelobjectside{‘left’, ‘right’}Returns:intIndex of label.See alsoIndex.get_locGet integer location, slice or boolean mask for requested label.Examples>>>idx=pd.RangeIndex(5)>>>idx.get_slice_bound(3,'left')3>>>idx.get_slice_bound(3,'right')4Iflabelis non-unique in the index, an error will be raised.>>>idx_duplicate=pd.Index(['a','b','a','c','d'])>>>idx_duplicate.get_slice_bound('a','left')Traceback (most recent call last):KeyError:Cannot get left slice bound for non-unique label: 'a'"
Pandas,Index objects,pandas.Index.isin,"pandas.Index.isin#Index.isin(values,level=None)[source]#Return a boolean array where the index values are invalues.Compute boolean array of whether each index value is found in the
passed set of values. The length of the returned boolean array matches
the length of the index.Parameters:valuesset or list-likeSought values.levelstr or int, optionalName or position of the index level to use (if the index is aMultiIndex).Returns:np.ndarray[bool]NumPy array of boolean values.See alsoSeries.isinSame for Series.DataFrame.isinSame method for DataFrames.NotesIn the case ofMultiIndexyou must either specifyvaluesas a
list-like object containing tuples that are the same length as the
number of levels, or specifylevel. Otherwise it will raise aValueError.Iflevelis specified:if it is the name of oneand only oneindex level, use that level;otherwise it should be a number indicating level position.Examples>>>idx=pd.Index([1,2,3])>>>idxIndex([1, 2, 3], dtype='int64')Check whether each index value in a list of values.>>>idx.isin([1,4])array([ True, False, False])>>>midx=pd.MultiIndex.from_arrays([[1,2,3],...['red','blue','green']],...names=('number','color'))>>>midxMultiIndex([(1,   'red'),(2,  'blue'),(3, 'green')],names=['number', 'color'])Check whether the strings in the ‘color’ level of the MultiIndex
are in a list of colors.>>>midx.isin(['red','orange','yellow'],level='color')array([ True, False, False])To check across the levels of a MultiIndex, pass a list of tuples:>>>midx.isin([(1,'red'),(3,'red')])array([ True, False, False])For a DatetimeIndex, string values invaluesare converted to
Timestamps.>>>dates=['2000-03-11','2000-03-12','2000-03-13']>>>dti=pd.to_datetime(dates)>>>dtiDatetimeIndex(['2000-03-11', '2000-03-12', '2000-03-13'],dtype='datetime64[ns]', freq=None)>>>dti.isin(['2000-03-11'])array([ True, False, False])"
Pandas,Index objects,pandas.Index.slice_indexer,"pandas.Index.slice_indexer#Index.slice_indexer(start=None,end=None,step=None)[source]#Compute the slice indexer for input labels and step.Index needs to be ordered and unique.Parameters:startlabel, default NoneIf None, defaults to the beginning.endlabel, default NoneIf None, defaults to the end.stepint, default NoneReturns:sliceRaises:KeyErrorIf key does not exist, or key is not unique and index isnot ordered.NotesThis function assumes that the data is sorted, so use at your own perilExamplesThis is a method on all index types. For example you can do:>>>idx=pd.Index(list('abcd'))>>>idx.slice_indexer(start='b',end='c')slice(1, 3, None)>>>idx=pd.MultiIndex.from_arrays([list('abcd'),list('efgh')])>>>idx.slice_indexer(start='b',end=('c','g'))slice(1, 3, None)"
Pandas,Index objects,pandas.Index.slice_locs,"pandas.Index.slice_locs#Index.slice_locs(start=None,end=None,step=None)[source]#Compute slice locations for input labels.Parameters:startlabel, default NoneIf None, defaults to the beginning.endlabel, default NoneIf None, defaults to the end.stepint, defaults NoneIf None, defaults to 1.Returns:tuple[int, int]See alsoIndex.get_locGet location for a single label.NotesThis method only works if the index is monotonic or unique.Examples>>>idx=pd.Index(list('abcd'))>>>idx.slice_locs(start='b',end='c')(1, 3)"
Pandas,Index objects,pandas.RangeIndex,"pandas.RangeIndex#classpandas.RangeIndex(start=None,stop=None,step=None,dtype=None,copy=False,name=None)[source]#Immutable Index implementing a monotonic integer range.RangeIndex is a memory-saving special case of an Index limited to representing
monotonic ranges with a 64-bit dtype. Using RangeIndex may in some instances
improve computing speed.This is the default index type used
by DataFrame and Series when no explicit index is provided by the user.Parameters:startint (default: 0), range, or other RangeIndex instanceIf int and “stop” is not given, interpreted as “stop” instead.stopint (default: 0)stepint (default: 1)dtypenp.int64Unused, accepted for homogeneity with other index types.copybool, default FalseUnused, accepted for homogeneity with other index types.nameobject, optionalName to be stored in the index.See alsoIndexThe base pandas Index type.Examples>>>list(pd.RangeIndex(5))[0, 1, 2, 3, 4]>>>list(pd.RangeIndex(-2,4))[-2, -1, 0, 1, 2, 3]>>>list(pd.RangeIndex(0,10,2))[0, 2, 4, 6, 8]>>>list(pd.RangeIndex(2,-10,-3))[2, -1, -4, -7]>>>list(pd.RangeIndex(0))[]>>>list(pd.RangeIndex(1,0))[]AttributesstartThe value of thestartparameter (0if this was not supplied).stopThe value of thestopparameter.stepThe value of thestepparameter (1if this was not supplied).Methodsfrom_range(data[, name, dtype])Createpandas.RangeIndexfrom arangeobject."
Pandas,Index objects,pandas.RangeIndex.start,"pandas.RangeIndex.start#propertyRangeIndex.start[source]#The value of thestartparameter (0if this was not supplied).Examples>>>idx=pd.RangeIndex(5)>>>idx.start0>>>idx=pd.RangeIndex(2,-10,-3)>>>idx.start2"
Pandas,Index objects,pandas.RangeIndex.stop,"pandas.RangeIndex.stop#propertyRangeIndex.stop[source]#The value of thestopparameter.Examples>>>idx=pd.RangeIndex(5)>>>idx.stop5>>>idx=pd.RangeIndex(2,-10,-3)>>>idx.stop-10"
Pandas,Index objects,pandas.RangeIndex.step,"pandas.RangeIndex.step#propertyRangeIndex.step[source]#The value of thestepparameter (1if this was not supplied).Examples>>>idx=pd.RangeIndex(5)>>>idx.step1>>>idx=pd.RangeIndex(2,-10,-3)>>>idx.step-3Even ifpandas.RangeIndexis empty,stepis still1if
not supplied.>>>idx=pd.RangeIndex(1,0)>>>idx.step1"
Pandas,Index objects,pandas.RangeIndex.from_range,"pandas.RangeIndex.from_range#classmethodRangeIndex.from_range(data,name=None,dtype=None)[source]#Createpandas.RangeIndexfrom arangeobject.Returns:RangeIndexExamples>>>pd.RangeIndex.from_range(range(5))RangeIndex(start=0, stop=5, step=1)>>>pd.RangeIndex.from_range(range(2,-10,-3))RangeIndex(start=2, stop=-10, step=-3)"
Pandas,Index objects,pandas.CategoricalIndex,"pandas.CategoricalIndex#classpandas.CategoricalIndex(data=None,categories=None,ordered=None,dtype=None,copy=False,name=None)[source]#Index based on an underlyingCategorical.CategoricalIndex, like Categorical, can only take on a limited,
and usually fixed, number of possible values (categories). Also,
like Categorical, it might have an order, but numerical operations
(additions, divisions, …) are not possible.Parameters:dataarray-like (1-dimensional)The values of the categorical. Ifcategoriesare given, values not incategorieswill be replaced with NaN.categoriesindex-like, optionalThe categories for the categorical. Items need to be unique.
If the categories are not given here (and also not indtype), they
will be inferred from thedata.orderedbool, optionalWhether or not this categorical is treated as an ordered
categorical. If not given here or indtype, the resulting
categorical will be unordered.dtypeCategoricalDtype or “category”, optionalIfCategoricalDtype, cannot be used together withcategoriesorordered.copybool, default FalseMake a copy of input ndarray.nameobject, optionalName to be stored in the index.Raises:ValueErrorIf the categories do not validate.TypeErrorIf an explicitordered=Trueis given but nocategoriesand thevaluesare not sortable.See alsoIndexThe base pandas Index type.CategoricalA categorical array.CategoricalDtypeType for categorical data.NotesSee theuser guidefor more.Examples>>>pd.CategoricalIndex([""a"",""b"",""c"",""a"",""b"",""c""])CategoricalIndex(['a', 'b', 'c', 'a', 'b', 'c'],categories=['a', 'b', 'c'], ordered=False, dtype='category')CategoricalIndexcan also be instantiated from aCategorical:>>>c=pd.Categorical([""a"",""b"",""c"",""a"",""b"",""c""])>>>pd.CategoricalIndex(c)CategoricalIndex(['a', 'b', 'c', 'a', 'b', 'c'],categories=['a', 'b', 'c'], ordered=False, dtype='category')OrderedCategoricalIndexcan have a min and max value.>>>ci=pd.CategoricalIndex(...[""a"",""b"",""c"",""a"",""b"",""c""],ordered=True,categories=[""c"",""b"",""a""]...)>>>ciCategoricalIndex(['a', 'b', 'c', 'a', 'b', 'c'],categories=['c', 'b', 'a'], ordered=True, dtype='category')>>>ci.min()'c'AttributescodesThe category codes of this categorical index.categoriesThe categories of this categorical.orderedWhether the categories have an ordered relationship.Methodsrename_categories(*args, **kwargs)Rename categories.reorder_categories(*args, **kwargs)Reorder categories as specified in new_categories.add_categories(*args, **kwargs)Add new categories.remove_categories(*args, **kwargs)Remove the specified categories.remove_unused_categories(*args, **kwargs)Remove categories which are not used.set_categories(*args, **kwargs)Set the categories to the specified new categories.as_ordered(*args, **kwargs)Set the Categorical to be ordered.as_unordered(*args, **kwargs)Set the Categorical to be unordered.map(mapper[, na_action])Map values using input an input mapping or function."
Pandas,Index objects,pandas.CategoricalIndex.codes,"pandas.CategoricalIndex.codes#propertyCategoricalIndex.codes[source]#The category codes of this categorical index.Codes are an array of integers which are the positions of the actual
values in the categories array.There is no setter, use the other categorical methods and the normal item
setter to change values in the categorical.Returns:ndarray[int]A non-writable view of thecodesarray.ExamplesForpandas.Categorical:>>>cat=pd.Categorical(['a','b'],ordered=True)>>>cat.codesarray([0, 1], dtype=int8)Forpandas.CategoricalIndex:>>>ci=pd.CategoricalIndex(['a','b','c','a','b','c'])>>>ci.codesarray([0, 1, 2, 0, 1, 2], dtype=int8)>>>ci=pd.CategoricalIndex(['a','c'],categories=['c','b','a'])>>>ci.codesarray([2, 0], dtype=int8)"
Pandas,Index objects,pandas.CategoricalIndex.categories,"pandas.CategoricalIndex.categories#propertyCategoricalIndex.categories[source]#The categories of this categorical.Setting assigns new values to each category (effectively a rename of
each individual category).The assigned value has to be a list-like object. All items must be
unique and the number of items in the new categories must be the same
as the number of items in the old categories.Raises:ValueErrorIf the new categories do not validate as categories or if the
number of new categories is unequal the number of old categoriesSee alsorename_categoriesRename categories.reorder_categoriesReorder categories.add_categoriesAdd new categories.remove_categoriesRemove the specified categories.remove_unused_categoriesRemove categories which are not used.set_categoriesSet the categories to the specified ones.ExamplesForpandas.Series:>>>ser=pd.Series(['a','b','c','a'],dtype='category')>>>ser.cat.categoriesIndex(['a', 'b', 'c'], dtype='object')>>>raw_cat=pd.Categorical(['a','b','c','a'],categories=['b','c','d'])>>>ser=pd.Series(raw_cat)>>>ser.cat.categoriesIndex(['b', 'c', 'd'], dtype='object')Forpandas.Categorical:>>>cat=pd.Categorical(['a','b'],ordered=True)>>>cat.categoriesIndex(['a', 'b'], dtype='object')Forpandas.CategoricalIndex:>>>ci=pd.CategoricalIndex(['a','c','b','a','c','b'])>>>ci.categoriesIndex(['a', 'b', 'c'], dtype='object')>>>ci=pd.CategoricalIndex(['a','c'],categories=['c','b','a'])>>>ci.categoriesIndex(['c', 'b', 'a'], dtype='object')"
Pandas,Index objects,pandas.CategoricalIndex.ordered,"pandas.CategoricalIndex.ordered#propertyCategoricalIndex.ordered[source]#Whether the categories have an ordered relationship.ExamplesForpandas.Series:>>>ser=pd.Series(['a','b','c','a'],dtype='category')>>>ser.cat.orderedFalse>>>raw_cat=pd.Categorical(['a','b','c','a'],ordered=True)>>>ser=pd.Series(raw_cat)>>>ser.cat.orderedTrueForpandas.Categorical:>>>cat=pd.Categorical(['a','b'],ordered=True)>>>cat.orderedTrue>>>cat=pd.Categorical(['a','b'],ordered=False)>>>cat.orderedFalseForpandas.CategoricalIndex:>>>ci=pd.CategoricalIndex(['a','b'],ordered=True)>>>ci.orderedTrue>>>ci=pd.CategoricalIndex(['a','b'],ordered=False)>>>ci.orderedFalse"
Pandas,Index objects,pandas.CategoricalIndex.rename_categories,"pandas.CategoricalIndex.rename_categories#CategoricalIndex.rename_categories(*args,**kwargs)[source]#Rename categories.Parameters:new_categorieslist-like, dict-like or callableNew categories which will replace old categories.list-like: all items must be unique and the number of items in
the new categories must match the existing number of categories.dict-like: specifies a mapping from
old categories to new. Categories not contained in the mapping
are passed through and extra categories in the mapping are
ignored.callable : a callable that is called on all items in the old
categories and whose return values comprise the new categories.Returns:CategoricalCategorical with renamed categories.Raises:ValueErrorIf new categories are list-like and do not have the same number of
items than the current categories or do not validate as categoriesSee alsoreorder_categoriesReorder categories.add_categoriesAdd new categories.remove_categoriesRemove the specified categories.remove_unused_categoriesRemove categories which are not used.set_categoriesSet the categories to the specified ones.Examples>>>c=pd.Categorical(['a','a','b'])>>>c.rename_categories([0,1])[0, 0, 1]Categories (2, int64): [0, 1]For dict-likenew_categories, extra keys are ignored and
categories not in the dictionary are passed through>>>c.rename_categories({'a':'A','c':'C'})['A', 'A', 'b']Categories (2, object): ['A', 'b']You may also provide a callable to create the new categories>>>c.rename_categories(lambdax:x.upper())['A', 'A', 'B']Categories (2, object): ['A', 'B']"
Pandas,Index objects,pandas.CategoricalIndex.reorder_categories,"pandas.CategoricalIndex.reorder_categories#CategoricalIndex.reorder_categories(*args,**kwargs)[source]#Reorder categories as specified in new_categories.new_categoriesneed to include all old categories and no new category
items.Parameters:new_categoriesIndex-likeThe categories in new order.orderedbool, optionalWhether or not the categorical is treated as a ordered categorical.
If not given, do not change the ordered information.Returns:CategoricalCategorical with reordered categories.Raises:ValueErrorIf the new categories do not contain all old category items or any
new onesSee alsorename_categoriesRename categories.add_categoriesAdd new categories.remove_categoriesRemove the specified categories.remove_unused_categoriesRemove categories which are not used.set_categoriesSet the categories to the specified ones.ExamplesForpandas.Series:>>>ser=pd.Series(['a','b','c','a'],dtype='category')>>>ser=ser.cat.reorder_categories(['c','b','a'],ordered=True)>>>ser0   a1   b2   c3   adtype: categoryCategories (3, object): ['c' < 'b' < 'a']>>>ser.sort_values()2   c1   b0   a3   adtype: categoryCategories (3, object): ['c' < 'b' < 'a']Forpandas.CategoricalIndex:>>>ci=pd.CategoricalIndex(['a','b','c','a'])>>>ciCategoricalIndex(['a', 'b', 'c', 'a'], categories=['a', 'b', 'c'],ordered=False, dtype='category')>>>ci.reorder_categories(['c','b','a'],ordered=True)CategoricalIndex(['a', 'b', 'c', 'a'], categories=['c', 'b', 'a'],ordered=True, dtype='category')"
Pandas,Index objects,pandas.CategoricalIndex.add_categories,"pandas.CategoricalIndex.add_categories#CategoricalIndex.add_categories(*args,**kwargs)[source]#Add new categories.new_categorieswill be included at the last/highest place in the
categories and will be unused directly after this call.Parameters:new_categoriescategory or list-like of categoryThe new categories to be included.Returns:CategoricalCategorical with new categories added.Raises:ValueErrorIf the new categories include old categories or do not validate as
categoriesSee alsorename_categoriesRename categories.reorder_categoriesReorder categories.remove_categoriesRemove the specified categories.remove_unused_categoriesRemove categories which are not used.set_categoriesSet the categories to the specified ones.Examples>>>c=pd.Categorical(['c','b','c'])>>>c['c', 'b', 'c']Categories (2, object): ['b', 'c']>>>c.add_categories(['d','a'])['c', 'b', 'c']Categories (4, object): ['b', 'c', 'd', 'a']"
Pandas,Index objects,pandas.CategoricalIndex.remove_categories,"pandas.CategoricalIndex.remove_categories#CategoricalIndex.remove_categories(*args,**kwargs)[source]#Remove the specified categories.removalsmust be included in the old categories. Values which were in
the removed categories will be set to NaNParameters:removalscategory or list of categoriesThe categories which should be removed.Returns:CategoricalCategorical with removed categories.Raises:ValueErrorIf the removals are not contained in the categoriesSee alsorename_categoriesRename categories.reorder_categoriesReorder categories.add_categoriesAdd new categories.remove_unused_categoriesRemove categories which are not used.set_categoriesSet the categories to the specified ones.Examples>>>c=pd.Categorical(['a','c','b','c','d'])>>>c['a', 'c', 'b', 'c', 'd']Categories (4, object): ['a', 'b', 'c', 'd']>>>c.remove_categories(['d','a'])[NaN, 'c', 'b', 'c', NaN]Categories (2, object): ['b', 'c']"
Pandas,Index objects,pandas.CategoricalIndex.remove_unused_categories,"pandas.CategoricalIndex.remove_unused_categories#CategoricalIndex.remove_unused_categories(*args,**kwargs)[source]#Remove categories which are not used.Returns:CategoricalCategorical with unused categories dropped.See alsorename_categoriesRename categories.reorder_categoriesReorder categories.add_categoriesAdd new categories.remove_categoriesRemove the specified categories.set_categoriesSet the categories to the specified ones.Examples>>>c=pd.Categorical(['a','c','b','c','d'])>>>c['a', 'c', 'b', 'c', 'd']Categories (4, object): ['a', 'b', 'c', 'd']>>>c[2]='a'>>>c[4]='c'>>>c['a', 'c', 'a', 'c', 'c']Categories (4, object): ['a', 'b', 'c', 'd']>>>c.remove_unused_categories()['a', 'c', 'a', 'c', 'c']Categories (2, object): ['a', 'c']"
Pandas,Index objects,pandas.CategoricalIndex.set_categories,"pandas.CategoricalIndex.set_categories#CategoricalIndex.set_categories(*args,**kwargs)[source]#Set the categories to the specified new categories.new_categoriescan include new categories (which will result in
unused categories) or remove old categories (which results in values
set toNaN). Ifrename=True, the categories will simply be renamed
(less or more items than in old categories will result in values set toNaNor in unused categories respectively).This method can be used to perform more than one action of adding,
removing, and reordering simultaneously and is therefore faster than
performing the individual steps via the more specialised methods.On the other hand this methods does not do checks (e.g., whether the
old categories are included in the new categories on a reorder), which
can result in surprising changes, for example when using special string
dtypes, which does not considers a S1 string equal to a single char
python string.Parameters:new_categoriesIndex-likeThe categories in new order.orderedbool, default FalseWhether or not the categorical is treated as a ordered categorical.
If not given, do not change the ordered information.renamebool, default FalseWhether or not the new_categories should be considered as a rename
of the old categories or as reordered categories.Returns:Categorical with reordered categories.Raises:ValueErrorIf new_categories does not validate as categoriesSee alsorename_categoriesRename categories.reorder_categoriesReorder categories.add_categoriesAdd new categories.remove_categoriesRemove the specified categories.remove_unused_categoriesRemove categories which are not used.ExamplesForpandas.Series:>>>raw_cat=pd.Categorical(['a','b','c','A'],...categories=['a','b','c'],ordered=True)>>>ser=pd.Series(raw_cat)>>>ser0   a1   b2   c3   NaNdtype: categoryCategories (3, object): ['a' < 'b' < 'c']>>>ser.cat.set_categories(['A','B','C'],rename=True)0   A1   B2   C3   NaNdtype: categoryCategories (3, object): ['A' < 'B' < 'C']Forpandas.CategoricalIndex:>>>ci=pd.CategoricalIndex(['a','b','c','A'],...categories=['a','b','c'],ordered=True)>>>ciCategoricalIndex(['a', 'b', 'c', nan], categories=['a', 'b', 'c'],ordered=True, dtype='category')>>>ci.set_categories(['A','b','c'])CategoricalIndex([nan, 'b', 'c', nan], categories=['A', 'b', 'c'],ordered=True, dtype='category')>>>ci.set_categories(['A','b','c'],rename=True)CategoricalIndex(['A', 'b', 'c', nan], categories=['A', 'b', 'c'],ordered=True, dtype='category')"
Pandas,Index objects,pandas.CategoricalIndex.as_ordered,"pandas.CategoricalIndex.as_ordered#CategoricalIndex.as_ordered(*args,**kwargs)[source]#Set the Categorical to be ordered.Returns:CategoricalOrdered Categorical.ExamplesForpandas.Series:>>>ser=pd.Series(['a','b','c','a'],dtype='category')>>>ser.cat.orderedFalse>>>ser=ser.cat.as_ordered()>>>ser.cat.orderedTrueForpandas.CategoricalIndex:>>>ci=pd.CategoricalIndex(['a','b','c','a'])>>>ci.orderedFalse>>>ci=ci.as_ordered()>>>ci.orderedTrue"
Pandas,Index objects,pandas.CategoricalIndex.as_unordered,"pandas.CategoricalIndex.as_unordered#CategoricalIndex.as_unordered(*args,**kwargs)[source]#Set the Categorical to be unordered.Returns:CategoricalUnordered Categorical.ExamplesForpandas.Series:>>>raw_cat=pd.Categorical(['a','b','c','a'],ordered=True)>>>ser=pd.Series(raw_cat)>>>ser.cat.orderedTrue>>>ser=ser.cat.as_unordered()>>>ser.cat.orderedFalseForpandas.CategoricalIndex:>>>ci=pd.CategoricalIndex(['a','b','c','a'],ordered=True)>>>ci.orderedTrue>>>ci=ci.as_unordered()>>>ci.orderedFalse"
Pandas,Index objects,pandas.CategoricalIndex.map,"pandas.CategoricalIndex.map#CategoricalIndex.map(mapper,na_action=None)[source]#Map values using input an input mapping or function.Maps the values (their categories, not the codes) of the index to new
categories. If the mapping correspondence is one-to-one the result is aCategoricalIndexwhich has the same order property as
the original, otherwise anIndexis returned.If adictorSeriesis used any unmapped category is
mapped toNaN. Note that if this happens anIndexwill be returned.Parameters:mapperfunction, dict, or SeriesMapping correspondence.Returns:pandas.CategoricalIndex or pandas.IndexMapped index.See alsoIndex.mapApply a mapping correspondence on anIndex.Series.mapApply a mapping correspondence on aSeries.Series.applyApply more complex functions on aSeries.Examples>>>idx=pd.CategoricalIndex(['a','b','c'])>>>idxCategoricalIndex(['a', 'b', 'c'], categories=['a', 'b', 'c'],ordered=False, dtype='category')>>>idx.map(lambdax:x.upper())CategoricalIndex(['A', 'B', 'C'], categories=['A', 'B', 'C'],ordered=False, dtype='category')>>>idx.map({'a':'first','b':'second','c':'third'})CategoricalIndex(['first', 'second', 'third'], categories=['first','second', 'third'], ordered=False, dtype='category')If the mapping is one-to-one the ordering of the categories is
preserved:>>>idx=pd.CategoricalIndex(['a','b','c'],ordered=True)>>>idxCategoricalIndex(['a', 'b', 'c'], categories=['a', 'b', 'c'],ordered=True, dtype='category')>>>idx.map({'a':3,'b':2,'c':1})CategoricalIndex([3, 2, 1], categories=[3, 2, 1], ordered=True,dtype='category')If the mapping is not one-to-one anIndexis returned:>>>idx.map({'a':'first','b':'second','c':'first'})Index(['first', 'second', 'first'], dtype='object')If adictis used, all unmapped categories are mapped toNaNand
the result is anIndex:>>>idx.map({'a':'first','b':'second'})Index(['first', 'second', nan], dtype='object')"
Pandas,Index objects,pandas.CategoricalIndex.equals,"pandas.CategoricalIndex.equals#CategoricalIndex.equals(other)[source]#Determine if two CategoricalIndex objects contain the same elements.Returns:boolTrueif twopandas.CategoricalIndexobjects have equal
elements,Falseotherwise.Examples>>>ci=pd.CategoricalIndex(['a','b','c','a','b','c'])>>>ci2=pd.CategoricalIndex(pd.Categorical(['a','b','c','a','b','c']))>>>ci.equals(ci2)TrueThe order of elements matters.>>>ci3=pd.CategoricalIndex(['c','b','a','a','b','c'])>>>ci.equals(ci3)FalseThe orderedness also matters.>>>ci4=ci.as_ordered()>>>ci.equals(ci4)FalseThe categories matter, but the order of the categories matters only whenordered=True.>>>ci5=ci.set_categories(['a','b','c','d'])>>>ci.equals(ci5)False>>>ci6=ci.set_categories(['b','c','a'])>>>ci.equals(ci6)True>>>ci_ordered=pd.CategoricalIndex(['a','b','c','a','b','c'],...ordered=True)>>>ci2_ordered=ci_ordered.set_categories(['b','c','a'])>>>ci_ordered.equals(ci2_ordered)False"
Pandas,Index objects,pandas.IntervalIndex,"pandas.IntervalIndex#classpandas.IntervalIndex(data,closed=None,dtype=None,copy=False,name=None,verify_integrity=True)[source]#Immutable index of intervals that are closed on the same side.Parameters:dataarray-like (1-dimensional)Array-like (ndarray,DateTimeArray,TimeDeltaArray) containing
Interval objects from which to build the IntervalIndex.closed{‘left’, ‘right’, ‘both’, ‘neither’}, default ‘right’Whether the intervals are closed on the left-side, right-side, both or
neither.dtypedtype or None, default NoneIf None, dtype will be inferred.copybool, default FalseCopy the input data.nameobject, optionalName to be stored in the index.verify_integritybool, default TrueVerify that the IntervalIndex is valid.See alsoIndexThe base pandas Index type.IntervalA bounded slice-like interval; the elements of an IntervalIndex.interval_rangeFunction to create a fixed frequency IntervalIndex.cutBin values into discrete Intervals.qcutBin values into equal-sized Intervals based on rank or sample quantiles.NotesSee theuser guidefor more.ExamplesA newIntervalIndexis typically constructed usinginterval_range():>>>pd.interval_range(start=0,end=5)IntervalIndex([(0, 1], (1, 2], (2, 3], (3, 4], (4, 5]],dtype='interval[int64, right]')It may also be constructed using one of the constructor
methods:IntervalIndex.from_arrays(),IntervalIndex.from_breaks(), andIntervalIndex.from_tuples().See further examples in the doc strings ofinterval_rangeand the
mentioned constructor methods.AttributesclosedString describing the inclusive side the intervals.is_emptyIndicates if an interval is empty, meaning it contains no points.is_non_overlapping_monotonicReturn a boolean whether the IntervalArray is non-overlapping and monotonic.is_overlappingReturn True if the IntervalIndex has overlapping intervals, else False.valuesReturn an array representing the data in the Index.leftrightmidlengthMethodsfrom_arrays(left, right[, closed, name, ...])Construct from two arrays defining the left and right bounds.from_tuples(data[, closed, name, copy, dtype])Construct an IntervalIndex from an array-like of tuples.from_breaks(breaks[, closed, name, copy, dtype])Construct an IntervalIndex from an array of splits.contains(*args, **kwargs)Check elementwise if the Intervals contain the value.overlaps(*args, **kwargs)Check elementwise if an Interval overlaps the values in the IntervalArray.set_closed(*args, **kwargs)Return an identical IntervalArray closed on the specified side.to_tuples(*args, **kwargs)Return an ndarray (if self is IntervalArray) or Index (if self is IntervalIndex) of tuples of the form (left, right)."
Pandas,Index objects,pandas.IntervalIndex.from_arrays,"pandas.IntervalIndex.from_arrays#classmethodIntervalIndex.from_arrays(left,right,closed='right',name=None,copy=False,dtype=None)[source]#Construct from two arrays defining the left and right bounds.Parameters:leftarray-like (1-dimensional)Left bounds for each interval.rightarray-like (1-dimensional)Right bounds for each interval.closed{‘left’, ‘right’, ‘both’, ‘neither’}, default ‘right’Whether the intervals are closed on the left-side, right-side, both
or neither.namestr, optionalName of the resulting IntervalIndex.copybool, default FalseCopy the data.dtypedtype, optionalIf None, dtype will be inferred.Returns:IntervalIndexRaises:ValueErrorWhen a value is missing in only one ofleftorright.
When a value inleftis greater than the corresponding value
inright.See alsointerval_rangeFunction to create a fixed frequency IntervalIndex.IntervalIndex.from_breaksConstruct an IntervalIndex from an array of splits.IntervalIndex.from_tuplesConstruct an IntervalIndex from an array-like of tuples.NotesEach element ofleftmust be less than or equal to therightelement at the same position. If an element is missing, it must be
missing in bothleftandright. A TypeError is raised when
using an unsupported type forleftorright. At the moment,
‘category’, ‘object’, and ‘string’ subtypes are not supported.Examples>>>pd.IntervalIndex.from_arrays([0,1,2],[1,2,3])IntervalIndex([(0, 1], (1, 2], (2, 3]],dtype='interval[int64, right]')"
Pandas,Index objects,pandas.IntervalIndex.from_tuples,"pandas.IntervalIndex.from_tuples#classmethodIntervalIndex.from_tuples(data,closed='right',name=None,copy=False,dtype=None)[source]#Construct an IntervalIndex from an array-like of tuples.Parameters:dataarray-like (1-dimensional)Array of tuples.closed{‘left’, ‘right’, ‘both’, ‘neither’}, default ‘right’Whether the intervals are closed on the left-side, right-side, both
or neither.namestr, optionalName of the resulting IntervalIndex.copybool, default FalseBy-default copy the data, this is compat only and ignored.dtypedtype or None, default NoneIf None, dtype will be inferred.Returns:IntervalIndexSee alsointerval_rangeFunction to create a fixed frequency IntervalIndex.IntervalIndex.from_arraysConstruct an IntervalIndex from a left and right array.IntervalIndex.from_breaksConstruct an IntervalIndex from an array of splits.Examples>>>pd.IntervalIndex.from_tuples([(0,1),(1,2)])IntervalIndex([(0, 1], (1, 2]],dtype='interval[int64, right]')"
Pandas,Index objects,pandas.IntervalIndex.from_breaks,"pandas.IntervalIndex.from_breaks#classmethodIntervalIndex.from_breaks(breaks,closed='right',name=None,copy=False,dtype=None)[source]#Construct an IntervalIndex from an array of splits.Parameters:breaksarray-like (1-dimensional)Left and right bounds for each interval.closed{‘left’, ‘right’, ‘both’, ‘neither’}, default ‘right’Whether the intervals are closed on the left-side, right-side, both
or neither.namestr, optionalName of the resulting IntervalIndex.copybool, default FalseCopy the data.dtypedtype or None, default NoneIf None, dtype will be inferred.Returns:IntervalIndexSee alsointerval_rangeFunction to create a fixed frequency IntervalIndex.IntervalIndex.from_arraysConstruct from a left and right array.IntervalIndex.from_tuplesConstruct from a sequence of tuples.Examples>>>pd.IntervalIndex.from_breaks([0,1,2,3])IntervalIndex([(0, 1], (1, 2], (2, 3]],dtype='interval[int64, right]')"
Pandas,Index objects,pandas.IntervalIndex.left,pandas.IntervalIndex.left#IntervalIndex.left[source]#
Pandas,Index objects,pandas.IntervalIndex.right,pandas.IntervalIndex.right#IntervalIndex.right[source]#
Pandas,Index objects,pandas.IntervalIndex.mid,pandas.IntervalIndex.mid#IntervalIndex.mid[source]#
Pandas,Index objects,pandas.IntervalIndex.closed,"pandas.IntervalIndex.closed#IntervalIndex.closed[source]#String describing the inclusive side the intervals.Eitherleft,right,bothorneither.ExamplesFor arrays:>>>interv_arr=pd.arrays.IntervalArray([pd.Interval(0,1),pd.Interval(1,5)])>>>interv_arr<IntervalArray>[(0, 1], (1, 5]]Length: 2, dtype: interval[int64, right]>>>interv_arr.closed'right'For Interval Index:>>>interv_idx=pd.interval_range(start=0,end=2)>>>interv_idxIntervalIndex([(0, 1], (1, 2]], dtype='interval[int64, right]')>>>interv_idx.closed'right'"
Pandas,Index objects,pandas.IntervalIndex.length,pandas.IntervalIndex.length#propertyIntervalIndex.length[source]#
Pandas,Index objects,pandas.IntervalIndex.values,"pandas.IntervalIndex.values#propertyIntervalIndex.values[source]#Return an array representing the data in the Index.WarningWe recommend usingIndex.arrayorIndex.to_numpy(), depending on whether you need
a reference to the underlying data or a NumPy array.Returns:array: numpy.ndarray or ExtensionArraySee alsoIndex.arrayReference to the underlying data.Index.to_numpyA NumPy array representing the underlying data.ExamplesForpandas.Index:>>>idx=pd.Index([1,2,3])>>>idxIndex([1, 2, 3], dtype='int64')>>>idx.valuesarray([1, 2, 3])Forpandas.IntervalIndex:>>>idx=pd.interval_range(start=0,end=5)>>>idx.values<IntervalArray>[(0, 1], (1, 2], (2, 3], (3, 4], (4, 5]]Length: 5, dtype: interval[int64, right]"
Pandas,Index objects,pandas.IntervalIndex.is_empty,"pandas.IntervalIndex.is_empty#propertyIntervalIndex.is_empty[source]#Indicates if an interval is empty, meaning it contains no points.Returns:bool or ndarrayA boolean indicating if a scalarIntervalis empty, or a
booleanndarraypositionally indicating if anIntervalin
anIntervalArrayorIntervalIndexis
empty.See alsoInterval.lengthReturn the length of the Interval.ExamplesAnIntervalthat contains points is not empty:>>>pd.Interval(0,1,closed='right').is_emptyFalseAnIntervalthat does not contain any points is empty:>>>pd.Interval(0,0,closed='right').is_emptyTrue>>>pd.Interval(0,0,closed='left').is_emptyTrue>>>pd.Interval(0,0,closed='neither').is_emptyTrueAnIntervalthat contains a single point is not empty:>>>pd.Interval(0,0,closed='both').is_emptyFalseAnIntervalArrayorIntervalIndexreturns a
booleanndarraypositionally indicating if anIntervalis
empty:>>>ivs=[pd.Interval(0,0,closed='neither'),...pd.Interval(1,2,closed='neither')]>>>pd.arrays.IntervalArray(ivs).is_emptyarray([ True, False])Missing values are not considered empty:>>>ivs=[pd.Interval(0,0,closed='neither'),np.nan]>>>pd.IntervalIndex(ivs).is_emptyarray([ True, False])"
Pandas,Index objects,pandas.IntervalIndex.is_non_overlapping_monotonic,"pandas.IntervalIndex.is_non_overlapping_monotonic#IntervalIndex.is_non_overlapping_monotonic[source]#Return a boolean whether the IntervalArray is non-overlapping and monotonic.Non-overlapping means (no Intervals share points), and monotonic means
either monotonic increasing or monotonic decreasing.ExamplesFor arrays:>>>interv_arr=pd.arrays.IntervalArray([pd.Interval(0,1),pd.Interval(1,5)])>>>interv_arr<IntervalArray>[(0, 1], (1, 5]]Length: 2, dtype: interval[int64, right]>>>interv_arr.is_non_overlapping_monotonicTrue>>>interv_arr=pd.arrays.IntervalArray([pd.Interval(0,1),...pd.Interval(-1,0.1)])>>>interv_arr<IntervalArray>[(0.0, 1.0], (-1.0, 0.1]]Length: 2, dtype: interval[float64, right]>>>interv_arr.is_non_overlapping_monotonicFalseFor Interval Index:>>>interv_idx=pd.interval_range(start=0,end=2)>>>interv_idxIntervalIndex([(0, 1], (1, 2]], dtype='interval[int64, right]')>>>interv_idx.is_non_overlapping_monotonicTrue>>>interv_idx=pd.interval_range(start=0,end=2,closed='both')>>>interv_idxIntervalIndex([[0, 1], [1, 2]], dtype='interval[int64, both]')>>>interv_idx.is_non_overlapping_monotonicFalse"
Pandas,Index objects,pandas.IntervalIndex.is_overlapping,"pandas.IntervalIndex.is_overlapping#propertyIntervalIndex.is_overlapping[source]#Return True if the IntervalIndex has overlapping intervals, else False.Two intervals overlap if they share a common point, including closed
endpoints. Intervals that only have an open endpoint in common do not
overlap.Returns:boolBoolean indicating if the IntervalIndex has overlapping intervals.See alsoInterval.overlapsCheck whether two Interval objects overlap.IntervalIndex.overlapsCheck an IntervalIndex elementwise for overlaps.Examples>>>index=pd.IntervalIndex.from_tuples([(0,2),(1,3),(4,5)])>>>indexIntervalIndex([(0, 2], (1, 3], (4, 5]],dtype='interval[int64, right]')>>>index.is_overlappingTrueIntervals that share closed endpoints overlap:>>>index=pd.interval_range(0,3,closed='both')>>>indexIntervalIndex([[0, 1], [1, 2], [2, 3]],dtype='interval[int64, both]')>>>index.is_overlappingTrueIntervals that only have an open endpoint in common do not overlap:>>>index=pd.interval_range(0,3,closed='left')>>>indexIntervalIndex([[0, 1), [1, 2), [2, 3)],dtype='interval[int64, left]')>>>index.is_overlappingFalse"
Pandas,Index objects,pandas.IntervalIndex.get_loc,"pandas.IntervalIndex.get_loc#IntervalIndex.get_loc(key)[source]#Get integer location, slice or boolean mask for requested label.Parameters:keylabelReturns:int if unique index, slice if monotonic index, else maskExamples>>>i1,i2=pd.Interval(0,1),pd.Interval(1,2)>>>index=pd.IntervalIndex([i1,i2])>>>index.get_loc(1)0You can also supply a point inside an interval.>>>index.get_loc(1.5)1If a label is in several intervals, you get the locations of all the
relevant intervals.>>>i3=pd.Interval(0,2)>>>overlapping_index=pd.IntervalIndex([i1,i2,i3])>>>overlapping_index.get_loc(0.5)array([ True, False,  True])Only exact matches will be returned if an interval is provided.>>>index.get_loc(pd.Interval(0,1))0"
Pandas,Index objects,pandas.IntervalIndex.get_indexer,"pandas.IntervalIndex.get_indexer#IntervalIndex.get_indexer(target,method=None,limit=None,tolerance=None)[source]#Compute indexer and mask for new index given the current index.The indexer should be then used as an input to ndarray.take to align the
current data to the new index.Parameters:targetIndexmethod{None, ‘pad’/’ffill’, ‘backfill’/’bfill’, ‘nearest’}, optionaldefault: exact matches only.pad / ffill: find the PREVIOUS index value if no exact match.backfill / bfill: use NEXT index value if no exact matchnearest: use the NEAREST index value if no exact match. Tied
distances are broken by preferring the larger index value.limitint, optionalMaximum number of consecutive labels intargetto match for
inexact matches.toleranceoptionalMaximum distance between original and new labels for inexact
matches. The values of the index at the matching locations must
satisfy the equationabs(index[indexer]-target)<=tolerance.Tolerance may be a scalar value, which applies the same tolerance
to all values, or list-like, which applies variable tolerance per
element. List-like includes list, tuple, array, Series, and must be
the same size as the index and its dtype must exactly match the
index’s type.Returns:np.ndarray[np.intp]Integers from 0 to n - 1 indicating that the index at these
positions matches the corresponding target values. Missing values
in the target are marked by -1.NotesReturns -1 for unmatched values, for further explanation see the
example below.Examples>>>index=pd.Index(['c','a','b'])>>>index.get_indexer(['a','b','x'])array([ 1,  2, -1])Notice that the return value is an array of locations inindexandxis marked by -1, as it is not inindex."
Pandas,Index objects,pandas.IntervalIndex.set_closed,"pandas.IntervalIndex.set_closed#IntervalIndex.set_closed(*args,**kwargs)[source]#Return an identical IntervalArray closed on the specified side.Parameters:closed{‘left’, ‘right’, ‘both’, ‘neither’}Whether the intervals are closed on the left-side, right-side, both
or neither.Returns:IntervalArrayExamples>>>index=pd.arrays.IntervalArray.from_breaks(range(4))>>>index<IntervalArray>[(0, 1], (1, 2], (2, 3]]Length: 3, dtype: interval[int64, right]>>>index.set_closed('both')<IntervalArray>[[0, 1], [1, 2], [2, 3]]Length: 3, dtype: interval[int64, both]"
Pandas,Index objects,pandas.IntervalIndex.contains,"pandas.IntervalIndex.contains#IntervalIndex.contains(*args,**kwargs)[source]#Check elementwise if the Intervals contain the value.Return a boolean mask whether the value is contained in the Intervals
of the IntervalArray.Parameters:otherscalarThe value to check whether it is contained in the Intervals.Returns:boolean arraySee alsoInterval.containsCheck whether Interval object contains value.IntervalArray.overlapsCheck if an Interval overlaps the values in the IntervalArray.Examples>>>intervals=pd.arrays.IntervalArray.from_tuples([(0,1),(1,3),(2,4)])>>>intervals<IntervalArray>[(0, 1], (1, 3], (2, 4]]Length: 3, dtype: interval[int64, right]>>>intervals.contains(0.5)array([ True, False, False])"
Pandas,Index objects,pandas.IntervalIndex.overlaps,"pandas.IntervalIndex.overlaps#IntervalIndex.overlaps(*args,**kwargs)[source]#Check elementwise if an Interval overlaps the values in the IntervalArray.Two intervals overlap if they share a common point, including closed
endpoints. Intervals that only have an open endpoint in common do not
overlap.Parameters:otherIntervalArrayInterval to check against for an overlap.Returns:ndarrayBoolean array positionally indicating where an overlap occurs.See alsoInterval.overlapsCheck whether two Interval objects overlap.Examples>>>data=[(0,1),(1,3),(2,4)]>>>intervals=pd.arrays.IntervalArray.from_tuples(data)>>>intervals<IntervalArray>[(0, 1], (1, 3], (2, 4]]Length: 3, dtype: interval[int64, right]>>>intervals.overlaps(pd.Interval(0.5,1.5))array([ True,  True, False])Intervals that share closed endpoints overlap:>>>intervals.overlaps(pd.Interval(1,3,closed='left'))array([ True,  True, True])Intervals that only have an open endpoint in common do not overlap:>>>intervals.overlaps(pd.Interval(1,2,closed='right'))array([False,  True, False])"
Pandas,Index objects,pandas.IntervalIndex.to_tuples,"pandas.IntervalIndex.to_tuples#IntervalIndex.to_tuples(*args,**kwargs)[source]#Return an ndarray (if self is IntervalArray) or Index (if self is IntervalIndex) of tuples of the form (left, right).Parameters:na_tuplebool, default TrueIfTrue, returnNAas a tuple(nan,nan). IfFalse,
just returnNAasnan.Returns:tuples: ndarray (if self is IntervalArray) or Index (if self is IntervalIndex)ExamplesForpandas.IntervalArray:>>>idx=pd.arrays.IntervalArray.from_tuples([(0,1),(1,2)])>>>idx<IntervalArray>[(0, 1], (1, 2]]Length: 2, dtype: interval[int64, right]>>>idx.to_tuples()array([(0, 1), (1, 2)], dtype=object)Forpandas.IntervalIndex:>>>idx=pd.interval_range(start=0,end=2)>>>idxIntervalIndex([(0, 1], (1, 2]], dtype='interval[int64, right]')>>>idx.to_tuples()Index([(0, 1), (1, 2)], dtype='object')"
Pandas,Index objects,pandas.MultiIndex,"pandas.MultiIndex#classpandas.MultiIndex(levels=None,codes=None,sortorder=None,names=None,dtype=None,copy=False,name=None,verify_integrity=True)[source]#A multi-level, or hierarchical, index object for pandas objects.Parameters:levelssequence of arraysThe unique labels for each level.codessequence of arraysIntegers for each level designating which label at each location.sortorderoptional intLevel of sortedness (must be lexicographically sorted by that
level).namesoptional sequence of objectsNames for each of the index levels. (name is accepted for compat).copybool, default FalseCopy the meta-data.verify_integritybool, default TrueCheck that the levels/codes are consistent and valid.See alsoMultiIndex.from_arraysConvert list of arrays to MultiIndex.MultiIndex.from_productCreate a MultiIndex from the cartesian product of iterables.MultiIndex.from_tuplesConvert list of tuples to a MultiIndex.MultiIndex.from_frameMake a MultiIndex from a DataFrame.IndexThe base pandas Index type.NotesSee theuser guidefor more.ExamplesA newMultiIndexis typically constructed using one of the helper
methodsMultiIndex.from_arrays(),MultiIndex.from_product()andMultiIndex.from_tuples(). For example (using.from_arrays):>>>arrays=[[1,1,2,2],['red','blue','red','blue']]>>>pd.MultiIndex.from_arrays(arrays,names=('number','color'))MultiIndex([(1,  'red'),(1, 'blue'),(2,  'red'),(2, 'blue')],names=['number', 'color'])See further examples for how to construct a MultiIndex in the doc strings
of the mentioned helper methods.AttributesnamesNames of levels in MultiIndex.nlevelsInteger number of levels in this MultiIndex.levshapeA tuple with the length of each level.dtypesReturn the dtypes as a Series for the underlying MultiIndex.levelscodesMethodsfrom_arrays(arrays[, sortorder, names])Convert arrays to MultiIndex.from_tuples(tuples[, sortorder, names])Convert list of tuples to MultiIndex.from_product(iterables[, sortorder, names])Make a MultiIndex from the cartesian product of multiple iterables.from_frame(df[, sortorder, names])Make a MultiIndex from a DataFrame.set_levels(levels, *[, level, verify_integrity])Set new levels on MultiIndex.set_codes(codes, *[, level, verify_integrity])Set new codes on MultiIndex.to_frame([index, name, allow_duplicates])Create a DataFrame with the levels of the MultiIndex as columns.to_flat_index()Convert a MultiIndex to an Index of Tuples containing the level values.sortlevel([level, ascending, ...])Sort MultiIndex at the requested level.droplevel([level])Return index with requested level(s) removed.swaplevel([i, j])Swap level i with level j.reorder_levels(order)Rearrange levels using input order.remove_unused_levels()Create new MultiIndex from current that removes unused levels.get_level_values(level)Return vector of label values for requested level.get_indexer(target[, method, limit, tolerance])Compute indexer and mask for new index given the current index.get_loc(key)Get location for a label or a tuple of labels.get_locs(seq)Get location for a sequence of labels.get_loc_level(key[, level, drop_level])Get location and sliced index for requested label(s)/level(s).drop(codes[, level, errors])Make a newpandas.MultiIndexwith the passed list of codes deleted."
Pandas,Index objects,pandas.MultiIndex.from_arrays,"pandas.MultiIndex.from_arrays#classmethodMultiIndex.from_arrays(arrays,sortorder=None,names=_NoDefault.no_default)[source]#Convert arrays to MultiIndex.Parameters:arrayslist / sequence of array-likesEach array-like gives one level’s value for each data point.
len(arrays) is the number of levels.sortorderint or NoneLevel of sortedness (must be lexicographically sorted by that
level).nameslist / sequence of str, optionalNames for the levels in the index.Returns:MultiIndexSee alsoMultiIndex.from_tuplesConvert list of tuples to MultiIndex.MultiIndex.from_productMake a MultiIndex from cartesian product of iterables.MultiIndex.from_frameMake a MultiIndex from a DataFrame.Examples>>>arrays=[[1,1,2,2],['red','blue','red','blue']]>>>pd.MultiIndex.from_arrays(arrays,names=('number','color'))MultiIndex([(1,  'red'),(1, 'blue'),(2,  'red'),(2, 'blue')],names=['number', 'color'])"
Pandas,Index objects,pandas.MultiIndex.from_tuples,"pandas.MultiIndex.from_tuples#classmethodMultiIndex.from_tuples(tuples,sortorder=None,names=None)[source]#Convert list of tuples to MultiIndex.Parameters:tupleslist / sequence of tuple-likesEach tuple is the index of one row/column.sortorderint or NoneLevel of sortedness (must be lexicographically sorted by that
level).nameslist / sequence of str, optionalNames for the levels in the index.Returns:MultiIndexSee alsoMultiIndex.from_arraysConvert list of arrays to MultiIndex.MultiIndex.from_productMake a MultiIndex from cartesian product of iterables.MultiIndex.from_frameMake a MultiIndex from a DataFrame.Examples>>>tuples=[(1,'red'),(1,'blue'),...(2,'red'),(2,'blue')]>>>pd.MultiIndex.from_tuples(tuples,names=('number','color'))MultiIndex([(1,  'red'),(1, 'blue'),(2,  'red'),(2, 'blue')],names=['number', 'color'])"
Pandas,Index objects,pandas.MultiIndex.from_product,"pandas.MultiIndex.from_product#classmethodMultiIndex.from_product(iterables,sortorder=None,names=_NoDefault.no_default)[source]#Make a MultiIndex from the cartesian product of multiple iterables.Parameters:iterableslist / sequence of iterablesEach iterable has unique labels for each level of the index.sortorderint or NoneLevel of sortedness (must be lexicographically sorted by that
level).nameslist / sequence of str, optionalNames for the levels in the index.
If not explicitly provided, names will be inferred from the
elements of iterables if an element has a name attribute.Returns:MultiIndexSee alsoMultiIndex.from_arraysConvert list of arrays to MultiIndex.MultiIndex.from_tuplesConvert list of tuples to MultiIndex.MultiIndex.from_frameMake a MultiIndex from a DataFrame.Examples>>>numbers=[0,1,2]>>>colors=['green','purple']>>>pd.MultiIndex.from_product([numbers,colors],...names=['number','color'])MultiIndex([(0,  'green'),(0, 'purple'),(1,  'green'),(1, 'purple'),(2,  'green'),(2, 'purple')],names=['number', 'color'])"
Pandas,Index objects,pandas.MultiIndex.from_frame,"pandas.MultiIndex.from_frame#classmethodMultiIndex.from_frame(df,sortorder=None,names=None)[source]#Make a MultiIndex from a DataFrame.Parameters:dfDataFrameDataFrame to be converted to MultiIndex.sortorderint, optionalLevel of sortedness (must be lexicographically sorted by that
level).nameslist-like, optionalIf no names are provided, use the column names, or tuple of column
names if the columns is a MultiIndex. If a sequence, overwrite
names with the given sequence.Returns:MultiIndexThe MultiIndex representation of the given DataFrame.See alsoMultiIndex.from_arraysConvert list of arrays to MultiIndex.MultiIndex.from_tuplesConvert list of tuples to MultiIndex.MultiIndex.from_productMake a MultiIndex from cartesian product of iterables.Examples>>>df=pd.DataFrame([['HI','Temp'],['HI','Precip'],...['NJ','Temp'],['NJ','Precip']],...columns=['a','b'])>>>dfa       b0    HI    Temp1    HI  Precip2    NJ    Temp3    NJ  Precip>>>pd.MultiIndex.from_frame(df)MultiIndex([('HI',   'Temp'),('HI', 'Precip'),('NJ',   'Temp'),('NJ', 'Precip')],names=['a', 'b'])Using explicit names, instead of the column names>>>pd.MultiIndex.from_frame(df,names=['state','observation'])MultiIndex([('HI',   'Temp'),('HI', 'Precip'),('NJ',   'Temp'),('NJ', 'Precip')],names=['state', 'observation'])"
Pandas,Index objects,pandas.MultiIndex.names,"pandas.MultiIndex.names#propertyMultiIndex.names[source]#Names of levels in MultiIndex.Examples>>>mi=pd.MultiIndex.from_arrays(...[[1,2],[3,4],[5,6]],names=['x','y','z'])>>>miMultiIndex([(1, 3, 5),(2, 4, 6)],names=['x', 'y', 'z'])>>>mi.namesFrozenList(['x', 'y', 'z'])"
Pandas,Index objects,pandas.MultiIndex.levels,pandas.MultiIndex.levels#MultiIndex.levels[source]#
Pandas,Index objects,pandas.MultiIndex.codes,pandas.MultiIndex.codes#propertyMultiIndex.codes[source]#
Pandas,Index objects,pandas.MultiIndex.nlevels,"pandas.MultiIndex.nlevels#propertyMultiIndex.nlevels[source]#Integer number of levels in this MultiIndex.Examples>>>mi=pd.MultiIndex.from_arrays([['a'],['b'],['c']])>>>miMultiIndex([('a', 'b', 'c')],)>>>mi.nlevels3"
Pandas,Index objects,pandas.MultiIndex.levshape,"pandas.MultiIndex.levshape#propertyMultiIndex.levshape[source]#A tuple with the length of each level.Examples>>>mi=pd.MultiIndex.from_arrays([['a'],['b'],['c']])>>>miMultiIndex([('a', 'b', 'c')],)>>>mi.levshape(1, 1, 1)"
Pandas,Index objects,pandas.MultiIndex.dtypes,"pandas.MultiIndex.dtypes#MultiIndex.dtypes[source]#Return the dtypes as a Series for the underlying MultiIndex.Examples>>>idx=pd.MultiIndex.from_product([(0,1,2),('green','purple')],...names=['number','color'])>>>idxMultiIndex([(0,  'green'),(0, 'purple'),(1,  'green'),(1, 'purple'),(2,  'green'),(2, 'purple')],names=['number', 'color'])>>>idx.dtypesnumber     int64color     objectdtype: object"
Pandas,Index objects,pandas.MultiIndex.set_levels,"pandas.MultiIndex.set_levels#MultiIndex.set_levels(levels,*,level=None,verify_integrity=True)[source]#Set new levels on MultiIndex. Defaults to returning new index.Parameters:levelssequence or list of sequenceNew level(s) to apply.levelint, level name, or sequence of int/level names (default None)Level(s) to set (None for all levels).verify_integritybool, default TrueIf True, checks that levels and codes are compatible.Returns:MultiIndexExamples>>>idx=pd.MultiIndex.from_tuples(...[...(1,""one""),...(1,""two""),...(2,""one""),...(2,""two""),...(3,""one""),...(3,""two"")...],...names=[""foo"",""bar""]...)>>>idxMultiIndex([(1, 'one'),(1, 'two'),(2, 'one'),(2, 'two'),(3, 'one'),(3, 'two')],names=['foo', 'bar'])>>>idx.set_levels([['a','b','c'],[1,2]])MultiIndex([('a', 1),('a', 2),('b', 1),('b', 2),('c', 1),('c', 2)],names=['foo', 'bar'])>>>idx.set_levels(['a','b','c'],level=0)MultiIndex([('a', 'one'),('a', 'two'),('b', 'one'),('b', 'two'),('c', 'one'),('c', 'two')],names=['foo', 'bar'])>>>idx.set_levels(['a','b'],level='bar')MultiIndex([(1, 'a'),(1, 'b'),(2, 'a'),(2, 'b'),(3, 'a'),(3, 'b')],names=['foo', 'bar'])If any of the levels passed toset_levels()exceeds the
existing length, all of the values from that argument will
be stored in the MultiIndex levels, though the values will
be truncated in the MultiIndex output.>>>idx.set_levels([['a','b','c'],[1,2,3,4]],level=[0,1])MultiIndex([('a', 1),('a', 2),('b', 1),('b', 2),('c', 1),('c', 2)],names=['foo', 'bar'])>>>idx.set_levels([['a','b','c'],[1,2,3,4]],level=[0,1]).levelsFrozenList([['a', 'b', 'c'], [1, 2, 3, 4]])"
Pandas,Index objects,pandas.MultiIndex.set_codes,"pandas.MultiIndex.set_codes#MultiIndex.set_codes(codes,*,level=None,verify_integrity=True)[source]#Set new codes on MultiIndex. Defaults to returning new index.Parameters:codessequence or list of sequenceNew codes to apply.levelint, level name, or sequence of int/level names (default None)Level(s) to set (None for all levels).verify_integritybool, default TrueIf True, checks that levels and codes are compatible.Returns:new index (of same type and class…etc) or NoneThe same type as the caller or None ifinplace=True.Examples>>>idx=pd.MultiIndex.from_tuples(...[(1,""one""),(1,""two""),(2,""one""),(2,""two"")],names=[""foo"",""bar""]...)>>>idxMultiIndex([(1, 'one'),(1, 'two'),(2, 'one'),(2, 'two')],names=['foo', 'bar'])>>>idx.set_codes([[1,0,1,0],[0,0,1,1]])MultiIndex([(2, 'one'),(1, 'one'),(2, 'two'),(1, 'two')],names=['foo', 'bar'])>>>idx.set_codes([1,0,1,0],level=0)MultiIndex([(2, 'one'),(1, 'two'),(2, 'one'),(1, 'two')],names=['foo', 'bar'])>>>idx.set_codes([0,0,1,1],level='bar')MultiIndex([(1, 'one'),(1, 'one'),(2, 'two'),(2, 'two')],names=['foo', 'bar'])>>>idx.set_codes([[1,0,1,0],[0,0,1,1]],level=[0,1])MultiIndex([(2, 'one'),(1, 'one'),(2, 'two'),(1, 'two')],names=['foo', 'bar'])"
Pandas,Index objects,pandas.MultiIndex.to_flat_index,"pandas.MultiIndex.to_flat_index#MultiIndex.to_flat_index()[source]#Convert a MultiIndex to an Index of Tuples containing the level values.Returns:pd.IndexIndex with the MultiIndex data represented in Tuples.See alsoMultiIndex.from_tuplesConvert flat index back to MultiIndex.NotesThis method will simply return the caller if called by anything other
than a MultiIndex.Examples>>>index=pd.MultiIndex.from_product(...[['foo','bar'],['baz','qux']],...names=['a','b'])>>>index.to_flat_index()Index([('foo', 'baz'), ('foo', 'qux'),('bar', 'baz'), ('bar', 'qux')],dtype='object')"
Pandas,Index objects,pandas.MultiIndex.to_frame,"pandas.MultiIndex.to_frame#MultiIndex.to_frame(index=True,name=_NoDefault.no_default,allow_duplicates=False)[source]#Create a DataFrame with the levels of the MultiIndex as columns.Column ordering is determined by the DataFrame constructor with data as
a dict.Parameters:indexbool, default TrueSet the index of the returned DataFrame as the original MultiIndex.namelist / sequence of str, optionalThe passed names should substitute index level names.allow_duplicatesbool, optional default FalseAllow duplicate column labels to be created.New in version 1.5.0.Returns:DataFrameSee alsoDataFrameTwo-dimensional, size-mutable, potentially heterogeneous tabular data.Examples>>>mi=pd.MultiIndex.from_arrays([['a','b'],['c','d']])>>>miMultiIndex([('a', 'c'),('b', 'd')],)>>>df=mi.to_frame()>>>df0  1a c  a  cb d  b  d>>>df=mi.to_frame(index=False)>>>df0  10  a  c1  b  d>>>df=mi.to_frame(name=['x','y'])>>>dfx  ya c  a  cb d  b  d"
Pandas,Index objects,pandas.MultiIndex.sortlevel,"pandas.MultiIndex.sortlevel#MultiIndex.sortlevel(level=0,ascending=True,sort_remaining=True,na_position='first')[source]#Sort MultiIndex at the requested level.The result will respect the original ordering of the associated
factor at that level.Parameters:levellist-like, int or str, default 0If a string is given, must be a name of the level.
If list-like must be names or ints of levels.ascendingbool, default TrueFalse to sort in descending order.
Can also be a list to specify a directed ordering.sort_remainingsort by the remaining levels after levelna_position{‘first’ or ‘last’}, default ‘first’Argument ‘first’ puts NaNs at the beginning, ‘last’ puts NaNs at
the end.New in version 2.1.0.Returns:sorted_indexpd.MultiIndexResulting index.indexernp.ndarray[np.intp]Indices of output values in original index.Examples>>>mi=pd.MultiIndex.from_arrays([[0,0],[2,1]])>>>miMultiIndex([(0, 2),(0, 1)],)>>>mi.sortlevel()(MultiIndex([(0, 1),(0, 2)],), array([1, 0]))>>>mi.sortlevel(sort_remaining=False)(MultiIndex([(0, 2),(0, 1)],), array([0, 1]))>>>mi.sortlevel(1)(MultiIndex([(0, 1),(0, 2)],), array([1, 0]))>>>mi.sortlevel(1,ascending=False)(MultiIndex([(0, 2),(0, 1)],), array([0, 1]))"
Pandas,Index objects,pandas.MultiIndex.droplevel,"pandas.MultiIndex.droplevel#MultiIndex.droplevel(level=0)[source]#Return index with requested level(s) removed.If resulting index has only 1 level left, the result will be
of Index type, not MultiIndex. The original index is not modified inplace.Parameters:levelint, str, or list-like, default 0If a string is given, must be the name of a level
If list-like, elements must be names or indexes of levels.Returns:Index or MultiIndexExamples>>>mi=pd.MultiIndex.from_arrays(...[[1,2],[3,4],[5,6]],names=['x','y','z'])>>>miMultiIndex([(1, 3, 5),(2, 4, 6)],names=['x', 'y', 'z'])>>>mi.droplevel()MultiIndex([(3, 5),(4, 6)],names=['y', 'z'])>>>mi.droplevel(2)MultiIndex([(1, 3),(2, 4)],names=['x', 'y'])>>>mi.droplevel('z')MultiIndex([(1, 3),(2, 4)],names=['x', 'y'])>>>mi.droplevel(['x','y'])Index([5, 6], dtype='int64', name='z')"
Pandas,Index objects,pandas.MultiIndex.swaplevel,"pandas.MultiIndex.swaplevel#MultiIndex.swaplevel(i=-2,j=-1)[source]#Swap level i with level j.Calling this method does not change the ordering of the values.Parameters:iint, str, default -2First level of index to be swapped. Can pass level name as string.
Type of parameters can be mixed.jint, str, default -1Second level of index to be swapped. Can pass level name as string.
Type of parameters can be mixed.Returns:MultiIndexA new MultiIndex.See alsoSeries.swaplevelSwap levels i and j in a MultiIndex.DataFrame.swaplevelSwap levels i and j in a MultiIndex on a particular axis.Examples>>>mi=pd.MultiIndex(levels=[['a','b'],['bb','aa']],...codes=[[0,0,1,1],[0,1,0,1]])>>>miMultiIndex([('a', 'bb'),('a', 'aa'),('b', 'bb'),('b', 'aa')],)>>>mi.swaplevel(0,1)MultiIndex([('bb', 'a'),('aa', 'a'),('bb', 'b'),('aa', 'b')],)"
Pandas,Index objects,pandas.MultiIndex.reorder_levels,"pandas.MultiIndex.reorder_levels#MultiIndex.reorder_levels(order)[source]#Rearrange levels using input order. May not drop or duplicate levels.Parameters:orderlist of int or list of strList representing new level order. Reference level by number
(position) or by key (label).Returns:MultiIndexExamples>>>mi=pd.MultiIndex.from_arrays([[1,2],[3,4]],names=['x','y'])>>>miMultiIndex([(1, 3),(2, 4)],names=['x', 'y'])>>>mi.reorder_levels(order=[1,0])MultiIndex([(3, 1),(4, 2)],names=['y', 'x'])>>>mi.reorder_levels(order=['y','x'])MultiIndex([(3, 1),(4, 2)],names=['y', 'x'])"
Pandas,Index objects,pandas.MultiIndex.remove_unused_levels,"pandas.MultiIndex.remove_unused_levels#MultiIndex.remove_unused_levels()[source]#Create new MultiIndex from current that removes unused levels.Unused level(s) means levels that are not expressed in the
labels. The resulting MultiIndex will have the same outward
appearance, meaning the same .values and ordering. It will
also be .equals() to the original.Returns:MultiIndexExamples>>>mi=pd.MultiIndex.from_product([range(2),list('ab')])>>>miMultiIndex([(0, 'a'),(0, 'b'),(1, 'a'),(1, 'b')],)>>>mi[2:]MultiIndex([(1, 'a'),(1, 'b')],)The 0 from the first level is not represented
and can be removed>>>mi2=mi[2:].remove_unused_levels()>>>mi2.levelsFrozenList([[1], ['a', 'b']])"
Pandas,Index objects,pandas.MultiIndex.drop,"pandas.MultiIndex.drop#MultiIndex.drop(codes,level=None,errors='raise')[source]#Make a newpandas.MultiIndexwith the passed list of codes deleted.Parameters:codesarray-likeMust be a list of tuples whenlevelis not specified.levelint or level name, default Noneerrorsstr, default ‘raise’Returns:MultiIndexExamples>>>idx=pd.MultiIndex.from_product([(0,1,2),('green','purple')],...names=[""number"",""color""])>>>idxMultiIndex([(0,  'green'),(0, 'purple'),(1,  'green'),(1, 'purple'),(2,  'green'),(2, 'purple')],names=['number', 'color'])>>>idx.drop([(1,'green'),(2,'purple')])MultiIndex([(0,  'green'),(0, 'purple'),(1, 'purple'),(2,  'green')],names=['number', 'color'])We can also drop from a specific level.>>>idx.drop('green',level='color')MultiIndex([(0, 'purple'),(1, 'purple'),(2, 'purple')],names=['number', 'color'])>>>idx.drop([1,2],level=0)MultiIndex([(0,  'green'),(0, 'purple')],names=['number', 'color'])"
Pandas,Index objects,pandas.MultiIndex.copy,"pandas.MultiIndex.copy#MultiIndex.copy(names=None,deep=False,name=None)[source]#Make a copy of this object.Names, dtype, levels and codes can be passed and will be set on new copy.Parameters:namessequence, optionaldeepbool, default FalsenameLabelKept for compatibility with 1-dimensional Index. Should not be used.Returns:MultiIndexNotesIn most cases, there should be no functional difference from usingdeep, but ifdeepis passed it will attempt to deepcopy.
This could be potentially expensive on large MultiIndex objects.Examples>>>mi=pd.MultiIndex.from_arrays([['a'],['b'],['c']])>>>miMultiIndex([('a', 'b', 'c')],)>>>mi.copy()MultiIndex([('a', 'b', 'c')],)"
Pandas,Index objects,pandas.MultiIndex.append,"pandas.MultiIndex.append#MultiIndex.append(other)[source]#Append a collection of Index options together.Parameters:otherIndex or list/tuple of indicesReturns:IndexThe combined index.Examples>>>mi=pd.MultiIndex.from_arrays([['a'],['b']])>>>miMultiIndex([('a', 'b')],)>>>mi.append(mi)MultiIndex([('a', 'b'), ('a', 'b')],)"
Pandas,Index objects,pandas.MultiIndex.truncate,"pandas.MultiIndex.truncate#MultiIndex.truncate(before=None,after=None)[source]#Slice index between two labels / tuples, return new MultiIndex.Parameters:beforelabel or tuple, can be partial. Default NoneNone defaults to start.afterlabel or tuple, can be partial. Default NoneNone defaults to end.Returns:MultiIndexThe truncated MultiIndex.Examples>>>mi=pd.MultiIndex.from_arrays([['a','b','c'],['x','y','z']])>>>miMultiIndex([('a', 'x'), ('b', 'y'), ('c', 'z')],)>>>mi.truncate(before='a',after='b')MultiIndex([('a', 'x'), ('b', 'y')],)"
Pandas,Index objects,pandas.MultiIndex.get_loc,"pandas.MultiIndex.get_loc#MultiIndex.get_loc(key)[source]#Get location for a label or a tuple of labels.The location is returned as an integer/slice or boolean
mask.Parameters:keylabel or tuple of labels (one for each level)Returns:int, slice object or boolean maskIf the key is past the lexsort depth, the return may be a
boolean mask array, otherwise it is always a slice or int.See alsoIndex.get_locThe get_loc method for (single-level) index.MultiIndex.slice_locsGet slice location given start label(s) and end label(s).MultiIndex.get_locsGet location for a label/slice/list/mask or a sequence of such.NotesThe key cannot be a slice, list of same-level labels, a boolean mask,
or a sequence of such. If you want to use those, useMultiIndex.get_locs()instead.Examples>>>mi=pd.MultiIndex.from_arrays([list('abb'),list('def')])>>>mi.get_loc('b')slice(1, 3, None)>>>mi.get_loc(('b','e'))1"
Pandas,Index objects,pandas.MultiIndex.get_locs,"pandas.MultiIndex.get_locs#MultiIndex.get_locs(seq)[source]#Get location for a sequence of labels.Parameters:seqlabel, slice, list, mask or a sequence of suchYou should use one of the above for each level.
If a level should not be used, set it toslice(None).Returns:numpy.ndarrayNumPy array of integers suitable for passing to iloc.See alsoMultiIndex.get_locGet location for a label or a tuple of labels.MultiIndex.slice_locsGet slice location given start label(s) and end label(s).Examples>>>mi=pd.MultiIndex.from_arrays([list('abb'),list('def')])>>>mi.get_locs('b')array([1, 2], dtype=int64)>>>mi.get_locs([slice(None),['e','f']])array([1, 2], dtype=int64)>>>mi.get_locs([[True,False,True],slice('e','f')])array([2], dtype=int64)"
Pandas,Index objects,pandas.MultiIndex.get_loc_level,"pandas.MultiIndex.get_loc_level#MultiIndex.get_loc_level(key,level=0,drop_level=True)[source]#Get location and sliced index for requested label(s)/level(s).Parameters:keylabel or sequence of labelslevelint/level name or list thereof, optionaldrop_levelbool, default TrueIfFalse, the resulting index will not drop any level.Returns:tupleA 2-tuple where the elements :Element 0: int, slice object or boolean array.Element 1: The resulting sliced multiindex/index. If the key
contains all levels, this will beNone.See alsoMultiIndex.get_locGet location for a label or a tuple of labels.MultiIndex.get_locsGet location for a label/slice/list/mask or a sequence of such.Examples>>>mi=pd.MultiIndex.from_arrays([list('abb'),list('def')],...names=['A','B'])>>>mi.get_loc_level('b')(slice(1, 3, None), Index(['e', 'f'], dtype='object', name='B'))>>>mi.get_loc_level('e',level='B')(array([False,  True, False]), Index(['b'], dtype='object', name='A'))>>>mi.get_loc_level(['b','e'])(1, None)"
Pandas,Index objects,pandas.MultiIndex.get_indexer,"pandas.MultiIndex.get_indexer#MultiIndex.get_indexer(target,method=None,limit=None,tolerance=None)[source]#Compute indexer and mask for new index given the current index.The indexer should be then used as an input to ndarray.take to align the
current data to the new index.Parameters:targetIndexmethod{None, ‘pad’/’ffill’, ‘backfill’/’bfill’, ‘nearest’}, optionaldefault: exact matches only.pad / ffill: find the PREVIOUS index value if no exact match.backfill / bfill: use NEXT index value if no exact matchnearest: use the NEAREST index value if no exact match. Tied
distances are broken by preferring the larger index value.limitint, optionalMaximum number of consecutive labels intargetto match for
inexact matches.toleranceoptionalMaximum distance between original and new labels for inexact
matches. The values of the index at the matching locations must
satisfy the equationabs(index[indexer]-target)<=tolerance.Tolerance may be a scalar value, which applies the same tolerance
to all values, or list-like, which applies variable tolerance per
element. List-like includes list, tuple, array, Series, and must be
the same size as the index and its dtype must exactly match the
index’s type.Returns:np.ndarray[np.intp]Integers from 0 to n - 1 indicating that the index at these
positions matches the corresponding target values. Missing values
in the target are marked by -1.NotesReturns -1 for unmatched values, for further explanation see the
example below.Examples>>>index=pd.Index(['c','a','b'])>>>index.get_indexer(['a','b','x'])array([ 1,  2, -1])Notice that the return value is an array of locations inindexandxis marked by -1, as it is not inindex."
Pandas,Index objects,pandas.MultiIndex.get_level_values,"pandas.MultiIndex.get_level_values#MultiIndex.get_level_values(level)[source]#Return vector of label values for requested level.Length of returned vector is equal to the length of the index.Parameters:levelint or strlevelis either the integer position of the level in the
MultiIndex, or the name of the level.Returns:IndexValues is a level of this MultiIndex converted to
a singleIndex(or subclass thereof).NotesIf the level contains missing values, the result may be casted tofloatwith missing values specified asNaN. This is because
the level is converted to a regularIndex.ExamplesCreate a MultiIndex:>>>mi=pd.MultiIndex.from_arrays((list('abc'),list('def')))>>>mi.names=['level_1','level_2']Get level values by supplying level as either integer or name:>>>mi.get_level_values(0)Index(['a', 'b', 'c'], dtype='object', name='level_1')>>>mi.get_level_values('level_2')Index(['d', 'e', 'f'], dtype='object', name='level_2')If a level contains missing values, the return type of the level
may be cast tofloat.>>>pd.MultiIndex.from_arrays([[1,None,2],[3,4,5]]).dtypeslevel_0    int64level_1    int64dtype: object>>>pd.MultiIndex.from_arrays([[1,None,2],[3,4,5]]).get_level_values(0)Index([1.0, nan, 2.0], dtype='float64')"
Pandas,Index objects,pandas.IndexSlice,"pandas.IndexSlice#pandas.IndexSlice=<pandas.core.indexing._IndexSliceobject>#Create an object to more easily perform multi-index slicing.See alsoMultiIndex.remove_unused_levelsNew MultiIndex with no unused levels.NotesSeeDefined Levelsfor further info on slicing a MultiIndex.Examples>>>midx=pd.MultiIndex.from_product([['A0','A1'],['B0','B1','B2','B3']])>>>columns=['foo','bar']>>>dfmi=pd.DataFrame(np.arange(16).reshape((len(midx),len(columns))),...index=midx,columns=columns)Using the default slice command:>>>dfmi.loc[(slice(None),slice('B0','B1')),:]foo  barA0 B0    0    1B1    2    3A1 B0    8    9B1   10   11Using the IndexSlice class for a more intuitive command:>>>idx=pd.IndexSlice>>>dfmi.loc[idx[:,'B0':'B1'],:]foo  barA0 B0    0    1B1    2    3A1 B0    8    9B1   10   11"
Pandas,Index objects,pandas.DatetimeIndex,"pandas.DatetimeIndex#classpandas.DatetimeIndex(data=None,freq=_NoDefault.no_default,tz=_NoDefault.no_default,normalize=_NoDefault.no_default,closed=_NoDefault.no_default,ambiguous='raise',dayfirst=False,yearfirst=False,dtype=None,copy=False,name=None)[source]#Immutable ndarray-like of datetime64 data.Represented internally as int64, and which can be boxed to Timestamp objects
that are subclasses of datetime and carry metadata.Changed in version 2.0.0:The various numeric date/time attributes (day,month,yearetc.) now have dtypeint32. Previously they had dtypeint64.Parameters:dataarray-like (1-dimensional)Datetime-like data to construct index with.freqstr or pandas offset object, optionalOne of pandas date offset strings or corresponding objects. The string
‘infer’ can be passed in order to set the frequency of the index as the
inferred frequency upon creation.tzpytz.timezone or dateutil.tz.tzfile or datetime.tzinfo or strSet the Timezone of the data.normalizebool, default FalseNormalize start/end dates to midnight before generating date range.Deprecated since version 2.1.0.closed{‘left’, ‘right’}, optionalSet whether to includestartandendthat are on the
boundary. The default includes boundary points on either end.Deprecated since version 2.1.0.ambiguous‘infer’, bool-ndarray, ‘NaT’, default ‘raise’When clocks moved backward due to DST, ambiguous times may arise.
For example in Central European Time (UTC+01), when going from 03:00
DST to 02:00 non-DST, 02:30:00 local time occurs both at 00:30:00 UTC
and at 01:30:00 UTC. In such a situation, theambiguousparameter
dictates how ambiguous times should be handled.‘infer’ will attempt to infer fall dst-transition hours based on
orderbool-ndarray where True signifies a DST time, False signifies a
non-DST time (note that this flag is only applicable for ambiguous
times)‘NaT’ will return NaT where there are ambiguous times‘raise’ will raise an AmbiguousTimeError if there are ambiguous times.dayfirstbool, default FalseIf True, parse dates indatawith the day first order.yearfirstbool, default FalseIf True parse dates indatawith the year first order.dtypenumpy.dtype or DatetimeTZDtype or str, default NoneNote that the only NumPy dtype allowed isdatetime64[ns].copybool, default FalseMake a copy of input ndarray.namelabel, default NoneName to be stored in the index.See alsoIndexThe base pandas Index type.TimedeltaIndexIndex of timedelta64 data.PeriodIndexIndex of Period data.to_datetimeConvert argument to datetime.date_rangeCreate a fixed-frequency DatetimeIndex.NotesTo learn more about the frequency strings, please seethis link.Examples>>>idx=pd.DatetimeIndex([""1/1/2020 10:00:00+00:00"",""2/1/2020 11:00:00+00:00""])>>>idxDatetimeIndex(['2020-01-01 10:00:00+00:00', '2020-02-01 11:00:00+00:00'],dtype='datetime64[ns, UTC]', freq=None)AttributesyearThe year of the datetime.monthThe month as January=1, December=12.dayThe day of the datetime.hourThe hours of the datetime.minuteThe minutes of the datetime.secondThe seconds of the datetime.microsecondThe microseconds of the datetime.nanosecondThe nanoseconds of the datetime.dateReturns numpy array of pythondatetime.dateobjects.timeReturns numpy array ofdatetime.timeobjects.timetzReturns numpy array ofdatetime.timeobjects with timezones.dayofyearThe ordinal day of the year.day_of_yearThe ordinal day of the year.dayofweekThe day of the week with Monday=0, Sunday=6.day_of_weekThe day of the week with Monday=0, Sunday=6.weekdayThe day of the week with Monday=0, Sunday=6.quarterThe quarter of the date.tzReturn the timezone.freqstrReturn the frequency object as a string if it's set, otherwise None.is_month_startIndicates whether the date is the first day of the month.is_month_endIndicates whether the date is the last day of the month.is_quarter_startIndicator for whether the date is the first day of a quarter.is_quarter_endIndicator for whether the date is the last day of a quarter.is_year_startIndicate whether the date is the first day of a year.is_year_endIndicate whether the date is the last day of the year.is_leap_yearBoolean indicator if the date belongs to a leap year.inferred_freqTries to return a string representing a frequency generated by infer_freq.weekofyearweekfreqMethodsnormalize(*args, **kwargs)Convert times to midnight.strftime(date_format)Convert to Index using specified date_format.snap([freq])Snap time stamps to nearest occurring frequency.tz_convert(tz)Convert tz-aware Datetime Array/Index from one time zone to another.tz_localize(tz[, ambiguous, nonexistent])Localize tz-naive Datetime Array/Index to tz-aware Datetime Array/Index.round(*args, **kwargs)Perform round operation on the data to the specifiedfreq.floor(*args, **kwargs)Perform floor operation on the data to the specifiedfreq.ceil(*args, **kwargs)Perform ceil operation on the data to the specifiedfreq.to_period(*args, **kwargs)Cast to PeriodArray/PeriodIndex at a particular frequency.to_pydatetime(*args, **kwargs)Return an ndarray ofdatetime.datetimeobjects.to_series([index, name])Create a Series with both index and values equal to the index keys.to_frame([index, name])Create a DataFrame with a column containing the Index.month_name(*args, **kwargs)Return the month names with specified locale.day_name(*args, **kwargs)Return the day names with specified locale.mean(*[, skipna, axis])Return the mean value of the Array.std(*args, **kwargs)Return sample standard deviation over requested axis."
Pandas,Index objects,pandas.DatetimeIndex.year,"pandas.DatetimeIndex.year#propertyDatetimeIndex.year[source]#The year of the datetime.Examples>>>datetime_series=pd.Series(...pd.date_range(""2000-01-01"",periods=3,freq=""Y"")...)>>>datetime_series0   2000-12-311   2001-12-312   2002-12-31dtype: datetime64[ns]>>>datetime_series.dt.year0    20001    20012    2002dtype: int32"
Pandas,Index objects,pandas.DatetimeIndex.month,"pandas.DatetimeIndex.month#propertyDatetimeIndex.month[source]#The month as January=1, December=12.Examples>>>datetime_series=pd.Series(...pd.date_range(""2000-01-01"",periods=3,freq=""M"")...)>>>datetime_series0   2000-01-311   2000-02-292   2000-03-31dtype: datetime64[ns]>>>datetime_series.dt.month0    11    22    3dtype: int32"
Pandas,Index objects,pandas.DatetimeIndex.day,"pandas.DatetimeIndex.day#propertyDatetimeIndex.day[source]#The day of the datetime.Examples>>>datetime_series=pd.Series(...pd.date_range(""2000-01-01"",periods=3,freq=""D"")...)>>>datetime_series0   2000-01-011   2000-01-022   2000-01-03dtype: datetime64[ns]>>>datetime_series.dt.day0    11    22    3dtype: int32"
Pandas,Index objects,pandas.DatetimeIndex.hour,"pandas.DatetimeIndex.hour#propertyDatetimeIndex.hour[source]#The hours of the datetime.Examples>>>datetime_series=pd.Series(...pd.date_range(""2000-01-01"",periods=3,freq=""h"")...)>>>datetime_series0   2000-01-01 00:00:001   2000-01-01 01:00:002   2000-01-01 02:00:00dtype: datetime64[ns]>>>datetime_series.dt.hour0    01    12    2dtype: int32"
Pandas,Index objects,pandas.DatetimeIndex.minute,"pandas.DatetimeIndex.minute#propertyDatetimeIndex.minute[source]#The minutes of the datetime.Examples>>>datetime_series=pd.Series(...pd.date_range(""2000-01-01"",periods=3,freq=""T"")...)>>>datetime_series0   2000-01-01 00:00:001   2000-01-01 00:01:002   2000-01-01 00:02:00dtype: datetime64[ns]>>>datetime_series.dt.minute0    01    12    2dtype: int32"
Pandas,Index objects,pandas.DatetimeIndex.second,"pandas.DatetimeIndex.second#propertyDatetimeIndex.second[source]#The seconds of the datetime.Examples>>>datetime_series=pd.Series(...pd.date_range(""2000-01-01"",periods=3,freq=""s"")...)>>>datetime_series0   2000-01-01 00:00:001   2000-01-01 00:00:012   2000-01-01 00:00:02dtype: datetime64[ns]>>>datetime_series.dt.second0    01    12    2dtype: int32"
Pandas,Index objects,pandas.DatetimeIndex.microsecond,"pandas.DatetimeIndex.microsecond#propertyDatetimeIndex.microsecond[source]#The microseconds of the datetime.Examples>>>datetime_series=pd.Series(...pd.date_range(""2000-01-01"",periods=3,freq=""us"")...)>>>datetime_series0   2000-01-01 00:00:00.0000001   2000-01-01 00:00:00.0000012   2000-01-01 00:00:00.000002dtype: datetime64[ns]>>>datetime_series.dt.microsecond0       01       12       2dtype: int32"
Pandas,Index objects,pandas.DatetimeIndex.nanosecond,"pandas.DatetimeIndex.nanosecond#propertyDatetimeIndex.nanosecond[source]#The nanoseconds of the datetime.Examples>>>datetime_series=pd.Series(...pd.date_range(""2000-01-01"",periods=3,freq=""ns"")...)>>>datetime_series0   2000-01-01 00:00:00.0000000001   2000-01-01 00:00:00.0000000012   2000-01-01 00:00:00.000000002dtype: datetime64[ns]>>>datetime_series.dt.nanosecond0       01       12       2dtype: int32"
Pandas,Index objects,pandas.DatetimeIndex.date,"pandas.DatetimeIndex.date#propertyDatetimeIndex.date[source]#Returns numpy array of pythondatetime.dateobjects.Namely, the date part of Timestamps without time and
timezone information.ExamplesFor Series:>>>s=pd.Series([""1/1/2020 10:00:00+00:00"",""2/1/2020 11:00:00+00:00""])>>>s=pd.to_datetime(s)>>>s0   2020-01-01 10:00:00+00:001   2020-02-01 11:00:00+00:00dtype: datetime64[ns, UTC]>>>s.dt.date0    2020-01-011    2020-02-01dtype: objectFor DatetimeIndex:>>>idx=pd.DatetimeIndex([""1/1/2020 10:00:00+00:00"",...""2/1/2020 11:00:00+00:00""])>>>idx.datearray([datetime.date(2020, 1, 1), datetime.date(2020, 2, 1)], dtype=object)"
Pandas,Index objects,pandas.DatetimeIndex.time,"pandas.DatetimeIndex.time#propertyDatetimeIndex.time[source]#Returns numpy array ofdatetime.timeobjects.The time part of the Timestamps.ExamplesFor Series:>>>s=pd.Series([""1/1/2020 10:00:00+00:00"",""2/1/2020 11:00:00+00:00""])>>>s=pd.to_datetime(s)>>>s0   2020-01-01 10:00:00+00:001   2020-02-01 11:00:00+00:00dtype: datetime64[ns, UTC]>>>s.dt.time0    10:00:001    11:00:00dtype: objectFor DatetimeIndex:>>>idx=pd.DatetimeIndex([""1/1/2020 10:00:00+00:00"",...""2/1/2020 11:00:00+00:00""])>>>idx.timearray([datetime.time(10, 0), datetime.time(11, 0)], dtype=object)"
Pandas,Index objects,pandas.DatetimeIndex.timetz,"pandas.DatetimeIndex.timetz#propertyDatetimeIndex.timetz[source]#Returns numpy array ofdatetime.timeobjects with timezones.The time part of the Timestamps.ExamplesFor Series:>>>s=pd.Series([""1/1/2020 10:00:00+00:00"",""2/1/2020 11:00:00+00:00""])>>>s=pd.to_datetime(s)>>>s0   2020-01-01 10:00:00+00:001   2020-02-01 11:00:00+00:00dtype: datetime64[ns, UTC]>>>s.dt.timetz0    10:00:00+00:001    11:00:00+00:00dtype: objectFor DatetimeIndex:>>>idx=pd.DatetimeIndex([""1/1/2020 10:00:00+00:00"",...""2/1/2020 11:00:00+00:00""])>>>idx.timetzarray([datetime.time(10, 0, tzinfo=datetime.timezone.utc),datetime.time(11, 0, tzinfo=datetime.timezone.utc)], dtype=object)"
Pandas,Index objects,pandas.DatetimeIndex.dayofyear,"pandas.DatetimeIndex.dayofyear#propertyDatetimeIndex.dayofyear[source]#The ordinal day of the year.ExamplesFor Series:>>>s=pd.Series([""1/1/2020 10:00:00+00:00"",""2/1/2020 11:00:00+00:00""])>>>s=pd.to_datetime(s)>>>s0   2020-01-01 10:00:00+00:001   2020-02-01 11:00:00+00:00dtype: datetime64[ns, UTC]>>>s.dt.dayofyear0    11   32dtype: int32For DatetimeIndex:>>>idx=pd.DatetimeIndex([""1/1/2020 10:00:00+00:00"",...""2/1/2020 11:00:00+00:00""])>>>idx.dayofyearIndex([1, 32], dtype='int32')"
Pandas,Index objects,pandas.DatetimeIndex.day_of_year,"pandas.DatetimeIndex.day_of_year#propertyDatetimeIndex.day_of_year[source]#The ordinal day of the year.ExamplesFor Series:>>>s=pd.Series([""1/1/2020 10:00:00+00:00"",""2/1/2020 11:00:00+00:00""])>>>s=pd.to_datetime(s)>>>s0   2020-01-01 10:00:00+00:001   2020-02-01 11:00:00+00:00dtype: datetime64[ns, UTC]>>>s.dt.dayofyear0    11   32dtype: int32For DatetimeIndex:>>>idx=pd.DatetimeIndex([""1/1/2020 10:00:00+00:00"",...""2/1/2020 11:00:00+00:00""])>>>idx.dayofyearIndex([1, 32], dtype='int32')"
Pandas,Index objects,pandas.DatetimeIndex.dayofweek,"pandas.DatetimeIndex.dayofweek#propertyDatetimeIndex.dayofweek[source]#The day of the week with Monday=0, Sunday=6.Return the day of the week. It is assumed the week starts on
Monday, which is denoted by 0 and ends on Sunday which is denoted
by 6. This method is available on both Series with datetime
values (using thedtaccessor) or DatetimeIndex.Returns:Series or IndexContaining integers indicating the day number.See alsoSeries.dt.dayofweekAlias.Series.dt.weekdayAlias.Series.dt.day_nameReturns the name of the day of the week.Examples>>>s=pd.date_range('2016-12-31','2017-01-08',freq='D').to_series()>>>s.dt.dayofweek2016-12-31    52017-01-01    62017-01-02    02017-01-03    12017-01-04    22017-01-05    32017-01-06    42017-01-07    52017-01-08    6Freq: D, dtype: int32"
Pandas,Index objects,pandas.DatetimeIndex.day_of_week,"pandas.DatetimeIndex.day_of_week#propertyDatetimeIndex.day_of_week[source]#The day of the week with Monday=0, Sunday=6.Return the day of the week. It is assumed the week starts on
Monday, which is denoted by 0 and ends on Sunday which is denoted
by 6. This method is available on both Series with datetime
values (using thedtaccessor) or DatetimeIndex.Returns:Series or IndexContaining integers indicating the day number.See alsoSeries.dt.dayofweekAlias.Series.dt.weekdayAlias.Series.dt.day_nameReturns the name of the day of the week.Examples>>>s=pd.date_range('2016-12-31','2017-01-08',freq='D').to_series()>>>s.dt.dayofweek2016-12-31    52017-01-01    62017-01-02    02017-01-03    12017-01-04    22017-01-05    32017-01-06    42017-01-07    52017-01-08    6Freq: D, dtype: int32"
Pandas,Index objects,pandas.DatetimeIndex.weekday,"pandas.DatetimeIndex.weekday#propertyDatetimeIndex.weekday[source]#The day of the week with Monday=0, Sunday=6.Return the day of the week. It is assumed the week starts on
Monday, which is denoted by 0 and ends on Sunday which is denoted
by 6. This method is available on both Series with datetime
values (using thedtaccessor) or DatetimeIndex.Returns:Series or IndexContaining integers indicating the day number.See alsoSeries.dt.dayofweekAlias.Series.dt.weekdayAlias.Series.dt.day_nameReturns the name of the day of the week.Examples>>>s=pd.date_range('2016-12-31','2017-01-08',freq='D').to_series()>>>s.dt.dayofweek2016-12-31    52017-01-01    62017-01-02    02017-01-03    12017-01-04    22017-01-05    32017-01-06    42017-01-07    52017-01-08    6Freq: D, dtype: int32"
Pandas,Index objects,pandas.DatetimeIndex.quarter,"pandas.DatetimeIndex.quarter#propertyDatetimeIndex.quarter[source]#The quarter of the date.ExamplesFor Series:>>>s=pd.Series([""1/1/2020 10:00:00+00:00"",""4/1/2020 11:00:00+00:00""])>>>s=pd.to_datetime(s)>>>s0   2020-01-01 10:00:00+00:001   2020-04-01 11:00:00+00:00dtype: datetime64[ns, UTC]>>>s.dt.quarter0    11    2dtype: int32For DatetimeIndex:>>>idx=pd.DatetimeIndex([""1/1/2020 10:00:00+00:00"",...""2/1/2020 11:00:00+00:00""])>>>idx.quarterIndex([1, 1], dtype='int32')"
Pandas,Index objects,pandas.DatetimeIndex.tz,"pandas.DatetimeIndex.tz#propertyDatetimeIndex.tz[source]#Return the timezone.Returns:datetime.tzinfo, pytz.tzinfo.BaseTZInfo, dateutil.tz.tz.tzfile, or NoneReturns None when the array is tz-naive.ExamplesFor Series:>>>s=pd.Series([""1/1/2020 10:00:00+00:00"",""2/1/2020 11:00:00+00:00""])>>>s=pd.to_datetime(s)>>>s0   2020-01-01 10:00:00+00:001   2020-02-01 11:00:00+00:00dtype: datetime64[ns, UTC]>>>s.dt.tzdatetime.timezone.utcFor DatetimeIndex:>>>idx=pd.DatetimeIndex([""1/1/2020 10:00:00+00:00"",...""2/1/2020 11:00:00+00:00""])>>>idx.tzdatetime.timezone.utc"
Pandas,Index objects,pandas.DatetimeIndex.freq,pandas.DatetimeIndex.freq#propertyDatetimeIndex.freq[source]#
Pandas,Index objects,pandas.DatetimeIndex.freqstr,"pandas.DatetimeIndex.freqstr#propertyDatetimeIndex.freqstr[source]#Return the frequency object as a string if it’s set, otherwise None.ExamplesFor DatetimeIndex:>>>idx=pd.DatetimeIndex([""1/1/2020 10:00:00+00:00""],freq=""D"")>>>idx.freqstr'D'The frequency can be inferred if there are more than 2 points:>>>idx=pd.DatetimeIndex([""2018-01-01"",""2018-01-03"",""2018-01-05""],...freq=""infer"")>>>idx.freqstr'2D'For PeriodIndex:>>>idx=pd.PeriodIndex([""2023-1"",""2023-2"",""2023-3""],freq=""M"")>>>idx.freqstr'M'"
Pandas,Index objects,pandas.DatetimeIndex.is_month_start,"pandas.DatetimeIndex.is_month_start#propertyDatetimeIndex.is_month_start[source]#Indicates whether the date is the first day of the month.Returns:Series or arrayFor Series, returns a Series with boolean values.
For DatetimeIndex, returns a boolean array.See alsois_month_startReturn a boolean indicating whether the date is the first day of the month.is_month_endReturn a boolean indicating whether the date is the last day of the month.ExamplesThis method is available on Series with datetime values under
the.dtaccessor, and directly on DatetimeIndex.>>>s=pd.Series(pd.date_range(""2018-02-27"",periods=3))>>>s0   2018-02-271   2018-02-282   2018-03-01dtype: datetime64[ns]>>>s.dt.is_month_start0    False1    False2    Truedtype: bool>>>s.dt.is_month_end0    False1    True2    Falsedtype: bool>>>idx=pd.date_range(""2018-02-27"",periods=3)>>>idx.is_month_startarray([False, False, True])>>>idx.is_month_endarray([False, True, False])"
Pandas,Index objects,pandas.DatetimeIndex.is_month_end,"pandas.DatetimeIndex.is_month_end#propertyDatetimeIndex.is_month_end[source]#Indicates whether the date is the last day of the month.Returns:Series or arrayFor Series, returns a Series with boolean values.
For DatetimeIndex, returns a boolean array.See alsois_month_startReturn a boolean indicating whether the date is the first day of the month.is_month_endReturn a boolean indicating whether the date is the last day of the month.ExamplesThis method is available on Series with datetime values under
the.dtaccessor, and directly on DatetimeIndex.>>>s=pd.Series(pd.date_range(""2018-02-27"",periods=3))>>>s0   2018-02-271   2018-02-282   2018-03-01dtype: datetime64[ns]>>>s.dt.is_month_start0    False1    False2    Truedtype: bool>>>s.dt.is_month_end0    False1    True2    Falsedtype: bool>>>idx=pd.date_range(""2018-02-27"",periods=3)>>>idx.is_month_startarray([False, False, True])>>>idx.is_month_endarray([False, True, False])"
Pandas,Index objects,pandas.DatetimeIndex.is_quarter_start,"pandas.DatetimeIndex.is_quarter_start#propertyDatetimeIndex.is_quarter_start[source]#Indicator for whether the date is the first day of a quarter.Returns:is_quarter_startSeries or DatetimeIndexThe same type as the original data with boolean values. Series will
have the same name and index. DatetimeIndex will have the same
name.See alsoquarterReturn the quarter of the date.is_quarter_endSimilar property for indicating the quarter end.ExamplesThis method is available on Series with datetime values under
the.dtaccessor, and directly on DatetimeIndex.>>>df=pd.DataFrame({'dates':pd.date_range(""2017-03-30"",...periods=4)})>>>df.assign(quarter=df.dates.dt.quarter,...is_quarter_start=df.dates.dt.is_quarter_start)dates  quarter  is_quarter_start0 2017-03-30        1             False1 2017-03-31        1             False2 2017-04-01        2              True3 2017-04-02        2             False>>>idx=pd.date_range('2017-03-30',periods=4)>>>idxDatetimeIndex(['2017-03-30', '2017-03-31', '2017-04-01', '2017-04-02'],dtype='datetime64[ns]', freq='D')>>>idx.is_quarter_startarray([False, False,  True, False])"
Pandas,Index objects,pandas.DatetimeIndex.is_quarter_end,"pandas.DatetimeIndex.is_quarter_end#propertyDatetimeIndex.is_quarter_end[source]#Indicator for whether the date is the last day of a quarter.Returns:is_quarter_endSeries or DatetimeIndexThe same type as the original data with boolean values. Series will
have the same name and index. DatetimeIndex will have the same
name.See alsoquarterReturn the quarter of the date.is_quarter_startSimilar property indicating the quarter start.ExamplesThis method is available on Series with datetime values under
the.dtaccessor, and directly on DatetimeIndex.>>>df=pd.DataFrame({'dates':pd.date_range(""2017-03-30"",...periods=4)})>>>df.assign(quarter=df.dates.dt.quarter,...is_quarter_end=df.dates.dt.is_quarter_end)dates  quarter    is_quarter_end0 2017-03-30        1             False1 2017-03-31        1              True2 2017-04-01        2             False3 2017-04-02        2             False>>>idx=pd.date_range('2017-03-30',periods=4)>>>idxDatetimeIndex(['2017-03-30', '2017-03-31', '2017-04-01', '2017-04-02'],dtype='datetime64[ns]', freq='D')>>>idx.is_quarter_endarray([False,  True, False, False])"
Pandas,Index objects,pandas.DatetimeIndex.is_year_start,"pandas.DatetimeIndex.is_year_start#propertyDatetimeIndex.is_year_start[source]#Indicate whether the date is the first day of a year.Returns:Series or DatetimeIndexThe same type as the original data with boolean values. Series will
have the same name and index. DatetimeIndex will have the same
name.See alsois_year_endSimilar property indicating the last day of the year.ExamplesThis method is available on Series with datetime values under
the.dtaccessor, and directly on DatetimeIndex.>>>dates=pd.Series(pd.date_range(""2017-12-30"",periods=3))>>>dates0   2017-12-301   2017-12-312   2018-01-01dtype: datetime64[ns]>>>dates.dt.is_year_start0    False1    False2    Truedtype: bool>>>idx=pd.date_range(""2017-12-30"",periods=3)>>>idxDatetimeIndex(['2017-12-30', '2017-12-31', '2018-01-01'],dtype='datetime64[ns]', freq='D')>>>idx.is_year_startarray([False, False,  True])"
Pandas,Index objects,pandas.DatetimeIndex.is_year_end,"pandas.DatetimeIndex.is_year_end#propertyDatetimeIndex.is_year_end[source]#Indicate whether the date is the last day of the year.Returns:Series or DatetimeIndexThe same type as the original data with boolean values. Series will
have the same name and index. DatetimeIndex will have the same
name.See alsois_year_startSimilar property indicating the start of the year.ExamplesThis method is available on Series with datetime values under
the.dtaccessor, and directly on DatetimeIndex.>>>dates=pd.Series(pd.date_range(""2017-12-30"",periods=3))>>>dates0   2017-12-301   2017-12-312   2018-01-01dtype: datetime64[ns]>>>dates.dt.is_year_end0    False1     True2    Falsedtype: bool>>>idx=pd.date_range(""2017-12-30"",periods=3)>>>idxDatetimeIndex(['2017-12-30', '2017-12-31', '2018-01-01'],dtype='datetime64[ns]', freq='D')>>>idx.is_year_endarray([False,  True, False])"
Pandas,Index objects,pandas.DatetimeIndex.is_leap_year,"pandas.DatetimeIndex.is_leap_year#propertyDatetimeIndex.is_leap_year[source]#Boolean indicator if the date belongs to a leap year.A leap year is a year, which has 366 days (instead of 365) including
29th of February as an intercalary day.
Leap years are years which are multiples of four with the exception
of years divisible by 100 but not by 400.Returns:Series or ndarrayBooleans indicating if dates belong to a leap year.ExamplesThis method is available on Series with datetime values under
the.dtaccessor, and directly on DatetimeIndex.>>>idx=pd.date_range(""2012-01-01"",""2015-01-01"",freq=""Y"")>>>idxDatetimeIndex(['2012-12-31', '2013-12-31', '2014-12-31'],dtype='datetime64[ns]', freq='A-DEC')>>>idx.is_leap_yeararray([ True, False, False])>>>dates_series=pd.Series(idx)>>>dates_series0   2012-12-311   2013-12-312   2014-12-31dtype: datetime64[ns]>>>dates_series.dt.is_leap_year0     True1    False2    Falsedtype: bool"
Pandas,Index objects,pandas.DatetimeIndex.inferred_freq,"pandas.DatetimeIndex.inferred_freq#DatetimeIndex.inferred_freq[source]#Tries to return a string representing a frequency generated by infer_freq.Returns None if it can’t autodetect the frequency.ExamplesFor DatetimeIndex:>>>idx=pd.DatetimeIndex([""2018-01-01"",""2018-01-03"",""2018-01-05""])>>>idx.inferred_freq'2D'For TimedeltaIndex:>>>tdelta_idx=pd.to_timedelta([""0 days"",""10 days"",""20 days""])>>>tdelta_idxTimedeltaIndex(['0 days', '10 days', '20 days'],dtype='timedelta64[ns]', freq=None)>>>tdelta_idx.inferred_freq'10D'"
Pandas,Index objects,pandas.DatetimeIndex.indexer_at_time,"pandas.DatetimeIndex.indexer_at_time#DatetimeIndex.indexer_at_time(time,asof=False)[source]#Return index locations of values at particular time of day.Parameters:timedatetime.time or strTime passed in either as object (datetime.time) or as string in
appropriate format (“%H:%M”, “%H%M”, “%I:%M%p”, “%I%M%p”,
“%H:%M:%S”, “%H%M%S”, “%I:%M:%S%p”, “%I%M%S%p”).Returns:np.ndarray[np.intp]See alsoindexer_between_timeGet index locations of values between particular times of day.DataFrame.at_timeSelect values at particular time of day.Examples>>>idx=pd.DatetimeIndex([""1/1/2020 10:00"",""2/1/2020 11:00"",...""3/1/2020 10:00""])>>>idx.indexer_at_time(""10:00"")array([0, 2])"
Pandas,Index objects,pandas.DatetimeIndex.indexer_between_time,"pandas.DatetimeIndex.indexer_between_time#DatetimeIndex.indexer_between_time(start_time,end_time,include_start=True,include_end=True)[source]#Return index locations of values between particular times of day.Parameters:start_time, end_timedatetime.time, strTime passed either as object (datetime.time) or as string in
appropriate format (“%H:%M”, “%H%M”, “%I:%M%p”, “%I%M%p”,
“%H:%M:%S”, “%H%M%S”, “%I:%M:%S%p”,”%I%M%S%p”).include_startbool, default Trueinclude_endbool, default TrueReturns:np.ndarray[np.intp]See alsoindexer_at_timeGet index locations of values at particular time of day.DataFrame.between_timeSelect values between particular times of day.Examples>>>idx=pd.date_range(""2023-01-01"",periods=4,freq=""H"")>>>idxDatetimeIndex(['2023-01-01 00:00:00', '2023-01-01 01:00:00','2023-01-01 02:00:00', '2023-01-01 03:00:00'],dtype='datetime64[ns]', freq='H')>>>idx.indexer_between_time(""00:00"",""2:00"",include_end=False)array([0, 1])"
Pandas,Index objects,pandas.DatetimeIndex.normalize,"pandas.DatetimeIndex.normalize#DatetimeIndex.normalize(*args,**kwargs)[source]#Convert times to midnight.The time component of the date-time is converted to midnight i.e.
00:00:00. This is useful in cases, when the time does not matter.
Length is unaltered. The timezones are unaffected.This method is available on Series with datetime values under
the.dtaccessor, and directly on Datetime Array/Index.Returns:DatetimeArray, DatetimeIndex or SeriesThe same type as the original data. Series will have the same
name and index. DatetimeIndex will have the same name.See alsofloorFloor the datetimes to the specified freq.ceilCeil the datetimes to the specified freq.roundRound the datetimes to the specified freq.Examples>>>idx=pd.date_range(start='2014-08-01 10:00',freq='H',...periods=3,tz='Asia/Calcutta')>>>idxDatetimeIndex(['2014-08-01 10:00:00+05:30','2014-08-01 11:00:00+05:30','2014-08-01 12:00:00+05:30'],dtype='datetime64[ns, Asia/Calcutta]', freq='H')>>>idx.normalize()DatetimeIndex(['2014-08-01 00:00:00+05:30','2014-08-01 00:00:00+05:30','2014-08-01 00:00:00+05:30'],dtype='datetime64[ns, Asia/Calcutta]', freq=None)"
Pandas,Index objects,pandas.DatetimeIndex.strftime,"pandas.DatetimeIndex.strftime#DatetimeIndex.strftime(date_format)[source]#Convert to Index using specified date_format.Return an Index of formatted strings specified by date_format, which
supports the same string format as the python standard library. Details
of the string format can be found inpython string format
doc.Formats supported by the CstrftimeAPI but not by the python string format
doc (such as“%R”,“%r”) are not officially supported and should be
preferably replaced with their supported equivalents (such as“%H:%M”,“%I:%M:%S %p”).Note thatPeriodIndexsupport additional directives, detailed inPeriod.strftime.Parameters:date_formatstrDate format string (e.g. “%Y-%m-%d”).Returns:ndarray[object]NumPy ndarray of formatted strings.See alsoto_datetimeConvert the given argument to datetime.DatetimeIndex.normalizeReturn DatetimeIndex with times to midnight.DatetimeIndex.roundRound the DatetimeIndex to the specified freq.DatetimeIndex.floorFloor the DatetimeIndex to the specified freq.Timestamp.strftimeFormat a single Timestamp.Period.strftimeFormat a single Period.Examples>>>rng=pd.date_range(pd.Timestamp(""2018-03-10 09:00""),...periods=3,freq='s')>>>rng.strftime('%B%d, %Y,%r')Index(['March 10, 2018, 09:00:00 AM', 'March 10, 2018, 09:00:01 AM','March 10, 2018, 09:00:02 AM'],dtype='object')"
Pandas,Index objects,pandas.DatetimeIndex.snap,"pandas.DatetimeIndex.snap#DatetimeIndex.snap(freq='S')[source]#Snap time stamps to nearest occurring frequency.Returns:DatetimeIndexExamples>>>idx=pd.DatetimeIndex(['2023-01-01','2023-01-02',...'2023-02-01','2023-02-02'])>>>idxDatetimeIndex(['2023-01-01', '2023-01-02', '2023-02-01', '2023-02-02'],dtype='datetime64[ns]', freq=None)>>>idx.snap('MS')DatetimeIndex(['2023-01-01', '2023-01-01', '2023-02-01', '2023-02-01'],dtype='datetime64[ns]', freq=None)"
Pandas,Index objects,pandas.DatetimeIndex.tz_convert,"pandas.DatetimeIndex.tz_convert#DatetimeIndex.tz_convert(tz)[source]#Convert tz-aware Datetime Array/Index from one time zone to another.Parameters:tzstr, pytz.timezone, dateutil.tz.tzfile, datetime.tzinfo or NoneTime zone for time. Corresponding timestamps would be converted
to this time zone of the Datetime Array/Index. Atzof None will
convert to UTC and remove the timezone information.Returns:Array or IndexRaises:TypeErrorIf Datetime Array/Index is tz-naive.See alsoDatetimeIndex.tzA timezone that has a variable offset from UTC.DatetimeIndex.tz_localizeLocalize tz-naive DatetimeIndex to a given time zone, or remove timezone from a tz-aware DatetimeIndex.ExamplesWith thetzparameter, we can change the DatetimeIndex
to other time zones:>>>dti=pd.date_range(start='2014-08-01 09:00',...freq='H',periods=3,tz='Europe/Berlin')>>>dtiDatetimeIndex(['2014-08-01 09:00:00+02:00','2014-08-01 10:00:00+02:00','2014-08-01 11:00:00+02:00'],dtype='datetime64[ns, Europe/Berlin]', freq='H')>>>dti.tz_convert('US/Central')DatetimeIndex(['2014-08-01 02:00:00-05:00','2014-08-01 03:00:00-05:00','2014-08-01 04:00:00-05:00'],dtype='datetime64[ns, US/Central]', freq='H')With thetz=None, we can remove the timezone (after converting
to UTC if necessary):>>>dti=pd.date_range(start='2014-08-01 09:00',freq='H',...periods=3,tz='Europe/Berlin')>>>dtiDatetimeIndex(['2014-08-01 09:00:00+02:00','2014-08-01 10:00:00+02:00','2014-08-01 11:00:00+02:00'],dtype='datetime64[ns, Europe/Berlin]', freq='H')>>>dti.tz_convert(None)DatetimeIndex(['2014-08-01 07:00:00','2014-08-01 08:00:00','2014-08-01 09:00:00'],dtype='datetime64[ns]', freq='H')"
Pandas,Index objects,pandas.DatetimeIndex.tz_localize,"pandas.DatetimeIndex.tz_localize#DatetimeIndex.tz_localize(tz,ambiguous='raise',nonexistent='raise')[source]#Localize tz-naive Datetime Array/Index to tz-aware Datetime Array/Index.This method takes a time zone (tz) naive Datetime Array/Index object
and makes this time zone aware. It does not move the time to another
time zone.This method can also be used to do the inverse – to create a time
zone unaware object from an aware object. To that end, passtz=None.Parameters:tzstr, pytz.timezone, dateutil.tz.tzfile, datetime.tzinfo or NoneTime zone to convert timestamps to. PassingNonewill
remove the time zone information preserving local time.ambiguous‘infer’, ‘NaT’, bool array, default ‘raise’When clocks moved backward due to DST, ambiguous times may arise.
For example in Central European Time (UTC+01), when going from
03:00 DST to 02:00 non-DST, 02:30:00 local time occurs both at
00:30:00 UTC and at 01:30:00 UTC. In such a situation, theambiguousparameter dictates how ambiguous times should be
handled.‘infer’ will attempt to infer fall dst-transition hours based on
orderbool-ndarray where True signifies a DST time, False signifies a
non-DST time (note that this flag is only applicable for
ambiguous times)‘NaT’ will return NaT where there are ambiguous times‘raise’ will raise an AmbiguousTimeError if there are ambiguous
times.nonexistent‘shift_forward’, ‘shift_backward, ‘NaT’, timedelta, default ‘raise’A nonexistent time does not exist in a particular timezone
where clocks moved forward due to DST.‘shift_forward’ will shift the nonexistent time forward to the
closest existing time‘shift_backward’ will shift the nonexistent time backward to the
closest existing time‘NaT’ will return NaT where there are nonexistent timestimedelta objects will shift nonexistent times by the timedelta‘raise’ will raise an NonExistentTimeError if there are
nonexistent times.Returns:Same type as selfArray/Index converted to the specified time zone.Raises:TypeErrorIf the Datetime Array/Index is tz-aware and tz is not None.See alsoDatetimeIndex.tz_convertConvert tz-aware DatetimeIndex from one time zone to another.Examples>>>tz_naive=pd.date_range('2018-03-01 09:00',periods=3)>>>tz_naiveDatetimeIndex(['2018-03-01 09:00:00', '2018-03-02 09:00:00','2018-03-03 09:00:00'],dtype='datetime64[ns]', freq='D')Localize DatetimeIndex in US/Eastern time zone:>>>tz_aware=tz_naive.tz_localize(tz='US/Eastern')>>>tz_awareDatetimeIndex(['2018-03-01 09:00:00-05:00','2018-03-02 09:00:00-05:00','2018-03-03 09:00:00-05:00'],dtype='datetime64[ns, US/Eastern]', freq=None)With thetz=None, we can remove the time zone information
while keeping the local time (not converted to UTC):>>>tz_aware.tz_localize(None)DatetimeIndex(['2018-03-01 09:00:00', '2018-03-02 09:00:00','2018-03-03 09:00:00'],dtype='datetime64[ns]', freq=None)Be careful with DST changes. When there is sequential data, pandas can
infer the DST time:>>>s=pd.to_datetime(pd.Series(['2018-10-28 01:30:00',...'2018-10-28 02:00:00',...'2018-10-28 02:30:00',...'2018-10-28 02:00:00',...'2018-10-28 02:30:00',...'2018-10-28 03:00:00',...'2018-10-28 03:30:00']))>>>s.dt.tz_localize('CET',ambiguous='infer')0   2018-10-28 01:30:00+02:001   2018-10-28 02:00:00+02:002   2018-10-28 02:30:00+02:003   2018-10-28 02:00:00+01:004   2018-10-28 02:30:00+01:005   2018-10-28 03:00:00+01:006   2018-10-28 03:30:00+01:00dtype: datetime64[ns, CET]In some cases, inferring the DST is impossible. In such cases, you can
pass an ndarray to the ambiguous parameter to set the DST explicitly>>>s=pd.to_datetime(pd.Series(['2018-10-28 01:20:00',...'2018-10-28 02:36:00',...'2018-10-28 03:46:00']))>>>s.dt.tz_localize('CET',ambiguous=np.array([True,True,False]))0   2018-10-28 01:20:00+02:001   2018-10-28 02:36:00+02:002   2018-10-28 03:46:00+01:00dtype: datetime64[ns, CET]If the DST transition causes nonexistent times, you can shift these
dates forward or backwards with a timedelta object or‘shift_forward’or‘shift_backwards’.>>>s=pd.to_datetime(pd.Series(['2015-03-29 02:30:00',...'2015-03-29 03:30:00']))>>>s.dt.tz_localize('Europe/Warsaw',nonexistent='shift_forward')0   2015-03-29 03:00:00+02:001   2015-03-29 03:30:00+02:00dtype: datetime64[ns, Europe/Warsaw]>>>s.dt.tz_localize('Europe/Warsaw',nonexistent='shift_backward')0   2015-03-29 01:59:59.999999999+01:001   2015-03-29 03:30:00+02:00dtype: datetime64[ns, Europe/Warsaw]>>>s.dt.tz_localize('Europe/Warsaw',nonexistent=pd.Timedelta('1H'))0   2015-03-29 03:30:00+02:001   2015-03-29 03:30:00+02:00dtype: datetime64[ns, Europe/Warsaw]"
Pandas,Index objects,pandas.DatetimeIndex.round,"pandas.DatetimeIndex.round#DatetimeIndex.round(*args,**kwargs)[source]#Perform round operation on the data to the specifiedfreq.Parameters:freqstr or OffsetThe frequency level to round the index to. Must be a fixed
frequency like ‘S’ (second) not ‘ME’ (month end). Seefrequency aliasesfor
a list of possiblefreqvalues.ambiguous‘infer’, bool-ndarray, ‘NaT’, default ‘raise’Only relevant for DatetimeIndex:‘infer’ will attempt to infer fall dst-transition hours based on
orderbool-ndarray where True signifies a DST time, False designates
a non-DST time (note that this flag is only applicable for
ambiguous times)‘NaT’ will return NaT where there are ambiguous times‘raise’ will raise an AmbiguousTimeError if there are ambiguous
times.nonexistent‘shift_forward’, ‘shift_backward’, ‘NaT’, timedelta, default ‘raise’A nonexistent time does not exist in a particular timezone
where clocks moved forward due to DST.‘shift_forward’ will shift the nonexistent time forward to the
closest existing time‘shift_backward’ will shift the nonexistent time backward to the
closest existing time‘NaT’ will return NaT where there are nonexistent timestimedelta objects will shift nonexistent times by the timedelta‘raise’ will raise an NonExistentTimeError if there are
nonexistent times.Returns:DatetimeIndex, TimedeltaIndex, or SeriesIndex of the same type for a DatetimeIndex or TimedeltaIndex,
or a Series with the same index for a Series.Raises:ValueError if thefreqcannot be converted.NotesIf the timestamps have a timezone, rounding will take place relative to the
local (“wall”) time and re-localized to the same timezone. When rounding
near daylight savings time, usenonexistentandambiguousto
control the re-localization behavior.ExamplesDatetimeIndex>>>rng=pd.date_range('1/1/2018 11:59:00',periods=3,freq='min')>>>rngDatetimeIndex(['2018-01-01 11:59:00', '2018-01-01 12:00:00','2018-01-01 12:01:00'],dtype='datetime64[ns]', freq='T')>>>rng.round('H')DatetimeIndex(['2018-01-01 12:00:00', '2018-01-01 12:00:00','2018-01-01 12:00:00'],dtype='datetime64[ns]', freq=None)Series>>>pd.Series(rng).dt.round(""H"")0   2018-01-01 12:00:001   2018-01-01 12:00:002   2018-01-01 12:00:00dtype: datetime64[ns]When rounding near a daylight savings time transition, useambiguousornonexistentto control how the timestamp should be re-localized.>>>rng_tz=pd.DatetimeIndex([""2021-10-31 03:30:00""],tz=""Europe/Amsterdam"")>>>rng_tz.floor(""2H"",ambiguous=False)DatetimeIndex(['2021-10-31 02:00:00+01:00'],dtype='datetime64[ns, Europe/Amsterdam]', freq=None)>>>rng_tz.floor(""2H"",ambiguous=True)DatetimeIndex(['2021-10-31 02:00:00+02:00'],dtype='datetime64[ns, Europe/Amsterdam]', freq=None)"
Pandas,Index objects,pandas.DatetimeIndex.floor,"pandas.DatetimeIndex.floor#DatetimeIndex.floor(*args,**kwargs)[source]#Perform floor operation on the data to the specifiedfreq.Parameters:freqstr or OffsetThe frequency level to floor the index to. Must be a fixed
frequency like ‘S’ (second) not ‘ME’ (month end). Seefrequency aliasesfor
a list of possiblefreqvalues.ambiguous‘infer’, bool-ndarray, ‘NaT’, default ‘raise’Only relevant for DatetimeIndex:‘infer’ will attempt to infer fall dst-transition hours based on
orderbool-ndarray where True signifies a DST time, False designates
a non-DST time (note that this flag is only applicable for
ambiguous times)‘NaT’ will return NaT where there are ambiguous times‘raise’ will raise an AmbiguousTimeError if there are ambiguous
times.nonexistent‘shift_forward’, ‘shift_backward’, ‘NaT’, timedelta, default ‘raise’A nonexistent time does not exist in a particular timezone
where clocks moved forward due to DST.‘shift_forward’ will shift the nonexistent time forward to the
closest existing time‘shift_backward’ will shift the nonexistent time backward to the
closest existing time‘NaT’ will return NaT where there are nonexistent timestimedelta objects will shift nonexistent times by the timedelta‘raise’ will raise an NonExistentTimeError if there are
nonexistent times.Returns:DatetimeIndex, TimedeltaIndex, or SeriesIndex of the same type for a DatetimeIndex or TimedeltaIndex,
or a Series with the same index for a Series.Raises:ValueError if thefreqcannot be converted.NotesIf the timestamps have a timezone, flooring will take place relative to the
local (“wall”) time and re-localized to the same timezone. When flooring
near daylight savings time, usenonexistentandambiguousto
control the re-localization behavior.ExamplesDatetimeIndex>>>rng=pd.date_range('1/1/2018 11:59:00',periods=3,freq='min')>>>rngDatetimeIndex(['2018-01-01 11:59:00', '2018-01-01 12:00:00','2018-01-01 12:01:00'],dtype='datetime64[ns]', freq='T')>>>rng.floor('H')DatetimeIndex(['2018-01-01 11:00:00', '2018-01-01 12:00:00','2018-01-01 12:00:00'],dtype='datetime64[ns]', freq=None)Series>>>pd.Series(rng).dt.floor(""H"")0   2018-01-01 11:00:001   2018-01-01 12:00:002   2018-01-01 12:00:00dtype: datetime64[ns]When rounding near a daylight savings time transition, useambiguousornonexistentto control how the timestamp should be re-localized.>>>rng_tz=pd.DatetimeIndex([""2021-10-31 03:30:00""],tz=""Europe/Amsterdam"")>>>rng_tz.floor(""2H"",ambiguous=False)DatetimeIndex(['2021-10-31 02:00:00+01:00'],dtype='datetime64[ns, Europe/Amsterdam]', freq=None)>>>rng_tz.floor(""2H"",ambiguous=True)DatetimeIndex(['2021-10-31 02:00:00+02:00'],dtype='datetime64[ns, Europe/Amsterdam]', freq=None)"
Pandas,Index objects,pandas.DatetimeIndex.ceil,"pandas.DatetimeIndex.ceil#DatetimeIndex.ceil(*args,**kwargs)[source]#Perform ceil operation on the data to the specifiedfreq.Parameters:freqstr or OffsetThe frequency level to ceil the index to. Must be a fixed
frequency like ‘S’ (second) not ‘ME’ (month end). Seefrequency aliasesfor
a list of possiblefreqvalues.ambiguous‘infer’, bool-ndarray, ‘NaT’, default ‘raise’Only relevant for DatetimeIndex:‘infer’ will attempt to infer fall dst-transition hours based on
orderbool-ndarray where True signifies a DST time, False designates
a non-DST time (note that this flag is only applicable for
ambiguous times)‘NaT’ will return NaT where there are ambiguous times‘raise’ will raise an AmbiguousTimeError if there are ambiguous
times.nonexistent‘shift_forward’, ‘shift_backward’, ‘NaT’, timedelta, default ‘raise’A nonexistent time does not exist in a particular timezone
where clocks moved forward due to DST.‘shift_forward’ will shift the nonexistent time forward to the
closest existing time‘shift_backward’ will shift the nonexistent time backward to the
closest existing time‘NaT’ will return NaT where there are nonexistent timestimedelta objects will shift nonexistent times by the timedelta‘raise’ will raise an NonExistentTimeError if there are
nonexistent times.Returns:DatetimeIndex, TimedeltaIndex, or SeriesIndex of the same type for a DatetimeIndex or TimedeltaIndex,
or a Series with the same index for a Series.Raises:ValueError if thefreqcannot be converted.NotesIf the timestamps have a timezone, ceiling will take place relative to the
local (“wall”) time and re-localized to the same timezone. When ceiling
near daylight savings time, usenonexistentandambiguousto
control the re-localization behavior.ExamplesDatetimeIndex>>>rng=pd.date_range('1/1/2018 11:59:00',periods=3,freq='min')>>>rngDatetimeIndex(['2018-01-01 11:59:00', '2018-01-01 12:00:00','2018-01-01 12:01:00'],dtype='datetime64[ns]', freq='T')>>>rng.ceil('H')DatetimeIndex(['2018-01-01 12:00:00', '2018-01-01 12:00:00','2018-01-01 13:00:00'],dtype='datetime64[ns]', freq=None)Series>>>pd.Series(rng).dt.ceil(""H"")0   2018-01-01 12:00:001   2018-01-01 12:00:002   2018-01-01 13:00:00dtype: datetime64[ns]When rounding near a daylight savings time transition, useambiguousornonexistentto control how the timestamp should be re-localized.>>>rng_tz=pd.DatetimeIndex([""2021-10-31 01:30:00""],tz=""Europe/Amsterdam"")>>>rng_tz.ceil(""H"",ambiguous=False)DatetimeIndex(['2021-10-31 02:00:00+01:00'],dtype='datetime64[ns, Europe/Amsterdam]', freq=None)>>>rng_tz.ceil(""H"",ambiguous=True)DatetimeIndex(['2021-10-31 02:00:00+02:00'],dtype='datetime64[ns, Europe/Amsterdam]', freq=None)"
Pandas,Index objects,pandas.DatetimeIndex.month_name,"pandas.DatetimeIndex.month_name#DatetimeIndex.month_name(*args,**kwargs)[source]#Return the month names with specified locale.Parameters:localestr, optionalLocale determining the language in which to return the month name.
Default is English locale ('en_US.utf8'). Use the commandlocale-aon your terminal on Unix systems to find your locale
language code.Returns:Series or IndexSeries or Index of month names.Examples>>>s=pd.Series(pd.date_range(start='2018-01',freq='M',periods=3))>>>s0   2018-01-311   2018-02-282   2018-03-31dtype: datetime64[ns]>>>s.dt.month_name()0     January1    February2       Marchdtype: object>>>idx=pd.date_range(start='2018-01',freq='M',periods=3)>>>idxDatetimeIndex(['2018-01-31', '2018-02-28', '2018-03-31'],dtype='datetime64[ns]', freq='M')>>>idx.month_name()Index(['January', 'February', 'March'], dtype='object')Using thelocaleparameter you can set a different locale language,
for example:idx.month_name(locale='pt_BR.utf8')will return month
names in Brazilian Portuguese language.>>>idx=pd.date_range(start='2018-01',freq='M',periods=3)>>>idxDatetimeIndex(['2018-01-31', '2018-02-28', '2018-03-31'],dtype='datetime64[ns]', freq='M')>>>idx.month_name(locale='pt_BR.utf8')Index(['Janeiro', 'Fevereiro', 'Março'], dtype='object')"
Pandas,Index objects,pandas.DatetimeIndex.day_name,"pandas.DatetimeIndex.day_name#DatetimeIndex.day_name(*args,**kwargs)[source]#Return the day names with specified locale.Parameters:localestr, optionalLocale determining the language in which to return the day name.
Default is English locale ('en_US.utf8'). Use the commandlocale-aon your terminal on Unix systems to find your locale
language code.Returns:Series or IndexSeries or Index of day names.Examples>>>s=pd.Series(pd.date_range(start='2018-01-01',freq='D',periods=3))>>>s0   2018-01-011   2018-01-022   2018-01-03dtype: datetime64[ns]>>>s.dt.day_name()0       Monday1      Tuesday2    Wednesdaydtype: object>>>idx=pd.date_range(start='2018-01-01',freq='D',periods=3)>>>idxDatetimeIndex(['2018-01-01', '2018-01-02', '2018-01-03'],dtype='datetime64[ns]', freq='D')>>>idx.day_name()Index(['Monday', 'Tuesday', 'Wednesday'], dtype='object')Using thelocaleparameter you can set a different locale language,
for example:idx.day_name(locale='pt_BR.utf8')will return day
names in Brazilian Portuguese language.>>>idx=pd.date_range(start='2018-01-01',freq='D',periods=3)>>>idxDatetimeIndex(['2018-01-01', '2018-01-02', '2018-01-03'],dtype='datetime64[ns]', freq='D')>>>idx.day_name(locale='pt_BR.utf8')Index(['Segunda', 'Terça', 'Quarta'], dtype='object')"
Pandas,Index objects,pandas.DatetimeIndex.as_unit,"pandas.DatetimeIndex.as_unit#DatetimeIndex.as_unit(*args,**kwargs)[source]#Convert to a dtype with the given unit resolution.Parameters:unit{‘s’, ‘ms’, ‘us’, ‘ns’}Returns:same type as selfExamplesForpandas.DatetimeIndex:>>>idx=pd.DatetimeIndex(['2020-01-02 01:02:03.004005006'])>>>idxDatetimeIndex(['2020-01-02 01:02:03.004005006'],dtype='datetime64[ns]', freq=None)>>>idx.as_unit('s')DatetimeIndex(['2020-01-02 01:02:03'], dtype='datetime64[s]', freq=None)Forpandas.TimedeltaIndex:>>>tdelta_idx=pd.to_timedelta(['1 day 3 min 2 us 42 ns'])>>>tdelta_idxTimedeltaIndex(['1 days 00:03:00.000002042'],dtype='timedelta64[ns]', freq=None)>>>tdelta_idx.as_unit('s')TimedeltaIndex(['1 days 00:03:00'], dtype='timedelta64[s]', freq=None)"
Pandas,Index objects,pandas.DatetimeIndex.to_period,"pandas.DatetimeIndex.to_period#DatetimeIndex.to_period(*args,**kwargs)[source]#Cast to PeriodArray/PeriodIndex at a particular frequency.Converts DatetimeArray/Index to PeriodArray/PeriodIndex.Parameters:freqstr or Period, optionalOne of pandas’period aliasesor an Period object. Will be inferred by default.Returns:PeriodArray/PeriodIndexRaises:ValueErrorWhen converting a DatetimeArray/Index with non-regular values,
so that a frequency cannot be inferred.See alsoPeriodIndexImmutable ndarray holding ordinal values.DatetimeIndex.to_pydatetimeReturn DatetimeIndex as object.Examples>>>df=pd.DataFrame({""y"":[1,2,3]},...index=pd.to_datetime([""2000-03-31 00:00:00"",...""2000-05-31 00:00:00"",...""2000-08-31 00:00:00""]))>>>df.index.to_period(""M"")PeriodIndex(['2000-03', '2000-05', '2000-08'],dtype='period[M]')Infer the daily frequency>>>idx=pd.date_range(""2017-01-01"",periods=2)>>>idx.to_period()PeriodIndex(['2017-01-01', '2017-01-02'],dtype='period[D]')"
Pandas,Index objects,pandas.DatetimeIndex.to_pydatetime,"pandas.DatetimeIndex.to_pydatetime#DatetimeIndex.to_pydatetime(*args,**kwargs)[source]#Return an ndarray ofdatetime.datetimeobjects.Returns:numpy.ndarrayExamples>>>idx=pd.date_range('2018-02-27',periods=3)>>>idx.to_pydatetime()array([datetime.datetime(2018, 2, 27, 0, 0),datetime.datetime(2018, 2, 28, 0, 0),datetime.datetime(2018, 3, 1, 0, 0)], dtype=object)"
Pandas,Index objects,pandas.DatetimeIndex.to_series,"pandas.DatetimeIndex.to_series#DatetimeIndex.to_series(index=None,name=None)[source]#Create a Series with both index and values equal to the index keys.Useful with map for returning an indexer based on an index.Parameters:indexIndex, optionalIndex of resulting Series. If None, defaults to original index.namestr, optionalName of resulting Series. If None, defaults to name of original
index.Returns:SeriesThe dtype will be based on the type of the Index values.See alsoIndex.to_frameConvert an Index to a DataFrame.Series.to_frameConvert Series to DataFrame.Examples>>>idx=pd.Index(['Ant','Bear','Cow'],name='animal')By default, the original index and original name is reused.>>>idx.to_series()animalAnt      AntBear    BearCow      CowName: animal, dtype: objectTo enforce a new index, specify new labels toindex:>>>idx.to_series(index=[0,1,2])0     Ant1    Bear2     CowName: animal, dtype: objectTo override the name of the resulting column, specifyname:>>>idx.to_series(name='zoo')animalAnt      AntBear    BearCow      CowName: zoo, dtype: object"
Pandas,Index objects,pandas.DatetimeIndex.to_frame,"pandas.DatetimeIndex.to_frame#DatetimeIndex.to_frame(index=True,name=_NoDefault.no_default)[source]#Create a DataFrame with a column containing the Index.Parameters:indexbool, default TrueSet the index of the returned DataFrame as the original Index.nameobject, defaults to index.nameThe passed name should substitute for the index name (if it has
one).Returns:DataFrameDataFrame containing the original Index data.See alsoIndex.to_seriesConvert an Index to a Series.Series.to_frameConvert Series to DataFrame.Examples>>>idx=pd.Index(['Ant','Bear','Cow'],name='animal')>>>idx.to_frame()animalanimalAnt       AntBear     BearCow       CowBy default, the original Index is reused. To enforce a new Index:>>>idx.to_frame(index=False)animal0   Ant1  Bear2   CowTo override the name of the resulting column, specifyname:>>>idx.to_frame(index=False,name='zoo')zoo0   Ant1  Bear2   Cow"
Pandas,Index objects,pandas.DatetimeIndex.mean,"pandas.DatetimeIndex.mean#DatetimeIndex.mean(*,skipna=True,axis=0)[source]#Return the mean value of the Array.Parameters:skipnabool, default TrueWhether to ignore any NaT elements.axisint, optional, default 0Returns:scalarTimestamp or Timedelta.See alsonumpy.ndarray.meanReturns the average of array elements along a given axis.Series.meanReturn the mean value in a Series.Notesmean is only defined for Datetime and Timedelta dtypes, not for Period.ExamplesForpandas.DatetimeIndex:>>>idx=pd.date_range('2001-01-01 00:00',periods=3)>>>idxDatetimeIndex(['2001-01-01', '2001-01-02', '2001-01-03'],dtype='datetime64[ns]', freq='D')>>>idx.mean()Timestamp('2001-01-02 00:00:00')Forpandas.TimedeltaIndex:>>>tdelta_idx=pd.to_timedelta([1,2,3],unit='D')>>>tdelta_idxTimedeltaIndex(['1 days', '2 days', '3 days'],dtype='timedelta64[ns]', freq=None)>>>tdelta_idx.mean()Timedelta('2 days 00:00:00')"
Pandas,Index objects,pandas.DatetimeIndex.std,"pandas.DatetimeIndex.std#DatetimeIndex.std(*args,**kwargs)[source]#Return sample standard deviation over requested axis.Normalized byN-1by default. This can be changed usingddof.Parameters:axisint, optionalAxis for the function to be applied on. Forpandas.Seriesthis parameter is unused and defaults toNone.ddofint, default 1Degrees of Freedom. The divisor used in calculations isN - ddof,
whereNrepresents the number of elements.skipnabool, default TrueExclude NA/null values. If an entire row/column isNA, the result
will beNA.Returns:TimedeltaSee alsonumpy.ndarray.stdReturns the standard deviation of the array elements along given axis.Series.stdReturn sample standard deviation over requested axis.ExamplesForpandas.DatetimeIndex:>>>idx=pd.date_range('2001-01-01 00:00',periods=3)>>>idxDatetimeIndex(['2001-01-01', '2001-01-02', '2001-01-03'],dtype='datetime64[ns]', freq='D')>>>idx.std()Timedelta('1 days 00:00:00')"
Pandas,Index objects,pandas.TimedeltaIndex,"pandas.TimedeltaIndex#classpandas.TimedeltaIndex(data=None,unit=None,freq=_NoDefault.no_default,closed=_NoDefault.no_default,dtype=None,copy=False,name=None)[source]#Immutable Index of timedelta64 data.Represented internally as int64, and scalars returned Timedelta objects.Parameters:dataarray-like (1-dimensional), optionalOptional timedelta-like data to construct index with.unit{‘D’, ‘h’, ‘m’, ‘s’, ‘ms’, ‘us’, ‘ns’}, optionalThe unit ofdata.freqstr or pandas offset object, optionalOne of pandas date offset strings or corresponding objects. The string'infer'can be passed in order to set the frequency of the index as
the inferred frequency upon creation.dtypenumpy.dtype or str, default NoneValidnumpydtypes aretimedelta64[ns],timedelta64[us],timedelta64[ms], andtimedelta64[s].copyboolMake a copy of input array.nameobjectName to be stored in the index.See alsoIndexThe base pandas Index type.TimedeltaRepresents a duration between two dates or times.DatetimeIndexIndex of datetime64 data.PeriodIndexIndex of Period data.timedelta_rangeCreate a fixed-frequency TimedeltaIndex.NotesTo learn more about the frequency strings, please seethis link.Examples>>>pd.TimedeltaIndex(['0 days','1 days','2 days','3 days','4 days'])TimedeltaIndex(['0 days', '1 days', '2 days', '3 days', '4 days'],dtype='timedelta64[ns]', freq=None)>>>pd.TimedeltaIndex([1,2,4,8],unit='D')TimedeltaIndex(['1 days', '2 days', '4 days', '8 days'],dtype='timedelta64[ns]', freq=None)We can also let pandas infer the frequency when possible.>>>pd.TimedeltaIndex(range(5),unit='D',freq='infer')TimedeltaIndex(['0 days', '1 days', '2 days', '3 days', '4 days'],dtype='timedelta64[ns]', freq='D')AttributesdaysNumber of days for each element.secondsNumber of seconds (>= 0 and less than 1 day) for each element.microsecondsNumber of microseconds (>= 0 and less than 1 second) for each element.nanosecondsNumber of nanoseconds (>= 0 and less than 1 microsecond) for each element.componentsReturn a DataFrame of the individual resolution components of the Timedeltas.inferred_freqTries to return a string representing a frequency generated by infer_freq.Methodsto_pytimedelta(*args, **kwargs)Return an ndarray of datetime.timedelta objects.to_series([index, name])Create a Series with both index and values equal to the index keys.round(*args, **kwargs)Perform round operation on the data to the specifiedfreq.floor(*args, **kwargs)Perform floor operation on the data to the specifiedfreq.ceil(*args, **kwargs)Perform ceil operation on the data to the specifiedfreq.to_frame([index, name])Create a DataFrame with a column containing the Index.mean(*[, skipna, axis])Return the mean value of the Array."
Pandas,Index objects,pandas.TimedeltaIndex.days,"pandas.TimedeltaIndex.days#propertyTimedeltaIndex.days[source]#Number of days for each element.ExamplesFor Series:>>>ser=pd.Series(pd.to_timedelta([1,2,3],unit='d'))>>>ser0   1 days1   2 days2   3 daysdtype: timedelta64[ns]>>>ser.dt.days0    11    22    3dtype: int64For TimedeltaIndex:>>>tdelta_idx=pd.to_timedelta([""0 days"",""10 days"",""20 days""])>>>tdelta_idxTimedeltaIndex(['0 days', '10 days', '20 days'],dtype='timedelta64[ns]', freq=None)>>>tdelta_idx.daysIndex([0, 10, 20], dtype='int64')"
Pandas,Index objects,pandas.TimedeltaIndex.seconds,"pandas.TimedeltaIndex.seconds#propertyTimedeltaIndex.seconds[source]#Number of seconds (>= 0 and less than 1 day) for each element.ExamplesFor Series:>>>ser=pd.Series(pd.to_timedelta([1,2,3],unit='S'))>>>ser0   0 days 00:00:011   0 days 00:00:022   0 days 00:00:03dtype: timedelta64[ns]>>>ser.dt.seconds0    11    22    3dtype: int32For TimedeltaIndex:>>>tdelta_idx=pd.to_timedelta([1,2,3],unit='S')>>>tdelta_idxTimedeltaIndex(['0 days 00:00:01', '0 days 00:00:02', '0 days 00:00:03'],dtype='timedelta64[ns]', freq=None)>>>tdelta_idx.secondsIndex([1, 2, 3], dtype='int32')"
Pandas,Index objects,pandas.TimedeltaIndex.microseconds,"pandas.TimedeltaIndex.microseconds#propertyTimedeltaIndex.microseconds[source]#Number of microseconds (>= 0 and less than 1 second) for each element.ExamplesFor Series:>>>ser=pd.Series(pd.to_timedelta([1,2,3],unit='U'))>>>ser0   0 days 00:00:00.0000011   0 days 00:00:00.0000022   0 days 00:00:00.000003dtype: timedelta64[ns]>>>ser.dt.microseconds0    11    22    3dtype: int32For TimedeltaIndex:>>>tdelta_idx=pd.to_timedelta([1,2,3],unit='U')>>>tdelta_idxTimedeltaIndex(['0 days 00:00:00.000001', '0 days 00:00:00.000002','0 days 00:00:00.000003'],dtype='timedelta64[ns]', freq=None)>>>tdelta_idx.microsecondsIndex([1, 2, 3], dtype='int32')"
Pandas,Index objects,pandas.TimedeltaIndex.nanoseconds,"pandas.TimedeltaIndex.nanoseconds#propertyTimedeltaIndex.nanoseconds[source]#Number of nanoseconds (>= 0 and less than 1 microsecond) for each element.ExamplesFor Series:>>>ser=pd.Series(pd.to_timedelta([1,2,3],unit='N'))>>>ser0   0 days 00:00:00.0000000011   0 days 00:00:00.0000000022   0 days 00:00:00.000000003dtype: timedelta64[ns]>>>ser.dt.nanoseconds0    11    22    3dtype: int32For TimedeltaIndex:>>>tdelta_idx=pd.to_timedelta([1,2,3],unit='N')>>>tdelta_idxTimedeltaIndex(['0 days 00:00:00.000000001', '0 days 00:00:00.000000002','0 days 00:00:00.000000003'],dtype='timedelta64[ns]', freq=None)>>>tdelta_idx.nanosecondsIndex([1, 2, 3], dtype='int32')"
Pandas,Index objects,pandas.TimedeltaIndex.components,"pandas.TimedeltaIndex.components#propertyTimedeltaIndex.components[source]#Return a DataFrame of the individual resolution components of the Timedeltas.The components (days, hours, minutes seconds, milliseconds, microseconds,
nanoseconds) are returned as columns in a DataFrame.Returns:DataFrameExamples>>>tdelta_idx=pd.to_timedelta(['1 day 3 min 2 us 42 ns'])>>>tdelta_idxTimedeltaIndex(['1 days 00:03:00.000002042'],dtype='timedelta64[ns]', freq=None)>>>tdelta_idx.componentsdays  hours  minutes  seconds  milliseconds  microseconds  nanoseconds0     1      0        3        0             0             2           42"
Pandas,Index objects,pandas.TimedeltaIndex.inferred_freq,"pandas.TimedeltaIndex.inferred_freq#TimedeltaIndex.inferred_freq[source]#Tries to return a string representing a frequency generated by infer_freq.Returns None if it can’t autodetect the frequency.ExamplesFor DatetimeIndex:>>>idx=pd.DatetimeIndex([""2018-01-01"",""2018-01-03"",""2018-01-05""])>>>idx.inferred_freq'2D'For TimedeltaIndex:>>>tdelta_idx=pd.to_timedelta([""0 days"",""10 days"",""20 days""])>>>tdelta_idxTimedeltaIndex(['0 days', '10 days', '20 days'],dtype='timedelta64[ns]', freq=None)>>>tdelta_idx.inferred_freq'10D'"
Pandas,Index objects,pandas.TimedeltaIndex.as_unit,"pandas.TimedeltaIndex.as_unit#TimedeltaIndex.as_unit(unit)[source]#Convert to a dtype with the given unit resolution.Parameters:unit{‘s’, ‘ms’, ‘us’, ‘ns’}Returns:same type as selfExamplesForpandas.DatetimeIndex:>>>idx=pd.DatetimeIndex(['2020-01-02 01:02:03.004005006'])>>>idxDatetimeIndex(['2020-01-02 01:02:03.004005006'],dtype='datetime64[ns]', freq=None)>>>idx.as_unit('s')DatetimeIndex(['2020-01-02 01:02:03'], dtype='datetime64[s]', freq=None)Forpandas.TimedeltaIndex:>>>tdelta_idx=pd.to_timedelta(['1 day 3 min 2 us 42 ns'])>>>tdelta_idxTimedeltaIndex(['1 days 00:03:00.000002042'],dtype='timedelta64[ns]', freq=None)>>>tdelta_idx.as_unit('s')TimedeltaIndex(['1 days 00:03:00'], dtype='timedelta64[s]', freq=None)"
Pandas,Index objects,pandas.TimedeltaIndex.to_pytimedelta,"pandas.TimedeltaIndex.to_pytimedelta#TimedeltaIndex.to_pytimedelta(*args,**kwargs)[source]#Return an ndarray of datetime.timedelta objects.Returns:numpy.ndarrayExamples>>>tdelta_idx=pd.to_timedelta([1,2,3],unit='D')>>>tdelta_idxTimedeltaIndex(['1 days', '2 days', '3 days'],dtype='timedelta64[ns]', freq=None)>>>tdelta_idx.to_pytimedelta()array([datetime.timedelta(days=1), datetime.timedelta(days=2),datetime.timedelta(days=3)], dtype=object)"
Pandas,Index objects,pandas.TimedeltaIndex.to_series,"pandas.TimedeltaIndex.to_series#TimedeltaIndex.to_series(index=None,name=None)[source]#Create a Series with both index and values equal to the index keys.Useful with map for returning an indexer based on an index.Parameters:indexIndex, optionalIndex of resulting Series. If None, defaults to original index.namestr, optionalName of resulting Series. If None, defaults to name of original
index.Returns:SeriesThe dtype will be based on the type of the Index values.See alsoIndex.to_frameConvert an Index to a DataFrame.Series.to_frameConvert Series to DataFrame.Examples>>>idx=pd.Index(['Ant','Bear','Cow'],name='animal')By default, the original index and original name is reused.>>>idx.to_series()animalAnt      AntBear    BearCow      CowName: animal, dtype: objectTo enforce a new index, specify new labels toindex:>>>idx.to_series(index=[0,1,2])0     Ant1    Bear2     CowName: animal, dtype: objectTo override the name of the resulting column, specifyname:>>>idx.to_series(name='zoo')animalAnt      AntBear    BearCow      CowName: zoo, dtype: object"
Pandas,Index objects,pandas.TimedeltaIndex.round,"pandas.TimedeltaIndex.round#TimedeltaIndex.round(*args,**kwargs)[source]#Perform round operation on the data to the specifiedfreq.Parameters:freqstr or OffsetThe frequency level to round the index to. Must be a fixed
frequency like ‘S’ (second) not ‘ME’ (month end). Seefrequency aliasesfor
a list of possiblefreqvalues.ambiguous‘infer’, bool-ndarray, ‘NaT’, default ‘raise’Only relevant for DatetimeIndex:‘infer’ will attempt to infer fall dst-transition hours based on
orderbool-ndarray where True signifies a DST time, False designates
a non-DST time (note that this flag is only applicable for
ambiguous times)‘NaT’ will return NaT where there are ambiguous times‘raise’ will raise an AmbiguousTimeError if there are ambiguous
times.nonexistent‘shift_forward’, ‘shift_backward’, ‘NaT’, timedelta, default ‘raise’A nonexistent time does not exist in a particular timezone
where clocks moved forward due to DST.‘shift_forward’ will shift the nonexistent time forward to the
closest existing time‘shift_backward’ will shift the nonexistent time backward to the
closest existing time‘NaT’ will return NaT where there are nonexistent timestimedelta objects will shift nonexistent times by the timedelta‘raise’ will raise an NonExistentTimeError if there are
nonexistent times.Returns:DatetimeIndex, TimedeltaIndex, or SeriesIndex of the same type for a DatetimeIndex or TimedeltaIndex,
or a Series with the same index for a Series.Raises:ValueError if thefreqcannot be converted.NotesIf the timestamps have a timezone, rounding will take place relative to the
local (“wall”) time and re-localized to the same timezone. When rounding
near daylight savings time, usenonexistentandambiguousto
control the re-localization behavior.ExamplesDatetimeIndex>>>rng=pd.date_range('1/1/2018 11:59:00',periods=3,freq='min')>>>rngDatetimeIndex(['2018-01-01 11:59:00', '2018-01-01 12:00:00','2018-01-01 12:01:00'],dtype='datetime64[ns]', freq='T')>>>rng.round('H')DatetimeIndex(['2018-01-01 12:00:00', '2018-01-01 12:00:00','2018-01-01 12:00:00'],dtype='datetime64[ns]', freq=None)Series>>>pd.Series(rng).dt.round(""H"")0   2018-01-01 12:00:001   2018-01-01 12:00:002   2018-01-01 12:00:00dtype: datetime64[ns]When rounding near a daylight savings time transition, useambiguousornonexistentto control how the timestamp should be re-localized.>>>rng_tz=pd.DatetimeIndex([""2021-10-31 03:30:00""],tz=""Europe/Amsterdam"")>>>rng_tz.floor(""2H"",ambiguous=False)DatetimeIndex(['2021-10-31 02:00:00+01:00'],dtype='datetime64[ns, Europe/Amsterdam]', freq=None)>>>rng_tz.floor(""2H"",ambiguous=True)DatetimeIndex(['2021-10-31 02:00:00+02:00'],dtype='datetime64[ns, Europe/Amsterdam]', freq=None)"
Pandas,Index objects,pandas.TimedeltaIndex.floor,"pandas.TimedeltaIndex.floor#TimedeltaIndex.floor(*args,**kwargs)[source]#Perform floor operation on the data to the specifiedfreq.Parameters:freqstr or OffsetThe frequency level to floor the index to. Must be a fixed
frequency like ‘S’ (second) not ‘ME’ (month end). Seefrequency aliasesfor
a list of possiblefreqvalues.ambiguous‘infer’, bool-ndarray, ‘NaT’, default ‘raise’Only relevant for DatetimeIndex:‘infer’ will attempt to infer fall dst-transition hours based on
orderbool-ndarray where True signifies a DST time, False designates
a non-DST time (note that this flag is only applicable for
ambiguous times)‘NaT’ will return NaT where there are ambiguous times‘raise’ will raise an AmbiguousTimeError if there are ambiguous
times.nonexistent‘shift_forward’, ‘shift_backward’, ‘NaT’, timedelta, default ‘raise’A nonexistent time does not exist in a particular timezone
where clocks moved forward due to DST.‘shift_forward’ will shift the nonexistent time forward to the
closest existing time‘shift_backward’ will shift the nonexistent time backward to the
closest existing time‘NaT’ will return NaT where there are nonexistent timestimedelta objects will shift nonexistent times by the timedelta‘raise’ will raise an NonExistentTimeError if there are
nonexistent times.Returns:DatetimeIndex, TimedeltaIndex, or SeriesIndex of the same type for a DatetimeIndex or TimedeltaIndex,
or a Series with the same index for a Series.Raises:ValueError if thefreqcannot be converted.NotesIf the timestamps have a timezone, flooring will take place relative to the
local (“wall”) time and re-localized to the same timezone. When flooring
near daylight savings time, usenonexistentandambiguousto
control the re-localization behavior.ExamplesDatetimeIndex>>>rng=pd.date_range('1/1/2018 11:59:00',periods=3,freq='min')>>>rngDatetimeIndex(['2018-01-01 11:59:00', '2018-01-01 12:00:00','2018-01-01 12:01:00'],dtype='datetime64[ns]', freq='T')>>>rng.floor('H')DatetimeIndex(['2018-01-01 11:00:00', '2018-01-01 12:00:00','2018-01-01 12:00:00'],dtype='datetime64[ns]', freq=None)Series>>>pd.Series(rng).dt.floor(""H"")0   2018-01-01 11:00:001   2018-01-01 12:00:002   2018-01-01 12:00:00dtype: datetime64[ns]When rounding near a daylight savings time transition, useambiguousornonexistentto control how the timestamp should be re-localized.>>>rng_tz=pd.DatetimeIndex([""2021-10-31 03:30:00""],tz=""Europe/Amsterdam"")>>>rng_tz.floor(""2H"",ambiguous=False)DatetimeIndex(['2021-10-31 02:00:00+01:00'],dtype='datetime64[ns, Europe/Amsterdam]', freq=None)>>>rng_tz.floor(""2H"",ambiguous=True)DatetimeIndex(['2021-10-31 02:00:00+02:00'],dtype='datetime64[ns, Europe/Amsterdam]', freq=None)"
Pandas,Index objects,pandas.TimedeltaIndex.ceil,"pandas.TimedeltaIndex.ceil#TimedeltaIndex.ceil(*args,**kwargs)[source]#Perform ceil operation on the data to the specifiedfreq.Parameters:freqstr or OffsetThe frequency level to ceil the index to. Must be a fixed
frequency like ‘S’ (second) not ‘ME’ (month end). Seefrequency aliasesfor
a list of possiblefreqvalues.ambiguous‘infer’, bool-ndarray, ‘NaT’, default ‘raise’Only relevant for DatetimeIndex:‘infer’ will attempt to infer fall dst-transition hours based on
orderbool-ndarray where True signifies a DST time, False designates
a non-DST time (note that this flag is only applicable for
ambiguous times)‘NaT’ will return NaT where there are ambiguous times‘raise’ will raise an AmbiguousTimeError if there are ambiguous
times.nonexistent‘shift_forward’, ‘shift_backward’, ‘NaT’, timedelta, default ‘raise’A nonexistent time does not exist in a particular timezone
where clocks moved forward due to DST.‘shift_forward’ will shift the nonexistent time forward to the
closest existing time‘shift_backward’ will shift the nonexistent time backward to the
closest existing time‘NaT’ will return NaT where there are nonexistent timestimedelta objects will shift nonexistent times by the timedelta‘raise’ will raise an NonExistentTimeError if there are
nonexistent times.Returns:DatetimeIndex, TimedeltaIndex, or SeriesIndex of the same type for a DatetimeIndex or TimedeltaIndex,
or a Series with the same index for a Series.Raises:ValueError if thefreqcannot be converted.NotesIf the timestamps have a timezone, ceiling will take place relative to the
local (“wall”) time and re-localized to the same timezone. When ceiling
near daylight savings time, usenonexistentandambiguousto
control the re-localization behavior.ExamplesDatetimeIndex>>>rng=pd.date_range('1/1/2018 11:59:00',periods=3,freq='min')>>>rngDatetimeIndex(['2018-01-01 11:59:00', '2018-01-01 12:00:00','2018-01-01 12:01:00'],dtype='datetime64[ns]', freq='T')>>>rng.ceil('H')DatetimeIndex(['2018-01-01 12:00:00', '2018-01-01 12:00:00','2018-01-01 13:00:00'],dtype='datetime64[ns]', freq=None)Series>>>pd.Series(rng).dt.ceil(""H"")0   2018-01-01 12:00:001   2018-01-01 12:00:002   2018-01-01 13:00:00dtype: datetime64[ns]When rounding near a daylight savings time transition, useambiguousornonexistentto control how the timestamp should be re-localized.>>>rng_tz=pd.DatetimeIndex([""2021-10-31 01:30:00""],tz=""Europe/Amsterdam"")>>>rng_tz.ceil(""H"",ambiguous=False)DatetimeIndex(['2021-10-31 02:00:00+01:00'],dtype='datetime64[ns, Europe/Amsterdam]', freq=None)>>>rng_tz.ceil(""H"",ambiguous=True)DatetimeIndex(['2021-10-31 02:00:00+02:00'],dtype='datetime64[ns, Europe/Amsterdam]', freq=None)"
Pandas,Index objects,pandas.TimedeltaIndex.to_frame,"pandas.TimedeltaIndex.to_frame#TimedeltaIndex.to_frame(index=True,name=_NoDefault.no_default)[source]#Create a DataFrame with a column containing the Index.Parameters:indexbool, default TrueSet the index of the returned DataFrame as the original Index.nameobject, defaults to index.nameThe passed name should substitute for the index name (if it has
one).Returns:DataFrameDataFrame containing the original Index data.See alsoIndex.to_seriesConvert an Index to a Series.Series.to_frameConvert Series to DataFrame.Examples>>>idx=pd.Index(['Ant','Bear','Cow'],name='animal')>>>idx.to_frame()animalanimalAnt       AntBear     BearCow       CowBy default, the original Index is reused. To enforce a new Index:>>>idx.to_frame(index=False)animal0   Ant1  Bear2   CowTo override the name of the resulting column, specifyname:>>>idx.to_frame(index=False,name='zoo')zoo0   Ant1  Bear2   Cow"
Pandas,Index objects,pandas.TimedeltaIndex.mean,"pandas.TimedeltaIndex.mean#TimedeltaIndex.mean(*,skipna=True,axis=0)[source]#Return the mean value of the Array.Parameters:skipnabool, default TrueWhether to ignore any NaT elements.axisint, optional, default 0Returns:scalarTimestamp or Timedelta.See alsonumpy.ndarray.meanReturns the average of array elements along a given axis.Series.meanReturn the mean value in a Series.Notesmean is only defined for Datetime and Timedelta dtypes, not for Period.ExamplesForpandas.DatetimeIndex:>>>idx=pd.date_range('2001-01-01 00:00',periods=3)>>>idxDatetimeIndex(['2001-01-01', '2001-01-02', '2001-01-03'],dtype='datetime64[ns]', freq='D')>>>idx.mean()Timestamp('2001-01-02 00:00:00')Forpandas.TimedeltaIndex:>>>tdelta_idx=pd.to_timedelta([1,2,3],unit='D')>>>tdelta_idxTimedeltaIndex(['1 days', '2 days', '3 days'],dtype='timedelta64[ns]', freq=None)>>>tdelta_idx.mean()Timedelta('2 days 00:00:00')"
Pandas,Index objects,pandas.PeriodIndex,"pandas.PeriodIndex#classpandas.PeriodIndex(data=None,ordinal=None,freq=None,dtype=None,copy=False,name=None,**fields)[source]#Immutable ndarray holding ordinal values indicating regular periods in time.Index keys are boxed to Period objects which carries the metadata (eg,
frequency information).Parameters:dataarray-like (1d int np.ndarray or PeriodArray), optionalOptional period-like data to construct index with.copyboolMake a copy of input ndarray.freqstr or period object, optionalOne of pandas period strings or corresponding objects.yearint, array, or Series, default Nonemonthint, array, or Series, default Nonequarterint, array, or Series, default Nonedayint, array, or Series, default Nonehourint, array, or Series, default Noneminuteint, array, or Series, default Nonesecondint, array, or Series, default Nonedtypestr or PeriodDtype, default NoneSee alsoIndexThe base pandas Index type.PeriodRepresents a period of time.DatetimeIndexIndex with datetime64 data.TimedeltaIndexIndex of timedelta64 data.period_rangeCreate a fixed-frequency PeriodIndex.Examples>>>idx=pd.PeriodIndex(year=[2000,2002],quarter=[1,3])>>>idxPeriodIndex(['2000Q1', '2002Q3'], dtype='period[Q-DEC]')AttributesdayThe days of the period.dayofweekThe day of the week with Monday=0, Sunday=6.day_of_weekThe day of the week with Monday=0, Sunday=6.dayofyearThe ordinal day of the year.day_of_yearThe ordinal day of the year.days_in_monthThe number of days in the month.daysinmonthThe number of days in the month.end_timeGet the Timestamp for the end of the period.freqstrReturn the frequency object as a string if it's set, otherwise None.hourThe hour of the period.is_leap_yearLogical indicating if the date belongs to a leap year.minuteThe minute of the period.monthThe month as January=1, December=12.quarterThe quarter of the date.secondThe second of the period.start_timeGet the Timestamp for the start of the period.weekThe week ordinal of the year.weekdayThe day of the week with Monday=0, Sunday=6.weekofyearThe week ordinal of the year.yearThe year of the period.freqqyearMethodsasfreq([freq, how])Convert the PeriodArray to the specified frequencyfreq.strftime(*args, **kwargs)Convert to Index using specified date_format.to_timestamp([freq, how])Cast to DatetimeArray/Index."
Pandas,Index objects,pandas.PeriodIndex.day,"pandas.PeriodIndex.day#propertyPeriodIndex.day[source]#The days of the period.Examples>>>idx=pd.PeriodIndex(['2020-01-31','2020-02-28'],freq='D')>>>idx.dayIndex([31, 28], dtype='int64')"
Pandas,Index objects,pandas.PeriodIndex.dayofweek,"pandas.PeriodIndex.dayofweek#propertyPeriodIndex.dayofweek[source]#The day of the week with Monday=0, Sunday=6.Examples>>>idx=pd.PeriodIndex([""2023-01-01"",""2023-01-02"",""2023-01-03""],freq=""D"")>>>idx.weekdayIndex([6, 0, 1], dtype='int64')"
Pandas,Index objects,pandas.PeriodIndex.day_of_week,"pandas.PeriodIndex.day_of_week#propertyPeriodIndex.day_of_week[source]#The day of the week with Monday=0, Sunday=6.Examples>>>idx=pd.PeriodIndex([""2023-01-01"",""2023-01-02"",""2023-01-03""],freq=""D"")>>>idx.weekdayIndex([6, 0, 1], dtype='int64')"
Pandas,Index objects,pandas.PeriodIndex.dayofyear,"pandas.PeriodIndex.dayofyear#propertyPeriodIndex.dayofyear[source]#The ordinal day of the year.Examples>>>idx=pd.PeriodIndex([""2023-01-10"",""2023-02-01"",""2023-03-01""],freq=""D"")>>>idx.dayofyearIndex([10, 32, 60], dtype='int64')>>>idx=pd.PeriodIndex([""2023"",""2024"",""2025""],freq=""Y"")>>>idxPeriodIndex(['2023', '2024', '2025'], dtype='period[A-DEC]')>>>idx.dayofyearIndex([365, 366, 365], dtype='int64')"
Pandas,Index objects,pandas.PeriodIndex.day_of_year,"pandas.PeriodIndex.day_of_year#propertyPeriodIndex.day_of_year[source]#The ordinal day of the year.Examples>>>idx=pd.PeriodIndex([""2023-01-10"",""2023-02-01"",""2023-03-01""],freq=""D"")>>>idx.dayofyearIndex([10, 32, 60], dtype='int64')>>>idx=pd.PeriodIndex([""2023"",""2024"",""2025""],freq=""Y"")>>>idxPeriodIndex(['2023', '2024', '2025'], dtype='period[A-DEC]')>>>idx.dayofyearIndex([365, 366, 365], dtype='int64')"
Pandas,Index objects,pandas.PeriodIndex.days_in_month,"pandas.PeriodIndex.days_in_month#propertyPeriodIndex.days_in_month[source]#The number of days in the month.ExamplesFor Series:>>>period=pd.period_range('2020-1-1 00:00','2020-3-1 00:00',freq='M')>>>s=pd.Series(period)>>>s0   2020-011   2020-022   2020-03dtype: period[M]>>>s.dt.days_in_month0    311    292    31dtype: int64For PeriodIndex:>>>idx=pd.PeriodIndex([""2023-01"",""2023-02"",""2023-03""],freq=""M"")>>>idx.days_in_month# It can be also entered as `daysinmonth`Index([31, 28, 31], dtype='int64')"
Pandas,Index objects,pandas.PeriodIndex.daysinmonth,"pandas.PeriodIndex.daysinmonth#propertyPeriodIndex.daysinmonth[source]#The number of days in the month.ExamplesFor Series:>>>period=pd.period_range('2020-1-1 00:00','2020-3-1 00:00',freq='M')>>>s=pd.Series(period)>>>s0   2020-011   2020-022   2020-03dtype: period[M]>>>s.dt.days_in_month0    311    292    31dtype: int64For PeriodIndex:>>>idx=pd.PeriodIndex([""2023-01"",""2023-02"",""2023-03""],freq=""M"")>>>idx.days_in_month# It can be also entered as `daysinmonth`Index([31, 28, 31], dtype='int64')"
Pandas,Index objects,pandas.PeriodIndex.end_time,"pandas.PeriodIndex.end_time#propertyPeriodIndex.end_time[source]#Get the Timestamp for the end of the period.Returns:TimestampSee alsoPeriod.start_timeReturn the start Timestamp.Period.dayofyearReturn the day of year.Period.daysinmonthReturn the days in that month.Period.dayofweekReturn the day of the week.ExamplesFor Period:>>>pd.Period('2020-01','D').end_timeTimestamp('2020-01-01 23:59:59.999999999')For Series:>>>period_index=pd.period_range('2020-1-1 00:00','2020-3-1 00:00',freq='M')>>>s=pd.Series(period_index)>>>s0   2020-011   2020-022   2020-03dtype: period[M]>>>s.dt.end_time0   2020-01-31 23:59:59.9999999991   2020-02-29 23:59:59.9999999992   2020-03-31 23:59:59.999999999dtype: datetime64[ns]For PeriodIndex:>>>idx=pd.PeriodIndex([""2023-01"",""2023-02"",""2023-03""],freq=""M"")>>>idx.end_timeDatetimeIndex(['2023-01-31 23:59:59.999999999','2023-02-28 23:59:59.999999999','2023-03-31 23:59:59.999999999'],dtype='datetime64[ns]', freq=None)"
Pandas,Index objects,pandas.PeriodIndex.freq,pandas.PeriodIndex.freq#propertyPeriodIndex.freq[source]#
Pandas,Index objects,pandas.PeriodIndex.freqstr,"pandas.PeriodIndex.freqstr#propertyPeriodIndex.freqstr[source]#Return the frequency object as a string if it’s set, otherwise None.ExamplesFor DatetimeIndex:>>>idx=pd.DatetimeIndex([""1/1/2020 10:00:00+00:00""],freq=""D"")>>>idx.freqstr'D'The frequency can be inferred if there are more than 2 points:>>>idx=pd.DatetimeIndex([""2018-01-01"",""2018-01-03"",""2018-01-05""],...freq=""infer"")>>>idx.freqstr'2D'For PeriodIndex:>>>idx=pd.PeriodIndex([""2023-1"",""2023-2"",""2023-3""],freq=""M"")>>>idx.freqstr'M'"
Pandas,Index objects,pandas.PeriodIndex.hour,"pandas.PeriodIndex.hour#propertyPeriodIndex.hour[source]#The hour of the period.Examples>>>idx=pd.PeriodIndex([""2023-01-01 10:00"",""2023-01-01 11:00""],freq='H')>>>idx.hourIndex([10, 11], dtype='int64')"
Pandas,Index objects,pandas.PeriodIndex.is_leap_year,"pandas.PeriodIndex.is_leap_year#propertyPeriodIndex.is_leap_year[source]#Logical indicating if the date belongs to a leap year.Examples>>>idx=pd.PeriodIndex([""2023"",""2024"",""2025""],freq=""Y"")>>>idx.is_leap_yeararray([False,  True, False])"
Pandas,Index objects,pandas.PeriodIndex.minute,"pandas.PeriodIndex.minute#propertyPeriodIndex.minute[source]#The minute of the period.Examples>>>idx=pd.PeriodIndex([""2023-01-01 10:30:00"",...""2023-01-01 11:50:00""],freq='min')>>>idx.minuteIndex([30, 50], dtype='int64')"
Pandas,Index objects,pandas.PeriodIndex.month,"pandas.PeriodIndex.month#propertyPeriodIndex.month[source]#The month as January=1, December=12.Examples>>>idx=pd.PeriodIndex([""2023-01"",""2023-02"",""2023-03""],freq=""M"")>>>idx.monthIndex([1, 2, 3], dtype='int64')"
Pandas,Index objects,pandas.PeriodIndex.quarter,"pandas.PeriodIndex.quarter#propertyPeriodIndex.quarter[source]#The quarter of the date.Examples>>>idx=pd.PeriodIndex([""2023-01"",""2023-02"",""2023-03""],freq=""M"")>>>idx.quarterIndex([1, 1, 1], dtype='int64')"
Pandas,Index objects,pandas.PeriodIndex.qyear,pandas.PeriodIndex.qyear#propertyPeriodIndex.qyear[source]#
Pandas,Index objects,pandas.PeriodIndex.second,"pandas.PeriodIndex.second#propertyPeriodIndex.second[source]#The second of the period.Examples>>>idx=pd.PeriodIndex([""2023-01-01 10:00:30"",...""2023-01-01 10:00:31""],freq='s')>>>idx.secondIndex([30, 31], dtype='int64')"
Pandas,Index objects,pandas.PeriodIndex.start_time,"pandas.PeriodIndex.start_time#propertyPeriodIndex.start_time[source]#Get the Timestamp for the start of the period.Returns:TimestampSee alsoPeriod.end_timeReturn the end Timestamp.Period.dayofyearReturn the day of year.Period.daysinmonthReturn the days in that month.Period.dayofweekReturn the day of the week.Examples>>>period=pd.Period('2012-1-1',freq='D')>>>periodPeriod('2012-01-01', 'D')>>>period.start_timeTimestamp('2012-01-01 00:00:00')>>>period.end_timeTimestamp('2012-01-01 23:59:59.999999999')"
Pandas,Index objects,pandas.PeriodIndex.week,"pandas.PeriodIndex.week#propertyPeriodIndex.week[source]#The week ordinal of the year.Examples>>>idx=pd.PeriodIndex([""2023-01"",""2023-02"",""2023-03""],freq=""M"")>>>idx.week# It can be written `weekofyear`Index([5, 9, 13], dtype='int64')"
Pandas,Index objects,pandas.PeriodIndex.weekday,"pandas.PeriodIndex.weekday#propertyPeriodIndex.weekday[source]#The day of the week with Monday=0, Sunday=6.Examples>>>idx=pd.PeriodIndex([""2023-01-01"",""2023-01-02"",""2023-01-03""],freq=""D"")>>>idx.weekdayIndex([6, 0, 1], dtype='int64')"
Pandas,Index objects,pandas.PeriodIndex.weekofyear,"pandas.PeriodIndex.weekofyear#propertyPeriodIndex.weekofyear[source]#The week ordinal of the year.Examples>>>idx=pd.PeriodIndex([""2023-01"",""2023-02"",""2023-03""],freq=""M"")>>>idx.week# It can be written `weekofyear`Index([5, 9, 13], dtype='int64')"
Pandas,Index objects,pandas.PeriodIndex.year,"pandas.PeriodIndex.year#propertyPeriodIndex.year[source]#The year of the period.Examples>>>idx=pd.PeriodIndex([""2023"",""2024"",""2025""],freq=""Y"")>>>idx.yearIndex([2023, 2024, 2025], dtype='int64')"
Pandas,Index objects,pandas.PeriodIndex.asfreq,"pandas.PeriodIndex.asfreq#PeriodIndex.asfreq(freq=None,how='E')[source]#Convert the PeriodArray to the specified frequencyfreq.Equivalent to applyingpandas.Period.asfreq()with the given arguments
to eachPeriodin this PeriodArray.Parameters:freqstrA frequency.howstr {‘E’, ‘S’}, default ‘E’Whether the elements should be aligned to the end
or start within pa period.‘E’, ‘END’, or ‘FINISH’ for end,‘S’, ‘START’, or ‘BEGIN’ for start.January 31st (‘END’) vs. January 1st (‘START’) for example.Returns:PeriodArrayThe transformed PeriodArray with the new frequency.See alsopandas.arrays.PeriodArray.asfreqConvert each Period in a PeriodArray to the given frequency.Period.asfreqConvert aPeriodobject to the given frequency.Examples>>>pidx=pd.period_range('2010-01-01','2015-01-01',freq='A')>>>pidxPeriodIndex(['2010', '2011', '2012', '2013', '2014', '2015'],dtype='period[A-DEC]')>>>pidx.asfreq('M')PeriodIndex(['2010-12', '2011-12', '2012-12', '2013-12', '2014-12','2015-12'], dtype='period[M]')>>>pidx.asfreq('M',how='S')PeriodIndex(['2010-01', '2011-01', '2012-01', '2013-01', '2014-01','2015-01'], dtype='period[M]')"
Pandas,Index objects,pandas.PeriodIndex.strftime,"pandas.PeriodIndex.strftime#PeriodIndex.strftime(*args,**kwargs)[source]#Convert to Index using specified date_format.Return an Index of formatted strings specified by date_format, which
supports the same string format as the python standard library. Details
of the string format can be found inpython string format
doc.Formats supported by the CstrftimeAPI but not by the python string format
doc (such as“%R”,“%r”) are not officially supported and should be
preferably replaced with their supported equivalents (such as“%H:%M”,“%I:%M:%S %p”).Note thatPeriodIndexsupport additional directives, detailed inPeriod.strftime.Parameters:date_formatstrDate format string (e.g. “%Y-%m-%d”).Returns:ndarray[object]NumPy ndarray of formatted strings.See alsoto_datetimeConvert the given argument to datetime.DatetimeIndex.normalizeReturn DatetimeIndex with times to midnight.DatetimeIndex.roundRound the DatetimeIndex to the specified freq.DatetimeIndex.floorFloor the DatetimeIndex to the specified freq.Timestamp.strftimeFormat a single Timestamp.Period.strftimeFormat a single Period.Examples>>>rng=pd.date_range(pd.Timestamp(""2018-03-10 09:00""),...periods=3,freq='s')>>>rng.strftime('%B%d, %Y,%r')Index(['March 10, 2018, 09:00:00 AM', 'March 10, 2018, 09:00:01 AM','March 10, 2018, 09:00:02 AM'],dtype='object')"
Pandas,Index objects,pandas.PeriodIndex.to_timestamp,"pandas.PeriodIndex.to_timestamp#PeriodIndex.to_timestamp(freq=None,how='start')[source]#Cast to DatetimeArray/Index.Parameters:freqstr or DateOffset, optionalTarget frequency. The default is ‘D’ for week or longer,
‘S’ otherwise.how{‘s’, ‘e’, ‘start’, ‘end’}Whether to use the start or end of the time period being converted.Returns:DatetimeArray/IndexExamples>>>idx=pd.PeriodIndex([""2023-01"",""2023-02"",""2023-03""],freq=""M"")>>>idx.to_timestamp()DatetimeIndex(['2023-01-01', '2023-02-01', '2023-03-01'],dtype='datetime64[ns]', freq='MS')"
