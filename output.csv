Name,Chapter,Section,Content
Numpy,fft,numpy.fft.fft,"numpy.fft.fft#fft.fft(a,n=None,axis=-1,norm=None)[source]#Compute the one-dimensional discrete Fourier Transform.This function computes the one-dimensionaln-point discrete Fourier
Transform (DFT) with the efficient Fast Fourier Transform (FFT)
algorithm [CT].Parameters:aarray_likeInput array, can be complex.nint, optionalLength of the transformed axis of the output.
Ifnis smaller than the length of the input, the input is cropped.
If it is larger, the input is padded with zeros.  Ifnis not given,
the length of the input along the axis specified byaxisis used.axisint, optionalAxis over which to compute the FFT.  If not given, the last axis is
used.norm{gbackwardh, gorthoh, gforwardh}, optionalNew in version 1.10.0.Normalization mode (seenumpy.fft). Default is gbackwardh.
Indicates which direction of the forward/backward pair of transforms
is scaled and with what normalization factor.New in version 1.20.0:The gbackwardh, gforwardh values were added.Returns:outcomplex ndarrayThe truncated or zero-padded input, transformed along the axis
indicated byaxis, or the last one ifaxisis not specified.Raises:IndexErrorIfaxisis not a valid axis ofa.See alsonumpy.fftfor definition of the DFT and conventions used.ifftThe inverse offft.fft2The two-dimensional FFT.fftnThen-dimensional FFT.rfftnThen-dimensional FFT of real input.fftfreqFrequency bins for given FFT parameters.NotesFFT (Fast Fourier Transform) refers to a way the discrete Fourier
Transform (DFT) can be calculated efficiently, by using symmetries in the
calculated terms.  The symmetry is highest whennis a power of 2, and
the transform is therefore most efficient for these sizes.The DFT is defined, with the conventions used in this implementation, in
the documentation for thenumpy.fftmodule.References[CT]Cooley, James W., and John W. Tukey, 1965, gAn algorithm for the
machine calculation of complex Fourier series,hMath. Comput.19: 297-301.Examples>>>np.fft.fft(np.exp(2j*np.pi*np.arange(8)/8))array([-2.33486982e-16+1.14423775e-17j,  8.00000000e+00-1.25557246e-15j,2.33486982e-16+2.33486982e-16j,  0.00000000e+00+1.22464680e-16j,-1.14423775e-17+2.33486982e-16j,  0.00000000e+00+5.20784380e-16j,1.14423775e-17+1.14423775e-17j,  0.00000000e+00+1.22464680e-16j])In this example, real input has an FFT which is Hermitian, i.e., symmetric
in the real part and anti-symmetric in the imaginary part, as described in
thenumpy.fftdocumentation:>>>importmatplotlib.pyplotasplt>>>t=np.arange(256)>>>sp=np.fft.fft(np.sin(t))>>>freq=np.fft.fftfreq(t.shape[-1])>>>plt.plot(freq,sp.real,freq,sp.imag)[<matplotlib.lines.Line2D object at 0x...>, <matplotlib.lines.Line2D object at 0x...>]>>>plt.show()"
Numpy,fft,numpy.fft.ifft,"numpy.fft.ifft#fft.ifft(a,n=None,axis=-1,norm=None)[source]#Compute the one-dimensional inverse discrete Fourier Transform.This function computes the inverse of the one-dimensionaln-point
discrete Fourier transform computed byfft.  In other words,ifft(fft(a))==ato within numerical accuracy.
For a general description of the algorithm and definitions,
seenumpy.fft.The input should be ordered in the same way as is returned byfft,
i.e.,a[0]should contain the zero frequency term,a[1:n//2]should contain the positive-frequency terms,a[n//2+1:]should contain the negative-frequency terms, in
increasing order starting from the most negative frequency.For an even number of input points,A[n//2]represents the sum of
the values at the positive and negative Nyquist frequencies, as the two
are aliased together. Seenumpy.fftfor details.Parameters:aarray_likeInput array, can be complex.nint, optionalLength of the transformed axis of the output.
Ifnis smaller than the length of the input, the input is cropped.
If it is larger, the input is padded with zeros.  Ifnis not given,
the length of the input along the axis specified byaxisis used.
See notes about padding issues.axisint, optionalAxis over which to compute the inverse DFT.  If not given, the last
axis is used.norm{gbackwardh, gorthoh, gforwardh}, optionalNew in version 1.10.0.Normalization mode (seenumpy.fft). Default is gbackwardh.
Indicates which direction of the forward/backward pair of transforms
is scaled and with what normalization factor.New in version 1.20.0:The gbackwardh, gforwardh values were added.Returns:outcomplex ndarrayThe truncated or zero-padded input, transformed along the axis
indicated byaxis, or the last one ifaxisis not specified.Raises:IndexErrorIfaxisis not a valid axis ofa.See alsonumpy.fftAn introduction, with definitions and general explanations.fftThe one-dimensional (forward) FFT, of whichifftis the inverseifft2The two-dimensional inverse FFT.ifftnThe n-dimensional inverse FFT.NotesIf the input parameternis larger than the size of the input, the input
is padded by appending zeros at the end.  Even though this is the common
approach, it might lead to surprising results.  If a different padding is
desired, it must be performed before callingifft.Examples>>>np.fft.ifft([0,4,0,0])array([ 1.+0.j,  0.+1.j, -1.+0.j,  0.-1.j]) # may varyCreate and plot a band-limited signal with random phases:>>>importmatplotlib.pyplotasplt>>>t=np.arange(400)>>>n=np.zeros((400,),dtype=complex)>>>n[40:60]=np.exp(1j*np.random.uniform(0,2*np.pi,(20,)))>>>s=np.fft.ifft(n)>>>plt.plot(t,s.real,label='real')[<matplotlib.lines.Line2D object at ...>]>>>plt.plot(t,s.imag,'--',label='imaginary')[<matplotlib.lines.Line2D object at ...>]>>>plt.legend()<matplotlib.legend.Legend object at ...>>>>plt.show()"
Numpy,fft,numpy.fft.fft2,"numpy.fft.fft2#fft.fft2(a,s=None,axes=(-2,-1),norm=None)[source]#Compute the 2-dimensional discrete Fourier Transform.This function computes then-dimensional discrete Fourier Transform
over any axes in anM-dimensional array by means of the
Fast Fourier Transform (FFT).  By default, the transform is computed over
the last two axes of the input array, i.e., a 2-dimensional FFT.Parameters:aarray_likeInput array, can be complexssequence of ints, optionalShape (length of each transformed axis) of the output
(s[0]refers to axis 0,s[1]to axis 1, etc.).
This corresponds tonforfft(x,n).
Along each axis, if the given shape is smaller than that of the input,
the input is cropped.  If it is larger, the input is padded with zeros.
ifsis not given, the shape of the input along the axes specified
byaxesis used.axessequence of ints, optionalAxes over which to compute the FFT.  If not given, the last two
axes are used.  A repeated index inaxesmeans the transform over
that axis is performed multiple times.  A one-element sequence means
that a one-dimensional FFT is performed.norm{gbackwardh, gorthoh, gforwardh}, optionalNew in version 1.10.0.Normalization mode (seenumpy.fft). Default is gbackwardh.
Indicates which direction of the forward/backward pair of transforms
is scaled and with what normalization factor.New in version 1.20.0:The gbackwardh, gforwardh values were added.Returns:outcomplex ndarrayThe truncated or zero-padded input, transformed along the axes
indicated byaxes, or the last two axes ifaxesis not given.Raises:ValueErrorIfsandaxeshave different length, oraxesnot given andlen(s)!=2.IndexErrorIf an element ofaxesis larger than than the number of axes ofa.See alsonumpy.fftOverall view of discrete Fourier transforms, with definitions and conventions used.ifft2The inverse two-dimensional FFT.fftThe one-dimensional FFT.fftnThen-dimensional FFT.fftshiftShifts zero-frequency terms to the center of the array. For two-dimensional input, swaps first and third quadrants, and second and fourth quadrants.Notesfft2is justfftnwith a different default foraxes.The output, analogously tofft, contains the term for zero frequency in
the low-order corner of the transformed axes, the positive frequency terms
in the first half of these axes, the term for the Nyquist frequency in the
middle of the axes and the negative frequency terms in the second half of
the axes, in order of decreasingly negative frequency.Seefftnfor details and a plotting example, andnumpy.fftfor
definitions and conventions used.Examples>>>a=np.mgrid[:5,:5][0]>>>np.fft.fft2(a)array([[ 50.  +0.j        ,   0.  +0.j        ,   0.  +0.j        , # may vary0.  +0.j        ,   0.  +0.j        ],[-12.5+17.20477401j,   0.  +0.j        ,   0.  +0.j        ,0.  +0.j        ,   0.  +0.j        ],[-12.5 +4.0614962j ,   0.  +0.j        ,   0.  +0.j        ,0.  +0.j        ,   0.  +0.j        ],[-12.5 -4.0614962j ,   0.  +0.j        ,   0.  +0.j        ,0.  +0.j        ,   0.  +0.j        ],[-12.5-17.20477401j,   0.  +0.j        ,   0.  +0.j        ,0.  +0.j        ,   0.  +0.j        ]])"
Numpy,fft,numpy.fft.ifft2,"numpy.fft.ifft2#fft.ifft2(a,s=None,axes=(-2,-1),norm=None)[source]#Compute the 2-dimensional inverse discrete Fourier Transform.This function computes the inverse of the 2-dimensional discrete Fourier
Transform over any number of axes in an M-dimensional array by means of
the Fast Fourier Transform (FFT).  In other words,ifft2(fft2(a))==ato within numerical accuracy.  By default, the inverse transform is
computed over the last two axes of the input array.The input, analogously toifft, should be ordered in the same way as is
returned byfft2, i.e. it should have the term for zero frequency
in the low-order corner of the two axes, the positive frequency terms in
the first half of these axes, the term for the Nyquist frequency in the
middle of the axes and the negative frequency terms in the second half of
both axes, in order of decreasingly negative frequency.Parameters:aarray_likeInput array, can be complex.ssequence of ints, optionalShape (length of each axis) of the output (s[0]refers to axis 0,s[1]to axis 1, etc.).  This corresponds tonforifft(x,n).
Along each axis, if the given shape is smaller than that of the input,
the input is cropped.  If it is larger, the input is padded with zeros.
ifsis not given, the shape of the input along the axes specified
byaxesis used.  See notes for issue onifftzero padding.axessequence of ints, optionalAxes over which to compute the FFT.  If not given, the last two
axes are used.  A repeated index inaxesmeans the transform over
that axis is performed multiple times.  A one-element sequence means
that a one-dimensional FFT is performed.norm{gbackwardh, gorthoh, gforwardh}, optionalNew in version 1.10.0.Normalization mode (seenumpy.fft). Default is gbackwardh.
Indicates which direction of the forward/backward pair of transforms
is scaled and with what normalization factor.New in version 1.20.0:The gbackwardh, gforwardh values were added.Returns:outcomplex ndarrayThe truncated or zero-padded input, transformed along the axes
indicated byaxes, or the last two axes ifaxesis not given.Raises:ValueErrorIfsandaxeshave different length, oraxesnot given andlen(s)!=2.IndexErrorIf an element ofaxesis larger than than the number of axes ofa.See alsonumpy.fftOverall view of discrete Fourier transforms, with definitions and conventions used.fft2The forward 2-dimensional FFT, of whichifft2is the inverse.ifftnThe inverse of then-dimensional FFT.fftThe one-dimensional FFT.ifftThe one-dimensional inverse FFT.Notesifft2is justifftnwith a different default foraxes.Seeifftnfor details and a plotting example, andnumpy.fftfor
definition and conventions used.Zero-padding, analogously withifft, is performed by appending zeros to
the input along the specified dimension.  Although this is the common
approach, it might lead to surprising results.  If another form of zero
padding is desired, it must be performed beforeifft2is called.Examples>>>a=4*np.eye(4)>>>np.fft.ifft2(a)array([[1.+0.j,  0.+0.j,  0.+0.j,  0.+0.j], # may vary[0.+0.j,  0.+0.j,  0.+0.j,  1.+0.j],[0.+0.j,  0.+0.j,  1.+0.j,  0.+0.j],[0.+0.j,  1.+0.j,  0.+0.j,  0.+0.j]])"
Numpy,fft,numpy.fft.fftn,"numpy.fft.fftn#fft.fftn(a,s=None,axes=None,norm=None)[source]#Compute the N-dimensional discrete Fourier Transform.This function computes theN-dimensional discrete Fourier Transform over
any number of axes in anM-dimensional array by means of the Fast Fourier
Transform (FFT).Parameters:aarray_likeInput array, can be complex.ssequence of ints, optionalShape (length of each transformed axis) of the output
(s[0]refers to axis 0,s[1]to axis 1, etc.).
This corresponds tonforfft(x,n).
Along any axis, if the given shape is smaller than that of the input,
the input is cropped.  If it is larger, the input is padded with zeros.
ifsis not given, the shape of the input along the axes specified
byaxesis used.axessequence of ints, optionalAxes over which to compute the FFT.  If not given, the lastlen(s)axes are used, or all axes ifsis also not specified.
Repeated indices inaxesmeans that the transform over that axis is
performed multiple times.norm{gbackwardh, gorthoh, gforwardh}, optionalNew in version 1.10.0.Normalization mode (seenumpy.fft). Default is gbackwardh.
Indicates which direction of the forward/backward pair of transforms
is scaled and with what normalization factor.New in version 1.20.0:The gbackwardh, gforwardh values were added.Returns:outcomplex ndarrayThe truncated or zero-padded input, transformed along the axes
indicated byaxes, or by a combination ofsanda,
as explained in the parameters section above.Raises:ValueErrorIfsandaxeshave different length.IndexErrorIf an element ofaxesis larger than than the number of axes ofa.See alsonumpy.fftOverall view of discrete Fourier transforms, with definitions and conventions used.ifftnThe inverse offftn, the inversen-dimensional FFT.fftThe one-dimensional FFT, with definitions and conventions used.rfftnThen-dimensional FFT of real input.fft2The two-dimensional FFT.fftshiftShifts zero-frequency terms to centre of arrayNotesThe output, analogously tofft, contains the term for zero frequency in
the low-order corner of all axes, the positive frequency terms in the
first half of all axes, the term for the Nyquist frequency in the middle
of all axes and the negative frequency terms in the second half of all
axes, in order of decreasingly negative frequency.Seenumpy.fftfor details, definitions and conventions used.Examples>>>a=np.mgrid[:3,:3,:3][0]>>>np.fft.fftn(a,axes=(1,2))array([[[ 0.+0.j,   0.+0.j,   0.+0.j], # may vary[ 0.+0.j,   0.+0.j,   0.+0.j],[ 0.+0.j,   0.+0.j,   0.+0.j]],[[ 9.+0.j,   0.+0.j,   0.+0.j],[ 0.+0.j,   0.+0.j,   0.+0.j],[ 0.+0.j,   0.+0.j,   0.+0.j]],[[18.+0.j,   0.+0.j,   0.+0.j],[ 0.+0.j,   0.+0.j,   0.+0.j],[ 0.+0.j,   0.+0.j,   0.+0.j]]])>>>np.fft.fftn(a,(2,2),axes=(0,1))array([[[ 2.+0.j,  2.+0.j,  2.+0.j], # may vary[ 0.+0.j,  0.+0.j,  0.+0.j]],[[-2.+0.j, -2.+0.j, -2.+0.j],[ 0.+0.j,  0.+0.j,  0.+0.j]]])>>>importmatplotlib.pyplotasplt>>>[X,Y]=np.meshgrid(2*np.pi*np.arange(200)/12,...2*np.pi*np.arange(200)/34)>>>S=np.sin(X)+np.cos(Y)+np.random.uniform(0,1,X.shape)>>>FS=np.fft.fftn(S)>>>plt.imshow(np.log(np.abs(np.fft.fftshift(FS))**2))<matplotlib.image.AxesImage object at 0x...>>>>plt.show()"
Numpy,fft,numpy.fft.ifftn,"numpy.fft.ifftn#fft.ifftn(a,s=None,axes=None,norm=None)[source]#Compute the N-dimensional inverse discrete Fourier Transform.This function computes the inverse of the N-dimensional discrete
Fourier Transform over any number of axes in an M-dimensional array by
means of the Fast Fourier Transform (FFT).  In other words,ifftn(fftn(a))==ato within numerical accuracy.
For a description of the definitions and conventions used, seenumpy.fft.The input, analogously toifft, should be ordered in the same way as is
returned byfftn, i.e. it should have the term for zero frequency
in all axes in the low-order corner, the positive frequency terms in the
first half of all axes, the term for the Nyquist frequency in the middle
of all axes and the negative frequency terms in the second half of all
axes, in order of decreasingly negative frequency.Parameters:aarray_likeInput array, can be complex.ssequence of ints, optionalShape (length of each transformed axis) of the output
(s[0]refers to axis 0,s[1]to axis 1, etc.).
This corresponds tonforifft(x,n).
Along any axis, if the given shape is smaller than that of the input,
the input is cropped.  If it is larger, the input is padded with zeros.
ifsis not given, the shape of the input along the axes specified
byaxesis used.  See notes for issue onifftzero padding.axessequence of ints, optionalAxes over which to compute the IFFT.  If not given, the lastlen(s)axes are used, or all axes ifsis also not specified.
Repeated indices inaxesmeans that the inverse transform over that
axis is performed multiple times.norm{gbackwardh, gorthoh, gforwardh}, optionalNew in version 1.10.0.Normalization mode (seenumpy.fft). Default is gbackwardh.
Indicates which direction of the forward/backward pair of transforms
is scaled and with what normalization factor.New in version 1.20.0:The gbackwardh, gforwardh values were added.Returns:outcomplex ndarrayThe truncated or zero-padded input, transformed along the axes
indicated byaxes, or by a combination ofsora,
as explained in the parameters section above.Raises:ValueErrorIfsandaxeshave different length.IndexErrorIf an element ofaxesis larger than than the number of axes ofa.See alsonumpy.fftOverall view of discrete Fourier transforms, with definitions and conventions used.fftnThe forwardn-dimensional FFT, of whichifftnis the inverse.ifftThe one-dimensional inverse FFT.ifft2The two-dimensional inverse FFT.ifftshiftUndoesfftshift, shifts zero-frequency terms to beginning of array.NotesSeenumpy.fftfor definitions and conventions used.Zero-padding, analogously withifft, is performed by appending zeros to
the input along the specified dimension.  Although this is the common
approach, it might lead to surprising results.  If another form of zero
padding is desired, it must be performed beforeifftnis called.Examples>>>a=np.eye(4)>>>np.fft.ifftn(np.fft.fftn(a,axes=(0,)),axes=(1,))array([[1.+0.j,  0.+0.j,  0.+0.j,  0.+0.j], # may vary[0.+0.j,  1.+0.j,  0.+0.j,  0.+0.j],[0.+0.j,  0.+0.j,  1.+0.j,  0.+0.j],[0.+0.j,  0.+0.j,  0.+0.j,  1.+0.j]])Create and plot an image with band-limited frequency content:>>>importmatplotlib.pyplotasplt>>>n=np.zeros((200,200),dtype=complex)>>>n[60:80,20:40]=np.exp(1j*np.random.uniform(0,2*np.pi,(20,20)))>>>im=np.fft.ifftn(n).real>>>plt.imshow(im)<matplotlib.image.AxesImage object at 0x...>>>>plt.show()"
Numpy,fft,numpy.fft.rfft,"numpy.fft.rfft#fft.rfft(a,n=None,axis=-1,norm=None)[source]#Compute the one-dimensional discrete Fourier Transform for real input.This function computes the one-dimensionaln-point discrete Fourier
Transform (DFT) of a real-valued array by means of an efficient algorithm
called the Fast Fourier Transform (FFT).Parameters:aarray_likeInput arraynint, optionalNumber of points along transformation axis in the input to use.
Ifnis smaller than the length of the input, the input is cropped.
If it is larger, the input is padded with zeros. Ifnis not given,
the length of the input along the axis specified byaxisis used.axisint, optionalAxis over which to compute the FFT. If not given, the last axis is
used.norm{gbackwardh, gorthoh, gforwardh}, optionalNew in version 1.10.0.Normalization mode (seenumpy.fft). Default is gbackwardh.
Indicates which direction of the forward/backward pair of transforms
is scaled and with what normalization factor.New in version 1.20.0:The gbackwardh, gforwardh values were added.Returns:outcomplex ndarrayThe truncated or zero-padded input, transformed along the axis
indicated byaxis, or the last one ifaxisis not specified.
Ifnis even, the length of the transformed axis is(n/2)+1.
Ifnis odd, the length is(n+1)/2.Raises:IndexErrorIfaxisis not a valid axis ofa.See alsonumpy.fftFor definition of the DFT and conventions used.irfftThe inverse ofrfft.fftThe one-dimensional FFT of general (complex) input.fftnThen-dimensional FFT.rfftnThen-dimensional FFT of real input.NotesWhen the DFT is computed for purely real input, the output is
Hermitian-symmetric, i.e. the negative frequency terms are just the complex
conjugates of the corresponding positive-frequency terms, and the
negative-frequency terms are therefore redundant.  This function does not
compute the negative frequency terms, and the length of the transformed
axis of the output is thereforen//2+1.WhenA=rfft(a)and fs is the sampling frequency,A[0]contains
the zero-frequency term 0*fs, which is real due to Hermitian symmetry.Ifnis even,A[-1]contains the term representing both positive
and negative Nyquist frequency (+fs/2 and -fs/2), and must also be purely
real. Ifnis odd, there is no term at fs/2;A[-1]contains
the largest positive frequency (fs/2*(n-1)/n), and is complex in the
general case.If the inputacontains an imaginary part, it is silently discarded.Examples>>>np.fft.fft([0,1,0,0])array([ 1.+0.j,  0.-1.j, -1.+0.j,  0.+1.j]) # may vary>>>np.fft.rfft([0,1,0,0])array([ 1.+0.j,  0.-1.j, -1.+0.j]) # may varyNotice how the final element of thefftoutput is the complex conjugate
of the second element, for real input. Forrfft, this symmetry is
exploited to compute only the non-negative frequency terms."
Numpy,fft,numpy.fft.irfft,"numpy.fft.irfft#fft.irfft(a,n=None,axis=-1,norm=None)[source]#Computes the inverse ofrfft.This function computes the inverse of the one-dimensionaln-point
discrete Fourier Transform of real input computed byrfft.
In other words,irfft(rfft(a),len(a))==ato within numerical
accuracy. (See Notes below for whylen(a)is necessary here.)The input is expected to be in the form returned byrfft, i.e. the
real zero-frequency term followed by the complex positive frequency terms
in order of increasing frequency.  Since the discrete Fourier Transform of
real input is Hermitian-symmetric, the negative frequency terms are taken
to be the complex conjugates of the corresponding positive frequency terms.Parameters:aarray_likeThe input array.nint, optionalLength of the transformed axis of the output.
Fornoutput points,n//2+1input points are necessary.  If the
input is longer than this, it is cropped.  If it is shorter than this,
it is padded with zeros.  Ifnis not given, it is taken to be2*(m-1)wheremis the length of the input along the axis
specified byaxis.axisint, optionalAxis over which to compute the inverse FFT. If not given, the last
axis is used.norm{gbackwardh, gorthoh, gforwardh}, optionalNew in version 1.10.0.Normalization mode (seenumpy.fft). Default is gbackwardh.
Indicates which direction of the forward/backward pair of transforms
is scaled and with what normalization factor.New in version 1.20.0:The gbackwardh, gforwardh values were added.Returns:outndarrayThe truncated or zero-padded input, transformed along the axis
indicated byaxis, or the last one ifaxisis not specified.
The length of the transformed axis isn, or, ifnis not given,2*(m-1)wheremis the length of the transformed axis of the
input. To get an odd number of output points,nmust be specified.Raises:IndexErrorIfaxisis not a valid axis ofa.See alsonumpy.fftFor definition of the DFT and conventions used.rfftThe one-dimensional FFT of real input, of whichirfftis inverse.fftThe one-dimensional FFT.irfft2The inverse of the two-dimensional FFT of real input.irfftnThe inverse of then-dimensional FFT of real input.NotesReturns the real valuedn-point inverse discrete Fourier transform
ofa, whereacontains the non-negative frequency terms of a
Hermitian-symmetric sequence.nis the length of the result, not the
input.If you specify annsuch thatamust be zero-padded or truncated, the
extra/removed values will be added/removed at high frequencies. One can
thus resample a series tompoints via Fourier interpolation by:a_resamp=irfft(rfft(a),m).The correct interpretation of the hermitian input depends on the length of
the original data, as given byn. This is because each input shape could
correspond to either an odd or even length signal. By default,irfftassumes an even output length which puts the last entry at the Nyquist
frequency; aliasing with its symmetric counterpart. By Hermitian symmetry,
the value is thus treated as purely real. To avoid losing information, the
correct length of the real inputmustbe given.Examples>>>np.fft.ifft([1,-1j,-1,1j])array([0.+0.j,  1.+0.j,  0.+0.j,  0.+0.j]) # may vary>>>np.fft.irfft([1,-1j,-1])array([0.,  1.,  0.,  0.])Notice how the last term in the input to the ordinaryifftis the
complex conjugate of the second term, and the output has zero imaginary
part everywhere.  When callingirfft, the negative frequencies are not
specified, and the output array is purely real."
Numpy,fft,numpy.fft.rfft2,"numpy.fft.rfft2#fft.rfft2(a,s=None,axes=(-2,-1),norm=None)[source]#Compute the 2-dimensional FFT of a real array.Parameters:aarrayInput array, taken to be real.ssequence of ints, optionalShape of the FFT.axessequence of ints, optionalAxes over which to compute the FFT.norm{gbackwardh, gorthoh, gforwardh}, optionalNew in version 1.10.0.Normalization mode (seenumpy.fft). Default is gbackwardh.
Indicates which direction of the forward/backward pair of transforms
is scaled and with what normalization factor.New in version 1.20.0:The gbackwardh, gforwardh values were added.Returns:outndarrayThe result of the real 2-D FFT.See alsorfftnCompute the N-dimensional discrete Fourier Transform for real input.NotesThis is really justrfftnwith different default behavior.
For more details seerfftn.Examples>>>a=np.mgrid[:5,:5][0]>>>np.fft.rfft2(a)array([[ 50.  +0.j        ,   0.  +0.j        ,   0.  +0.j        ],[-12.5+17.20477401j,   0.  +0.j        ,   0.  +0.j        ],[-12.5 +4.0614962j ,   0.  +0.j        ,   0.  +0.j        ],[-12.5 -4.0614962j ,   0.  +0.j        ,   0.  +0.j        ],[-12.5-17.20477401j,   0.  +0.j        ,   0.  +0.j        ]])"
Numpy,fft,numpy.fft.irfft2,"numpy.fft.irfft2#fft.irfft2(a,s=None,axes=(-2,-1),norm=None)[source]#Computes the inverse ofrfft2.Parameters:aarray_likeThe input arrayssequence of ints, optionalShape of the real output to the inverse FFT.axessequence of ints, optionalThe axes over which to compute the inverse fft.
Default is the last two axes.norm{gbackwardh, gorthoh, gforwardh}, optionalNew in version 1.10.0.Normalization mode (seenumpy.fft). Default is gbackwardh.
Indicates which direction of the forward/backward pair of transforms
is scaled and with what normalization factor.New in version 1.20.0:The gbackwardh, gforwardh values were added.Returns:outndarrayThe result of the inverse real 2-D FFT.See alsorfft2The forward two-dimensional FFT of real input, of whichirfft2is the inverse.rfftThe one-dimensional FFT for real input.irfftThe inverse of the one-dimensional FFT of real input.irfftnCompute the inverse of the N-dimensional FFT of real input.NotesThis is reallyirfftnwith different defaults.
For more details seeirfftn.Examples>>>a=np.mgrid[:5,:5][0]>>>A=np.fft.rfft2(a)>>>np.fft.irfft2(A,s=a.shape)array([[0., 0., 0., 0., 0.],[1., 1., 1., 1., 1.],[2., 2., 2., 2., 2.],[3., 3., 3., 3., 3.],[4., 4., 4., 4., 4.]])"
Numpy,fft,numpy.fft.rfftn,"numpy.fft.rfftn#fft.rfftn(a,s=None,axes=None,norm=None)[source]#Compute the N-dimensional discrete Fourier Transform for real input.This function computes the N-dimensional discrete Fourier Transform over
any number of axes in an M-dimensional real array by means of the Fast
Fourier Transform (FFT).  By default, all axes are transformed, with the
real transform performed over the last axis, while the remaining
transforms are complex.Parameters:aarray_likeInput array, taken to be real.ssequence of ints, optionalShape (length along each transformed axis) to use from the input.
(s[0]refers to axis 0,s[1]to axis 1, etc.).
The final element ofscorresponds tonforrfft(x,n), while
for the remaining axes, it corresponds tonforfft(x,n).
Along any axis, if the given shape is smaller than that of the input,
the input is cropped.  If it is larger, the input is padded with zeros.
ifsis not given, the shape of the input along the axes specified
byaxesis used.axessequence of ints, optionalAxes over which to compute the FFT.  If not given, the lastlen(s)axes are used, or all axes ifsis also not specified.norm{gbackwardh, gorthoh, gforwardh}, optionalNew in version 1.10.0.Normalization mode (seenumpy.fft). Default is gbackwardh.
Indicates which direction of the forward/backward pair of transforms
is scaled and with what normalization factor.New in version 1.20.0:The gbackwardh, gforwardh values were added.Returns:outcomplex ndarrayThe truncated or zero-padded input, transformed along the axes
indicated byaxes, or by a combination ofsanda,
as explained in the parameters section above.
The length of the last axis transformed will bes[-1]//2+1,
while the remaining transformed axes will have lengths according tos, or unchanged from the input.Raises:ValueErrorIfsandaxeshave different length.IndexErrorIf an element ofaxesis larger than than the number of axes ofa.See alsoirfftnThe inverse ofrfftn, i.e. the inverse of the n-dimensional FFT of real input.fftThe one-dimensional FFT, with definitions and conventions used.rfftThe one-dimensional FFT of real input.fftnThe n-dimensional FFT.rfft2The two-dimensional FFT of real input.NotesThe transform for real input is performed over the last transformation
axis, as byrfft, then the transform over the remaining axes is
performed as byfftn.  The order of the output is as forrfftfor the
final transformation axis, and as forfftnfor the remaining
transformation axes.Seefftfor details, definitions and conventions used.Examples>>>a=np.ones((2,2,2))>>>np.fft.rfftn(a)array([[[8.+0.j,  0.+0.j], # may vary[0.+0.j,  0.+0.j]],[[0.+0.j,  0.+0.j],[0.+0.j,  0.+0.j]]])>>>np.fft.rfftn(a,axes=(2,0))array([[[4.+0.j,  0.+0.j], # may vary[4.+0.j,  0.+0.j]],[[0.+0.j,  0.+0.j],[0.+0.j,  0.+0.j]]])"
Numpy,fft,numpy.fft.irfftn,"numpy.fft.irfftn#fft.irfftn(a,s=None,axes=None,norm=None)[source]#Computes the inverse ofrfftn.This function computes the inverse of the N-dimensional discrete
Fourier Transform for real input over any number of axes in an
M-dimensional array by means of the Fast Fourier Transform (FFT).  In
other words,irfftn(rfftn(a),a.shape)==ato within numerical
accuracy. (Thea.shapeis necessary likelen(a)is forirfft,
and for the same reason.)The input should be ordered in the same way as is returned byrfftn,
i.e. as forirfftfor the final transformation axis, and as forifftnalong all the other axes.Parameters:aarray_likeInput array.ssequence of ints, optionalShape (length of each transformed axis) of the output
(s[0]refers to axis 0,s[1]to axis 1, etc.).sis also the
number of input points used along this axis, except for the last axis,
wheres[-1]//2+1points of the input are used.
Along any axis, if the shape indicated bysis smaller than that of
the input, the input is cropped.  If it is larger, the input is padded
with zeros. Ifsis not given, the shape of the input along the axes
specified by axes is used. Except for the last axis which is taken to
be2*(m-1)wheremis the length of the input along that axis.axessequence of ints, optionalAxes over which to compute the inverse FFT. If not given, the lastlen(s)axes are used, or all axes ifsis also not specified.
Repeated indices inaxesmeans that the inverse transform over that
axis is performed multiple times.norm{gbackwardh, gorthoh, gforwardh}, optionalNew in version 1.10.0.Normalization mode (seenumpy.fft). Default is gbackwardh.
Indicates which direction of the forward/backward pair of transforms
is scaled and with what normalization factor.New in version 1.20.0:The gbackwardh, gforwardh values were added.Returns:outndarrayThe truncated or zero-padded input, transformed along the axes
indicated byaxes, or by a combination ofsora,
as explained in the parameters section above.
The length of each transformed axis is as given by the corresponding
element ofs, or the length of the input in every axis except for the
last one ifsis not given.  In the final transformed axis the length
of the output whensis not given is2*(m-1)wheremis the
length of the final transformed axis of the input.  To get an odd
number of output points in the final axis,smust be specified.Raises:ValueErrorIfsandaxeshave different length.IndexErrorIf an element ofaxesis larger than than the number of axes ofa.See alsorfftnThe forward n-dimensional FFT of real input, of whichifftnis the inverse.fftThe one-dimensional FFT, with definitions and conventions used.irfftThe inverse of the one-dimensional FFT of real input.irfft2The inverse of the two-dimensional FFT of real input.NotesSeefftfor definitions and conventions used.Seerfftfor definitions and conventions used for real input.The correct interpretation of the hermitian input depends on the shape of
the original data, as given bys. This is because each input shape could
correspond to either an odd or even length signal. By default,irfftnassumes an even output length which puts the last entry at the Nyquist
frequency; aliasing with its symmetric counterpart. When performing the
final complex to real transform, the last value is thus treated as purely
real. To avoid losing information, the correct shape of the real inputmustbe given.Examples>>>a=np.zeros((3,2,2))>>>a[0,0,0]=3*2*2>>>np.fft.irfftn(a)array([[[1.,  1.],[1.,  1.]],[[1.,  1.],[1.,  1.]],[[1.,  1.],[1.,  1.]]])"
Numpy,fft,numpy.fft.hfft,"numpy.fft.hfft#fft.hfft(a,n=None,axis=-1,norm=None)[source]#Compute the FFT of a signal that has Hermitian symmetry, i.e., a real
spectrum.Parameters:aarray_likeThe input array.nint, optionalLength of the transformed axis of the output. Fornoutput
points,n//2+1input points are necessary.  If the input is
longer than this, it is cropped.  If it is shorter than this, it is
padded with zeros.  Ifnis not given, it is taken to be2*(m-1)wheremis the length of the input along the axis specified byaxis.axisint, optionalAxis over which to compute the FFT. If not given, the last
axis is used.norm{gbackwardh, gorthoh, gforwardh}, optionalNew in version 1.10.0.Normalization mode (seenumpy.fft). Default is gbackwardh.
Indicates which direction of the forward/backward pair of transforms
is scaled and with what normalization factor.New in version 1.20.0:The gbackwardh, gforwardh values were added.Returns:outndarrayThe truncated or zero-padded input, transformed along the axis
indicated byaxis, or the last one ifaxisis not specified.
The length of the transformed axis isn, or, ifnis not given,2*m-2wheremis the length of the transformed axis of
the input. To get an odd number of output points,nmust be
specified, for instance as2*m-1in the typical case,Raises:IndexErrorIfaxisis not a valid axis ofa.See alsorfftCompute the one-dimensional FFT for real input.ihfftThe inverse ofhfft.Noteshfft/ihfftare a pair analogous torfft/irfft, but for the
opposite case: here the signal has Hermitian symmetry in the time
domain and is real in the frequency domain. So here itfshfftfor
which you must supply the length of the result if it is to be odd.even:ihfft(hfft(a,2*len(a)-2))==a, within roundoff error,odd:ihfft(hfft(a,2*len(a)-1))==a, within roundoff error.The correct interpretation of the hermitian input depends on the length of
the original data, as given byn. This is because each input shape could
correspond to either an odd or even length signal. By default,hfftassumes an even output length which puts the last entry at the Nyquist
frequency; aliasing with its symmetric counterpart. By Hermitian symmetry,
the value is thus treated as purely real. To avoid losing information, the
shape of the full signalmustbe given.Examples>>>signal=np.array([1,2,3,4,3,2])>>>np.fft.fft(signal)array([15.+0.j,  -4.+0.j,   0.+0.j,  -1.-0.j,   0.+0.j,  -4.+0.j]) # may vary>>>np.fft.hfft(signal[:4])# Input first half of signalarray([15.,  -4.,   0.,  -1.,   0.,  -4.])>>>np.fft.hfft(signal,6)# Input entire signal and truncatearray([15.,  -4.,   0.,  -1.,   0.,  -4.])>>>signal=np.array([[1,1.j],[-1.j,2]])>>>np.conj(signal.T)-signal# check Hermitian symmetryarray([[ 0.-0.j,  -0.+0.j], # may vary[ 0.+0.j,  0.-0.j]])>>>freq_spectrum=np.fft.hfft(signal)>>>freq_spectrumarray([[ 1.,  1.],[ 2., -2.]])"
Numpy,fft,numpy.fft.ihfft,"numpy.fft.ihfft#fft.ihfft(a,n=None,axis=-1,norm=None)[source]#Compute the inverse FFT of a signal that has Hermitian symmetry.Parameters:aarray_likeInput array.nint, optionalLength of the inverse FFT, the number of points along
transformation axis in the input to use.  Ifnis smaller than
the length of the input, the input is cropped.  If it is larger,
the input is padded with zeros. Ifnis not given, the length of
the input along the axis specified byaxisis used.axisint, optionalAxis over which to compute the inverse FFT. If not given, the last
axis is used.norm{gbackwardh, gorthoh, gforwardh}, optionalNew in version 1.10.0.Normalization mode (seenumpy.fft). Default is gbackwardh.
Indicates which direction of the forward/backward pair of transforms
is scaled and with what normalization factor.New in version 1.20.0:The gbackwardh, gforwardh values were added.Returns:outcomplex ndarrayThe truncated or zero-padded input, transformed along the axis
indicated byaxis, or the last one ifaxisis not specified.
The length of the transformed axis isn//2+1.See alsohfft,irfftNoteshfft/ihfftare a pair analogous torfft/irfft, but for the
opposite case: here the signal has Hermitian symmetry in the time
domain and is real in the frequency domain. So here itfshfftfor
which you must supply the length of the result if it is to be odd:even:ihfft(hfft(a,2*len(a)-2))==a, within roundoff error,odd:ihfft(hfft(a,2*len(a)-1))==a, within roundoff error.Examples>>>spectrum=np.array([15,-4,0,-1,0,-4])>>>np.fft.ifft(spectrum)array([1.+0.j,  2.+0.j,  3.+0.j,  4.+0.j,  3.+0.j,  2.+0.j]) # may vary>>>np.fft.ihfft(spectrum)array([ 1.-0.j,  2.-0.j,  3.-0.j,  4.-0.j]) # may vary"
Numpy,fft,numpy.fft.fftfreq,"numpy.fft.fftfreq#fft.fftfreq(n,d=1.0)[source]#Return the Discrete Fourier Transform sample frequencies.The returned float arrayfcontains the frequency bin centers in cycles
per unit of the sample spacing (with zero at the start).  For instance, if
the sample spacing is in seconds, then the frequency unit is cycles/second.Given a window lengthnand a sample spacingd:f=[0,1,...,n/2-1,-n/2,...,-1]/(d*n)ifnisevenf=[0,1,...,(n-1)/2,-(n-1)/2,...,-1]/(d*n)ifnisoddParameters:nintWindow length.dscalar, optionalSample spacing (inverse of the sampling rate). Defaults to 1.Returns:fndarrayArray of lengthncontaining the sample frequencies.Examples>>>signal=np.array([-2,8,6,4,1,0,3,5],dtype=float)>>>fourier=np.fft.fft(signal)>>>n=signal.size>>>timestep=0.1>>>freq=np.fft.fftfreq(n,d=timestep)>>>freqarray([ 0.  ,  1.25,  2.5 , ..., -3.75, -2.5 , -1.25])"
Numpy,fft,numpy.fft.rfftfreq,"numpy.fft.rfftfreq#fft.rfftfreq(n,d=1.0)[source]#Return the Discrete Fourier Transform sample frequencies
(for usage with rfft, irfft).The returned float arrayfcontains the frequency bin centers in cycles
per unit of the sample spacing (with zero at the start).  For instance, if
the sample spacing is in seconds, then the frequency unit is cycles/second.Given a window lengthnand a sample spacingd:f=[0,1,...,n/2-1,n/2]/(d*n)ifnisevenf=[0,1,...,(n-1)/2-1,(n-1)/2]/(d*n)ifnisoddUnlikefftfreq(but likescipy.fftpack.rfftfreq)
the Nyquist frequency component is considered to be positive.Parameters:nintWindow length.dscalar, optionalSample spacing (inverse of the sampling rate). Defaults to 1.Returns:fndarrayArray of lengthn//2+1containing the sample frequencies.Examples>>>signal=np.array([-2,8,6,4,1,0,3,5,-3,4],dtype=float)>>>fourier=np.fft.rfft(signal)>>>n=signal.size>>>sample_rate=100>>>freq=np.fft.fftfreq(n,d=1./sample_rate)>>>freqarray([  0.,  10.,  20., ..., -30., -20., -10.])>>>freq=np.fft.rfftfreq(n,d=1./sample_rate)>>>freqarray([  0.,  10.,  20.,  30.,  40.,  50.])"
Numpy,fft,numpy.fft.fftshift,"numpy.fft.fftshift#fft.fftshift(x,axes=None)[source]#Shift the zero-frequency component to the center of the spectrum.This function swaps half-spaces for all axes listed (defaults to all).
Note thaty[0]is the Nyquist component only iflen(x)is even.Parameters:xarray_likeInput array.axesint or shape tuple, optionalAxes over which to shift.  Default is None, which shifts all axes.Returns:yndarrayThe shifted array.See alsoifftshiftThe inverse offftshift.Examples>>>freqs=np.fft.fftfreq(10,0.1)>>>freqsarray([ 0.,  1.,  2., ..., -3., -2., -1.])>>>np.fft.fftshift(freqs)array([-5., -4., -3., -2., -1.,  0.,  1.,  2.,  3.,  4.])Shift the zero-frequency component only along the second axis:>>>freqs=np.fft.fftfreq(9,d=1./9).reshape(3,3)>>>freqsarray([[ 0.,  1.,  2.],[ 3.,  4., -4.],[-3., -2., -1.]])>>>np.fft.fftshift(freqs,axes=(1,))array([[ 2.,  0.,  1.],[-4.,  3.,  4.],[-1., -3., -2.]])"
Numpy,fft,numpy.fft.ifftshift,"numpy.fft.ifftshift#fft.ifftshift(x,axes=None)[source]#The inverse offftshift. Although identical for even-lengthx, the
functions differ by one sample for odd-lengthx.Parameters:xarray_likeInput array.axesint or shape tuple, optionalAxes over which to calculate.  Defaults to None, which shifts all axes.Returns:yndarrayThe shifted array.See alsofftshiftShift zero-frequency component to the center of the spectrum.Examples>>>freqs=np.fft.fftfreq(9,d=1./9).reshape(3,3)>>>freqsarray([[ 0.,  1.,  2.],[ 3.,  4., -4.],[-3., -2., -1.]])>>>np.fft.ifftshift(np.fft.fftshift(freqs))array([[ 0.,  1.,  2.],[ 3.,  4., -4.],[-3., -2., -1.]])"
