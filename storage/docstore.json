{"docstore/metadata": {"accf5291-7bec-431d-bd78-2f7e23d4a347": {"doc_hash": "c42a769913b169f7106e3ff28c87f6b4f2bac8cb27e01769cc252f856aee40c1"}, "b7b4d7e4-c496-43c9-a1bb-e7f8f72937f0": {"doc_hash": "e4e1fc28814faaccb867372e17979d500d438647229b30d1c7dfc068a193ee44"}, "6bfaa769-0ed9-4763-9a51-7f4108888d69": {"doc_hash": "1599d4c8f4f6eeb4cf1409855fd68e5d736858d3678837aaa50f1a258f5ec421"}, "26e25ff7-3d0b-4782-a834-b91699881275": {"doc_hash": "00ea291bc417bd884d5e068fea4f0e1b1da6c51735f8327fa42915573f6e8379"}, "306d0757-d8e1-461e-9853-281177dc1033": {"doc_hash": "c28afcc2a05ebc6c7d3f3f6662dfe55dc74105de88623141ba625a17d6117bda"}, "c45770c6-24f2-41a4-b75b-69efd4ce462a": {"doc_hash": "4322b21b6d99567292d25ff1911cccfcfe73a88adb811fddeafb0ea4c3782847"}, "51a00fa3-f0b3-4a7b-94c3-dfc8c80af60a": {"doc_hash": "188561541ee66277b0212231b629c50fb5b4b58b85d3f2febd9eb8dfe5327933"}, "88a1e370-219c-4587-b26b-1bc2c82abb1c": {"doc_hash": "30c6ac00f32106bb643ed5427aac231dcd589e4b5cb4fd9f362b2b20c4557447"}, "f0981b41-11e4-439a-a647-f5d6b0d1fa44": {"doc_hash": "5a0f8f80aede76804c9489c35e2a3f81abce535d55e69e24c2af9ded83141ce9"}, "2bf38792-63b3-4269-9c73-499c09224d9c": {"doc_hash": "755b1d45bd029d9b3233131d8e2f25ddedfa9270ed98643699a043a06e0846ee"}, "2c0cf7cf-ff7f-40be-92f3-9b2dc3f32677": {"doc_hash": "5380d0f682330a92d583e779a524741c4d610a1dd3dd57bf790d7593d8c8529a"}, "c0114562-c484-4d04-a492-b936b4801e97": {"doc_hash": "a36da825674181c719912f21ad017aa502fe48594f87bf1fb2744e126bdaddb4"}, "bb912eaa-9ced-4ba5-a2fe-859c4614dc29": {"doc_hash": "f61f7e57dbbf354bf83e02f03d740b4eda28b68672214f0e72479cfd8293ed7b"}, "dafb0b0d-fafc-4624-aa61-6be42ec512e0": {"doc_hash": "ce952c90247fa4f0a399d2907ad638e64c8f29e092b97a863d61ef77f3b75f99"}, "b5d1a0c7-82fd-4b01-a6ad-ad6a4f597092": {"doc_hash": "c3b083ea44b7442fd1c95fe8e892faf4f77cfa1afe3b9bbfd2cd18c35fda55c7"}, "2d44903b-29ef-40b0-9263-33869ee118b1": {"doc_hash": "de487aede9b9c9aaf38811c989f9ef155a2a74085ba673067bf81d3fde67491e"}, "dfe74ba2-ec55-467a-818a-db46176c3532": {"doc_hash": "1b623ed160b4693126792b8af52f8fadfd3bdc17068140c2bd9e59cc18d86e12"}, "9595da32-3271-476f-93b0-d6a6671b8902": {"doc_hash": "4628e7cff58754ad9d908ee071c982bdcdc61568218404233bf6869f225541fc"}, "49857faf-a128-41e4-9ce6-ebef21c8d6bf": {"doc_hash": "c42a769913b169f7106e3ff28c87f6b4f2bac8cb27e01769cc252f856aee40c1"}, "cbf91180-6d6a-427c-9d4f-5eab3a62b3dd": {"doc_hash": "e4e1fc28814faaccb867372e17979d500d438647229b30d1c7dfc068a193ee44"}, "f4265113-3aed-4037-bc11-0e9d501c568f": {"doc_hash": "e186b609339add6ec8e74ea0b3d3b31c95a3e55fc7aeffea84c9c6d6c8e168a4"}, "999e401c-b196-4e08-bb37-8c38837eea17": {"doc_hash": "4b864b4818654d4111020e3913e605c37d84ec563a7fa573b709ac5d826baf17"}, "23f8e023-fac4-4bfc-97b0-35319f83d68c": {"doc_hash": "c4f904527a7f327c11a5de864c21b9f7cad97d6331ab302ed877a0d008b38dab"}, "98fe90a6-5979-4b97-b9fd-b87c67397f86": {"doc_hash": "051a2e71cca305225e4166871c1775f46084bf4b341998e278e4cdf2400ec2d3"}, "54422311-bbc0-4fe7-a6a7-54e46a4c8b31": {"doc_hash": "00d93dc1a4b23913c90c674ee734cf59ad1359d24e7a7f843923ff45d65ab274"}, "95174c95-cdb0-4127-8f92-44f08ef75521": {"doc_hash": "350d0ea0fec8b59a73eec65b63656c1637756ee00e6b0cce79523c0c651bb89e"}, "0efa5b0c-5b34-4421-8efe-e34c601c72d3": {"doc_hash": "841a531ba0aa49376027bf0d8237dd733931a4e721d3c3e40c606431c2179528"}, "bf2e2ebc-c495-48e6-acba-ce47e2e06fd4": {"doc_hash": "b176c543261e8196ce1041ebc5010572a063d4205b85fa6cb8da75c32156676e"}, "ac910914-f85a-4f82-9e4a-3c5618db0d1c": {"doc_hash": "188561541ee66277b0212231b629c50fb5b4b58b85d3f2febd9eb8dfe5327933"}, "d18a3604-75ba-4c87-b99b-09f237044326": {"doc_hash": "d4cb3b4d6f516421ab6a6739b5a4d74465fe6234a3c328ee94bcaaf406896127"}, "65d727ae-616a-4c61-9d01-2a675a185260": {"doc_hash": "4ad7746c0b353071de456c1b8cf2a61acc745650f0305de27892aaf833934c2a"}, "a5e3c63e-0bd5-4c1b-adeb-12087ea77d2e": {"doc_hash": "5a0f8f80aede76804c9489c35e2a3f81abce535d55e69e24c2af9ded83141ce9"}, "e7c391e6-fee3-4d4a-9eac-a0148fc63d10": {"doc_hash": "755b1d45bd029d9b3233131d8e2f25ddedfa9270ed98643699a043a06e0846ee"}, "2105398f-5911-4912-9559-543baffa23fa": {"doc_hash": "5380d0f682330a92d583e779a524741c4d610a1dd3dd57bf790d7593d8c8529a"}, "7d6e7d7f-0152-4baa-aa0d-80b54aa5d71a": {"doc_hash": "d38e2d2d4261056f34e5a3ce40eaeff382d2ece4ed25f1e7af1fcd15dae6dbdb"}, "0767020e-4325-49e6-9f47-a24807d74237": {"doc_hash": "6d1b2794843ca6a0c2313e31bc26913b3c61331f0a114974a959dbfb69b80e34"}, "c773aabc-06b5-419a-9229-1af15abb87ec": {"doc_hash": "a01a03d4d4a5476b20c30a78db563cd832efc978da35508ec008ee45b65542ab"}, "58fe08ae-4c47-42ed-a60e-999b0c004aae": {"doc_hash": "5ec5aea8811876d84fdec825ace4f0a8b7f0ab11630223b721d2ccd522afc865"}, "fb2e8bd0-e88b-4d7e-bc30-4e284ead9f38": {"doc_hash": "ce952c90247fa4f0a399d2907ad638e64c8f29e092b97a863d61ef77f3b75f99"}, "7311894b-ca9b-42eb-a466-32ea75773860": {"doc_hash": "c3b083ea44b7442fd1c95fe8e892faf4f77cfa1afe3b9bbfd2cd18c35fda55c7"}, "4db49a9a-30bf-4cc1-9975-09e14a8e2946": {"doc_hash": "de487aede9b9c9aaf38811c989f9ef155a2a74085ba673067bf81d3fde67491e"}, "4568c442-3a88-48d5-997d-c73633f1c10f": {"doc_hash": "1b623ed160b4693126792b8af52f8fadfd3bdc17068140c2bd9e59cc18d86e12"}, "3ecafc0d-addb-4d49-9533-6bc4b690642b": {"doc_hash": "4628e7cff58754ad9d908ee071c982bdcdc61568218404233bf6869f225541fc"}}, "docstore/data": {"49857faf-a128-41e4-9ce6-ebef21c8d6bf": {"__data__": {"text": "\u3010Name\u3011Numpy\u3010Chapter\u3011fft\u3010Section\u3011numpy.fft.fft\u3010Content\u3011numpy.fft.fft#fft.fft(a,n=None,axis=-1,norm=None)[source]#Compute the one-dimensional discrete Fourier Transform.This function computes the one-dimensionaln-point discrete Fourier\nTransform (DFT) with the efficient Fast Fourier Transform (FFT)\nalgorithm [CT].Parameters:aarray_likeInput array, can be complex.nint, optionalLength of the transformed axis of the output.\nIfnis smaller than the length of the input, the input is cropped.\nIf it is larger, the input is padded with zeros.  Ifnis not given,\nthe length of the input along the axis specified byaxisis used.axisint, optionalAxis over which to compute the FFT.  If not given, the last axis is\nused.norm{\u201cbackward\u201d, \u201cortho\u201d, \u201cforward\u201d}, optionalNew in version 1.10.0.Normalization mode (seenumpy.fft). Default is \u201cbackward\u201d.\nIndicates which direction of the forward/backward pair of transforms\nis scaled and with what normalization factor.New in version 1.20.0:The \u201cbackward\u201d, \u201cforward\u201d values were added.Returns:outcomplex ndarrayThe truncated or zero-padded input, transformed along the axis\nindicated byaxis, or the last one ifaxisis not specified.Raises:IndexErrorIfaxisis not a valid axis ofa.See alsonumpy.fftfor definition of the DFT and conventions used.ifftThe inverse offft.fft2The two-dimensional FFT.fftnThen-dimensional FFT.rfftnThen-dimensional FFT of real input.fftfreqFrequency bins for given FFT parameters.NotesFFT (Fast Fourier Transform) refers to a way the discrete Fourier\nTransform (DFT) can be calculated efficiently, by using symmetries in the\ncalculated terms.  The symmetry is highest whennis a power of 2, and\nthe transform is therefore most efficient for these sizes.The DFT is defined, with the conventions used in this implementation, in\nthe documentation for thenumpy.fftmodule.References[CT]Cooley, James W., and John W. Tukey, 1965, \u201cAn algorithm for the\nmachine calculation of complex Fourier series,\u201dMath. Comput.19: 297-301.Examples>>>np.fft.fft(np.exp(2j*np.pi*np.arange(8)/8))array([-2.33486982e-16+1.14423775e-17j,  8.00000000e+00-1.25557246e-15j,2.33486982e-16+2.33486982e-16j,  0.00000000e+00+1.22464680e-16j,-1.14423775e-17+2.33486982e-16j,  0.00000000e+00+5.20784380e-16j,1.14423775e-17+1.14423775e-17j,  0.00000000e+00+1.22464680e-16j])In this example, real input has an FFT which is Hermitian, i.e., symmetric\nin the real part and anti-symmetric in the imaginary part, as described in\nthenumpy.fftdocumentation:>>>importmatplotlib.pyplotasplt>>>t=np.arange(256)>>>sp=np.fft.fft(np.sin(t))>>>freq=np.fft.fftfreq(t.shape[-1])>>>plt.plot(freq,sp.real,freq,sp.imag)[<matplotlib.lines.Line2D object at 0x...>, <matplotlib.lines.Line2D object at 0x...>]>>>plt.show()", "doc_id": "49857faf-a128-41e4-9ce6-ebef21c8d6bf", "embedding": null, "doc_hash": "c42a769913b169f7106e3ff28c87f6b4f2bac8cb27e01769cc252f856aee40c1", "extra_info": null, "node_info": {"start": 0, "end": 2716, "_node_type": "1"}, "relationships": {"1": "accf5291-7bec-431d-bd78-2f7e23d4a347"}}, "__type__": "1"}, "cbf91180-6d6a-427c-9d4f-5eab3a62b3dd": {"__data__": {"text": "\u3010Name\u3011Numpy\u3010Chapter\u3011fft\u3010Section\u3011numpy.fft.ifft\u3010Content\u3011numpy.fft.ifft#fft.ifft(a,n=None,axis=-1,norm=None)[source]#Compute the one-dimensional inverse discrete Fourier Transform.This function computes the inverse of the one-dimensionaln-point\ndiscrete Fourier transform computed byfft.  In other words,ifft(fft(a))==ato within numerical accuracy.\nFor a general description of the algorithm and definitions,\nseenumpy.fft.The input should be ordered in the same way as is returned byfft,\ni.e.,a[0]should contain the zero frequency term,a[1:n//2]should contain the positive-frequency terms,a[n//2+1:]should contain the negative-frequency terms, in\nincreasing order starting from the most negative frequency.For an even number of input points,A[n//2]represents the sum of\nthe values at the positive and negative Nyquist frequencies, as the two\nare aliased together. Seenumpy.fftfor details.Parameters:aarray_likeInput array, can be complex.nint, optionalLength of the transformed axis of the output.\nIfnis smaller than the length of the input, the input is cropped.\nIf it is larger, the input is padded with zeros.  Ifnis not given,\nthe length of the input along the axis specified byaxisis used.\nSee notes about padding issues.axisint, optionalAxis over which to compute the inverse DFT.  If not given, the last\naxis is used.norm{\u201cbackward\u201d, \u201cortho\u201d, \u201cforward\u201d}, optionalNew in version 1.10.0.Normalization mode (seenumpy.fft). Default is \u201cbackward\u201d.\nIndicates which direction of the forward/backward pair of transforms\nis scaled and with what normalization factor.New in version 1.20.0:The \u201cbackward\u201d, \u201cforward\u201d values were added.Returns:outcomplex ndarrayThe truncated or zero-padded input, transformed along the axis\nindicated byaxis, or the last one ifaxisis not specified.Raises:IndexErrorIfaxisis not a valid axis ofa.See alsonumpy.fftAn introduction, with definitions and general explanations.fftThe one-dimensional (forward) FFT, of whichifftis the inverseifft2The two-dimensional inverse FFT.ifftnThe n-dimensional inverse FFT.NotesIf the input parameternis larger than the size of the input, the input\nis padded by appending zeros at the end.  Even though this is the common\napproach, it might lead to surprising results.  If a different padding is\ndesired, it must be performed before callingifft.Examples>>>np.fft.ifft([0,4,0,0])array([ 1.+0.j,  0.+1.j, -1.+0.j,  0.-1.j]) # may varyCreate and plot a band-limited signal with random phases:>>>importmatplotlib.pyplotasplt>>>t=np.arange(400)>>>n=np.zeros((400,),dtype=complex)>>>n[40:60]=np.exp(1j*np.random.uniform(0,2*np.pi,(20,)))>>>s=np.fft.ifft(n)>>>plt.plot(t,s.real,label='real')[<matplotlib.lines.Line2D object at ...>]>>>plt.plot(t,s.imag,'--',label='imaginary')[<matplotlib.lines.Line2D object at ...>]>>>plt.legend()<matplotlib.legend.Legend object at ...>>>>plt.show()", "doc_id": "cbf91180-6d6a-427c-9d4f-5eab3a62b3dd", "embedding": null, "doc_hash": "e4e1fc28814faaccb867372e17979d500d438647229b30d1c7dfc068a193ee44", "extra_info": null, "node_info": {"start": 0, "end": 2838, "_node_type": "1"}, "relationships": {"1": "b7b4d7e4-c496-43c9-a1bb-e7f8f72937f0"}}, "__type__": "1"}, "f4265113-3aed-4037-bc11-0e9d501c568f": {"__data__": {"text": "\u3010Name\u3011Numpy\u3010Chapter\u3011fft\u3010Section\u3011numpy.fft.fft2\u3010Content\u3011numpy.fft.fft2#fft.fft2(a,s=None,axes=(-2,-1),norm=None)[source]#Compute the 2-dimensional discrete Fourier Transform.This function computes then-dimensional discrete Fourier Transform\nover any axes in anM-dimensional array by means of the\nFast Fourier Transform (FFT).  By default, the transform is computed over\nthe last two axes of the input array, i.e., a 2-dimensional FFT.Parameters:aarray_likeInput array, can be complexssequence of ints, optionalShape (length of each transformed axis) of the output\n(s[0]refers to axis 0,s[1]to axis 1, etc.).\nThis corresponds tonforfft(x,n).\nAlong each axis, if the given shape is smaller than that of the input,\nthe input is cropped.  If it is larger, the input is padded with zeros.\nifsis not given, the shape of the input along the axes specified\nbyaxesis used.axessequence of ints, optionalAxes over which to compute the FFT.  If not given, the last two\naxes are used.  A repeated index inaxesmeans the transform over\nthat axis is performed multiple times.  A one-element sequence means\nthat a one-dimensional FFT is performed.norm{\u201cbackward\u201d, \u201cortho\u201d, \u201cforward\u201d}, optionalNew in version 1.10.0.Normalization mode (seenumpy.fft). Default is \u201cbackward\u201d.\nIndicates which direction of the forward/backward pair of transforms\nis scaled and with what normalization factor.New in version 1.20.0:The \u201cbackward\u201d, \u201cforward\u201d values were added.Returns:outcomplex ndarrayThe truncated or zero-padded input, transformed along the axes\nindicated byaxes, or the last two axes ifaxesis not given.Raises:ValueErrorIfsandaxeshave different length, oraxesnot given andlen(s)!=2.IndexErrorIf an element ofaxesis larger than than the number of axes ofa.See alsonumpy.fftOverall view of discrete Fourier transforms, with definitions and conventions used.ifft2The inverse two-dimensional FFT.fftThe one-dimensional FFT.fftnThen-dimensional FFT.fftshiftShifts zero-frequency terms to the center of the array. For two-dimensional input, swaps first and third quadrants, and second and fourth quadrants.Notesfft2is justfftnwith a different default foraxes.The output, analogously tofft, contains the term for zero frequency in\nthe low-order corner of the transformed axes, the positive frequency terms\nin the first half of these axes, the term for the Nyquist frequency in the\nmiddle of the axes and the negative frequency terms in the second half of\nthe axes, in order of decreasingly negative frequency.Seefftnfor details and a plotting example, andnumpy.fftfor\ndefinitions and conventions used.Examples>>>a=np.mgrid[:5,:5][0]>>>np.fft.fft2(a)array([[ 50.  +0.j        ,   0.  +0.j        ,   0.  +0.j        , # may vary0.  +0.j        ,   0.  +0.j        ],[-12.5+17.20477401j,   0.  +0.j        ,   0.  +0.j        ,0.  +0.j        ,   0.  +0.j        ],[-12.5 +4.0614962j ,   0.  +0.j        ,   0.  +0.j        ,0.  +0.j        ,   0. ", "doc_id": "f4265113-3aed-4037-bc11-0e9d501c568f", "embedding": null, "doc_hash": "e186b609339add6ec8e74ea0b3d3b31c95a3e55fc7aeffea84c9c6d6c8e168a4", "extra_info": null, "node_info": {"start": 0, "end": 2918, "_node_type": "1"}, "relationships": {"1": "6bfaa769-0ed9-4763-9a51-7f4108888d69", "3": "999e401c-b196-4e08-bb37-8c38837eea17"}}, "__type__": "1"}, "999e401c-b196-4e08-bb37-8c38837eea17": {"__data__": {"text": ",   0.  +0.j        , # may vary0.  +0.j        ,   0.  +0.j        ],[-12.5+17.20477401j,   0.  +0.j        ,   0.  +0.j        ,0.  +0.j        ,   0.  +0.j        ],[-12.5 +4.0614962j ,   0.  +0.j        ,   0.  +0.j        ,0.  +0.j        ,   0.  +0.j        ],[-12.5 -4.0614962j ,   0.  +0.j        ,   0.  +0.j        ,0.  +0.j        ,   0.  +0.j        ],[-12.5-17.20477401j,   0.  +0.j        ,   0.  +0.j        ,0.  +0.j        ,   0.  +0.j        ]])", "doc_id": "999e401c-b196-4e08-bb37-8c38837eea17", "embedding": null, "doc_hash": "4b864b4818654d4111020e3913e605c37d84ec563a7fa573b709ac5d826baf17", "extra_info": null, "node_info": {"start": 2667, "end": 3130, "_node_type": "1"}, "relationships": {"1": "6bfaa769-0ed9-4763-9a51-7f4108888d69", "2": "f4265113-3aed-4037-bc11-0e9d501c568f"}}, "__type__": "1"}, "23f8e023-fac4-4bfc-97b0-35319f83d68c": {"__data__": {"text": "\u3010Name\u3011Numpy\u3010Chapter\u3011fft\u3010Section\u3011numpy.fft.ifft2\u3010Content\u3011numpy.fft.ifft2#fft.ifft2(a,s=None,axes=(-2,-1),norm=None)[source]#Compute the 2-dimensional inverse discrete Fourier Transform.This function computes the inverse of the 2-dimensional discrete Fourier\nTransform over any number of axes in an M-dimensional array by means of\nthe Fast Fourier Transform (FFT).  In other words,ifft2(fft2(a))==ato within numerical accuracy.  By default, the inverse transform is\ncomputed over the last two axes of the input array.The input, analogously toifft, should be ordered in the same way as is\nreturned byfft2, i.e. it should have the term for zero frequency\nin the low-order corner of the two axes, the positive frequency terms in\nthe first half of these axes, the term for the Nyquist frequency in the\nmiddle of the axes and the negative frequency terms in the second half of\nboth axes, in order of decreasingly negative frequency.Parameters:aarray_likeInput array, can be complex.ssequence of ints, optionalShape (length of each axis) of the output (s[0]refers to axis 0,s[1]to axis 1, etc.).  This corresponds tonforifft(x,n).\nAlong each axis, if the given shape is smaller than that of the input,\nthe input is cropped.  If it is larger, the input is padded with zeros.\nifsis not given, the shape of the input along the axes specified\nbyaxesis used.  See notes for issue onifftzero padding.axessequence of ints, optionalAxes over which to compute the FFT.  If not given, the last two\naxes are used.  A repeated index inaxesmeans the transform over\nthat axis is performed multiple times.  A one-element sequence means\nthat a one-dimensional FFT is performed.norm{\u201cbackward\u201d, \u201cortho\u201d, \u201cforward\u201d}, optionalNew in version 1.10.0.Normalization mode (seenumpy.fft). Default is \u201cbackward\u201d.\nIndicates which direction of the forward/backward pair of transforms\nis scaled and with what normalization factor.New in version 1.20.0:The \u201cbackward\u201d, \u201cforward\u201d values were added.Returns:outcomplex ndarrayThe truncated or zero-padded input, transformed along the axes\nindicated byaxes, or the last two axes ifaxesis not given.Raises:ValueErrorIfsandaxeshave different length, oraxesnot given andlen(s)!=2.IndexErrorIf an element ofaxesis larger than than the number of axes ofa.See alsonumpy.fftOverall view of discrete Fourier transforms, with definitions and conventions used.fft2The forward 2-dimensional FFT, of whichifft2is the inverse.ifftnThe inverse of then-dimensional FFT.fftThe one-dimensional FFT.ifftThe one-dimensional inverse FFT.Notesifft2is justifftnwith a different default foraxes.Seeifftnfor details and a plotting example, andnumpy.fftfor\ndefinition and conventions used.Zero-padding, analogously withifft, is performed by appending zeros to\nthe input along the specified dimension.  Although this is the common\napproach, it might lead to surprising results.  If another form of zero\npadding is desired, it must be performed beforeifft2is called.Examples>>>a=4*np.eye(4)>>>np.fft.ifft2(a)array([[1.+0.j,  0.+0.j,  0.+0.j,  0.+0.j], # may vary[0.+0.j,  0.+0.j,  0.+0.j,  1.+0.j],[0.+0.j,  0.+0.j,  1.+0.j,  0.+0.j],[0.+0.j,  1.+0.j,  0.+0.j, ", "doc_id": "23f8e023-fac4-4bfc-97b0-35319f83d68c", "embedding": null, "doc_hash": "c4f904527a7f327c11a5de864c21b9f7cad97d6331ab302ed877a0d008b38dab", "extra_info": null, "node_info": {"start": 0, "end": 3142, "_node_type": "1"}, "relationships": {"1": "26e25ff7-3d0b-4782-a834-b91699881275", "3": "98fe90a6-5979-4b97-b9fd-b87c67397f86"}}, "__type__": "1"}, "98fe90a6-5979-4b97-b9fd-b87c67397f86": {"__data__": {"text": "to\nthe input along the specified dimension.  Although this is the common\napproach, it might lead to surprising results.  If another form of zero\npadding is desired, it must be performed beforeifft2is called.Examples>>>a=4*np.eye(4)>>>np.fft.ifft2(a)array([[1.+0.j,  0.+0.j,  0.+0.j,  0.+0.j], # may vary[0.+0.j,  0.+0.j,  0.+0.j,  1.+0.j],[0.+0.j,  0.+0.j,  1.+0.j,  0.+0.j],[0.+0.j,  1.+0.j,  0.+0.j,  0.+0.j]])", "doc_id": "98fe90a6-5979-4b97-b9fd-b87c67397f86", "embedding": null, "doc_hash": "051a2e71cca305225e4166871c1775f46084bf4b341998e278e4cdf2400ec2d3", "extra_info": null, "node_info": {"start": 2740, "end": 3152, "_node_type": "1"}, "relationships": {"1": "26e25ff7-3d0b-4782-a834-b91699881275", "2": "23f8e023-fac4-4bfc-97b0-35319f83d68c"}}, "__type__": "1"}, "54422311-bbc0-4fe7-a6a7-54e46a4c8b31": {"__data__": {"text": "\u3010Name\u3011Numpy\u3010Chapter\u3011fft\u3010Section\u3011numpy.fft.fftn\u3010Content\u3011numpy.fft.fftn#fft.fftn(a,s=None,axes=None,norm=None)[source]#Compute the N-dimensional discrete Fourier Transform.This function computes theN-dimensional discrete Fourier Transform over\nany number of axes in anM-dimensional array by means of the Fast Fourier\nTransform (FFT).Parameters:aarray_likeInput array, can be complex.ssequence of ints, optionalShape (length of each transformed axis) of the output\n(s[0]refers to axis 0,s[1]to axis 1, etc.).\nThis corresponds tonforfft(x,n).\nAlong any axis, if the given shape is smaller than that of the input,\nthe input is cropped.  If it is larger, the input is padded with zeros.\nifsis not given, the shape of the input along the axes specified\nbyaxesis used.axessequence of ints, optionalAxes over which to compute the FFT.  If not given, the lastlen(s)axes are used, or all axes ifsis also not specified.\nRepeated indices inaxesmeans that the transform over that axis is\nperformed multiple times.norm{\u201cbackward\u201d, \u201cortho\u201d, \u201cforward\u201d}, optionalNew in version 1.10.0.Normalization mode (seenumpy.fft). Default is \u201cbackward\u201d.\nIndicates which direction of the forward/backward pair of transforms\nis scaled and with what normalization factor.New in version 1.20.0:The \u201cbackward\u201d, \u201cforward\u201d values were added.Returns:outcomplex ndarrayThe truncated or zero-padded input, transformed along the axes\nindicated byaxes, or by a combination ofsanda,\nas explained in the parameters section above.Raises:ValueErrorIfsandaxeshave different length.IndexErrorIf an element ofaxesis larger than than the number of axes ofa.See alsonumpy.fftOverall view of discrete Fourier transforms, with definitions and conventions used.ifftnThe inverse offftn, the inversen-dimensional FFT.fftThe one-dimensional FFT, with definitions and conventions used.rfftnThen-dimensional FFT of real input.fft2The two-dimensional FFT.fftshiftShifts zero-frequency terms to centre of arrayNotesThe output, analogously tofft, contains the term for zero frequency in\nthe low-order corner of all axes, the positive frequency terms in the\nfirst half of all axes, the term for the Nyquist frequency in the middle\nof all axes and the negative frequency terms in the second half of all\naxes, in order of decreasingly negative frequency.Seenumpy.fftfor details, definitions and conventions used.Examples>>>a=np.mgrid[:3,:3,:3][0]>>>np.fft.fftn(a,axes=(1,2))array([[[ 0.+0.j,   0.+0.j,   0.+0.j], # may vary[ 0.+0.j,   0.+0.j,   0.+0.j],[ 0.+0.j,   0.+0.j,   0.+0.j]],[[ 9.+0.j,   0.+0.j,   0.+0.j],[ 0.+0.j,   0.+0.j,   0.+0.j],[ 0.+0.j,   0.+0.j,   0.+0.j]],[[18.+0.j,   0.+0.j,   0.+0.j],[ 0.+0.j,   0.+0.j,   0.+0.j],[ 0.+0.j,   0.+0.j,   0.+0.j]]])>>>np.fft.fftn(a,(2,2),axes=(0,1))array([[[ 2.+0.j,  2.+0.j,  2.+0.j], # may", "doc_id": "54422311-bbc0-4fe7-a6a7-54e46a4c8b31", "embedding": null, "doc_hash": "00d93dc1a4b23913c90c674ee734cf59ad1359d24e7a7f843923ff45d65ab274", "extra_info": null, "node_info": {"start": 0, "end": 2781, "_node_type": "1"}, "relationships": {"1": "306d0757-d8e1-461e-9853-281177dc1033", "3": "95174c95-cdb0-4127-8f92-44f08ef75521"}}, "__type__": "1"}, "95174c95-cdb0-4127-8f92-44f08ef75521": {"__data__": {"text": "  0.+0.j,   0.+0.j],[ 0.+0.j,   0.+0.j,   0.+0.j],[ 0.+0.j,   0.+0.j,   0.+0.j]],[[18.+0.j,   0.+0.j,   0.+0.j],[ 0.+0.j,   0.+0.j,   0.+0.j],[ 0.+0.j,   0.+0.j,   0.+0.j]]])>>>np.fft.fftn(a,(2,2),axes=(0,1))array([[[ 2.+0.j,  2.+0.j,  2.+0.j], # may vary[ 0.+0.j,  0.+0.j,  0.+0.j]],[[-2.+0.j, -2.+0.j, -2.+0.j],[ 0.+0.j,  0.+0.j,  0.+0.j]]])>>>importmatplotlib.pyplotasplt>>>[X,Y]=np.meshgrid(2*np.pi*np.arange(200)/12,...2*np.pi*np.arange(200)/34)>>>S=np.sin(X)+np.cos(Y)+np.random.uniform(0,1,X.shape)>>>FS=np.fft.fftn(S)>>>plt.imshow(np.log(np.abs(np.fft.fftshift(FS))**2))<matplotlib.image.AxesImage object at 0x...>>>>plt.show()", "doc_id": "95174c95-cdb0-4127-8f92-44f08ef75521", "embedding": null, "doc_hash": "350d0ea0fec8b59a73eec65b63656c1637756ee00e6b0cce79523c0c651bb89e", "extra_info": null, "node_info": {"start": 2531, "end": 3166, "_node_type": "1"}, "relationships": {"1": "306d0757-d8e1-461e-9853-281177dc1033", "2": "54422311-bbc0-4fe7-a6a7-54e46a4c8b31"}}, "__type__": "1"}, "0efa5b0c-5b34-4421-8efe-e34c601c72d3": {"__data__": {"text": "\u3010Name\u3011Numpy\u3010Chapter\u3011fft\u3010Section\u3011numpy.fft.ifftn\u3010Content\u3011numpy.fft.ifftn#fft.ifftn(a,s=None,axes=None,norm=None)[source]#Compute the N-dimensional inverse discrete Fourier Transform.This function computes the inverse of the N-dimensional discrete\nFourier Transform over any number of axes in an M-dimensional array by\nmeans of the Fast Fourier Transform (FFT).  In other words,ifftn(fftn(a))==ato within numerical accuracy.\nFor a description of the definitions and conventions used, seenumpy.fft.The input, analogously toifft, should be ordered in the same way as is\nreturned byfftn, i.e. it should have the term for zero frequency\nin all axes in the low-order corner, the positive frequency terms in the\nfirst half of all axes, the term for the Nyquist frequency in the middle\nof all axes and the negative frequency terms in the second half of all\naxes, in order of decreasingly negative frequency.Parameters:aarray_likeInput array, can be complex.ssequence of ints, optionalShape (length of each transformed axis) of the output\n(s[0]refers to axis 0,s[1]to axis 1, etc.).\nThis corresponds tonforifft(x,n).\nAlong any axis, if the given shape is smaller than that of the input,\nthe input is cropped.  If it is larger, the input is padded with zeros.\nifsis not given, the shape of the input along the axes specified\nbyaxesis used.  See notes for issue onifftzero padding.axessequence of ints, optionalAxes over which to compute the IFFT.  If not given, the lastlen(s)axes are used, or all axes ifsis also not specified.\nRepeated indices inaxesmeans that the inverse transform over that\naxis is performed multiple times.norm{\u201cbackward\u201d, \u201cortho\u201d, \u201cforward\u201d}, optionalNew in version 1.10.0.Normalization mode (seenumpy.fft). Default is \u201cbackward\u201d.\nIndicates which direction of the forward/backward pair of transforms\nis scaled and with what normalization factor.New in version 1.20.0:The \u201cbackward\u201d, \u201cforward\u201d values were added.Returns:outcomplex ndarrayThe truncated or zero-padded input, transformed along the axes\nindicated byaxes, or by a combination ofsora,\nas explained in the parameters section above.Raises:ValueErrorIfsandaxeshave different length.IndexErrorIf an element ofaxesis larger than than the number of axes ofa.See alsonumpy.fftOverall view of discrete Fourier transforms, with definitions and conventions used.fftnThe forwardn-dimensional FFT, of whichifftnis the inverse.ifftThe one-dimensional inverse FFT.ifft2The two-dimensional inverse FFT.ifftshiftUndoesfftshift, shifts zero-frequency terms to beginning of array.NotesSeenumpy.fftfor definitions and conventions used.Zero-padding, analogously withifft, is performed by appending zeros to\nthe input along the specified dimension.  Although this is the common\napproach, it might lead to surprising results.  If another form of zero\npadding is desired, it must be performed beforeifftnis called.Examples>>>a=np.eye(4)>>>np.fft.ifftn(np.fft.fftn(a,axes=(0,)),axes=(1,))array([[1.+0.j,  0.+0.j,  0.+0.j,  0.+0.j], # may vary[0.+0.j,  1.+0.j,  0.+0.j,  0.+0.j],[0.+0.j,  0.+0.j,  1.+0.j,  0.+0.j],[0.+0.j,  0.+0.j,  0.+0.j,  1.+0.j]])Create and plot an image with band-limited frequency", "doc_id": "0efa5b0c-5b34-4421-8efe-e34c601c72d3", "embedding": null, "doc_hash": "841a531ba0aa49376027bf0d8237dd733931a4e721d3c3e40c606431c2179528", "extra_info": null, "node_info": {"start": 0, "end": 3152, "_node_type": "1"}, "relationships": {"1": "c45770c6-24f2-41a4-b75b-69efd4ce462a", "3": "bf2e2ebc-c495-48e6-acba-ce47e2e06fd4"}}, "__type__": "1"}, "bf2e2ebc-c495-48e6-acba-ce47e2e06fd4": {"__data__": {"text": "is desired, it must be performed beforeifftnis called.Examples>>>a=np.eye(4)>>>np.fft.ifftn(np.fft.fftn(a,axes=(0,)),axes=(1,))array([[1.+0.j,  0.+0.j,  0.+0.j,  0.+0.j], # may vary[0.+0.j,  1.+0.j,  0.+0.j,  0.+0.j],[0.+0.j,  0.+0.j,  1.+0.j,  0.+0.j],[0.+0.j,  0.+0.j,  0.+0.j,  1.+0.j]])Create and plot an image with band-limited frequency content:>>>importmatplotlib.pyplotasplt>>>n=np.zeros((200,200),dtype=complex)>>>n[60:80,20:40]=np.exp(1j*np.random.uniform(0,2*np.pi,(20,20)))>>>im=np.fft.ifftn(n).real>>>plt.imshow(im)<matplotlib.image.AxesImage object at 0x...>>>>plt.show()", "doc_id": "bf2e2ebc-c495-48e6-acba-ce47e2e06fd4", "embedding": null, "doc_hash": "b176c543261e8196ce1041ebc5010572a063d4205b85fa6cb8da75c32156676e", "extra_info": null, "node_info": {"start": 2810, "end": 3395, "_node_type": "1"}, "relationships": {"1": "c45770c6-24f2-41a4-b75b-69efd4ce462a", "2": "0efa5b0c-5b34-4421-8efe-e34c601c72d3"}}, "__type__": "1"}, "ac910914-f85a-4f82-9e4a-3c5618db0d1c": {"__data__": {"text": "\u3010Name\u3011Numpy\u3010Chapter\u3011fft\u3010Section\u3011numpy.fft.rfft\u3010Content\u3011numpy.fft.rfft#fft.rfft(a,n=None,axis=-1,norm=None)[source]#Compute the one-dimensional discrete Fourier Transform for real input.This function computes the one-dimensionaln-point discrete Fourier\nTransform (DFT) of a real-valued array by means of an efficient algorithm\ncalled the Fast Fourier Transform (FFT).Parameters:aarray_likeInput arraynint, optionalNumber of points along transformation axis in the input to use.\nIfnis smaller than the length of the input, the input is cropped.\nIf it is larger, the input is padded with zeros. Ifnis not given,\nthe length of the input along the axis specified byaxisis used.axisint, optionalAxis over which to compute the FFT. If not given, the last axis is\nused.norm{\u201cbackward\u201d, \u201cortho\u201d, \u201cforward\u201d}, optionalNew in version 1.10.0.Normalization mode (seenumpy.fft). Default is \u201cbackward\u201d.\nIndicates which direction of the forward/backward pair of transforms\nis scaled and with what normalization factor.New in version 1.20.0:The \u201cbackward\u201d, \u201cforward\u201d values were added.Returns:outcomplex ndarrayThe truncated or zero-padded input, transformed along the axis\nindicated byaxis, or the last one ifaxisis not specified.\nIfnis even, the length of the transformed axis is(n/2)+1.\nIfnis odd, the length is(n+1)/2.Raises:IndexErrorIfaxisis not a valid axis ofa.See alsonumpy.fftFor definition of the DFT and conventions used.irfftThe inverse ofrfft.fftThe one-dimensional FFT of general (complex) input.fftnThen-dimensional FFT.rfftnThen-dimensional FFT of real input.NotesWhen the DFT is computed for purely real input, the output is\nHermitian-symmetric, i.e. the negative frequency terms are just the complex\nconjugates of the corresponding positive-frequency terms, and the\nnegative-frequency terms are therefore redundant.  This function does not\ncompute the negative frequency terms, and the length of the transformed\naxis of the output is thereforen//2+1.WhenA=rfft(a)and fs is the sampling frequency,A[0]contains\nthe zero-frequency term 0*fs, which is real due to Hermitian symmetry.Ifnis even,A[-1]contains the term representing both positive\nand negative Nyquist frequency (+fs/2 and -fs/2), and must also be purely\nreal. Ifnis odd, there is no term at fs/2;A[-1]contains\nthe largest positive frequency (fs/2*(n-1)/n), and is complex in the\ngeneral case.If the inputacontains an imaginary part, it is silently discarded.Examples>>>np.fft.fft([0,1,0,0])array([ 1.+0.j,  0.-1.j, -1.+0.j,  0.+1.j]) # may vary>>>np.fft.rfft([0,1,0,0])array([ 1.+0.j,  0.-1.j, -1.+0.j]) # may varyNotice how the final element of thefftoutput is the complex conjugate\nof the second element, for real input. Forrfft, this symmetry is\nexploited to compute only the non-negative frequency terms.", "doc_id": "ac910914-f85a-4f82-9e4a-3c5618db0d1c", "embedding": null, "doc_hash": "188561541ee66277b0212231b629c50fb5b4b58b85d3f2febd9eb8dfe5327933", "extra_info": null, "node_info": {"start": 0, "end": 2769, "_node_type": "1"}, "relationships": {"1": "51a00fa3-f0b3-4a7b-94c3-dfc8c80af60a"}}, "__type__": "1"}, "d18a3604-75ba-4c87-b99b-09f237044326": {"__data__": {"text": "\u3010Name\u3011Numpy\u3010Chapter\u3011fft\u3010Section\u3011numpy.fft.irfft\u3010Content\u3011numpy.fft.irfft#fft.irfft(a,n=None,axis=-1,norm=None)[source]#Computes the inverse ofrfft.This function computes the inverse of the one-dimensionaln-point\ndiscrete Fourier Transform of real input computed byrfft.\nIn other words,irfft(rfft(a),len(a))==ato within numerical\naccuracy. (See Notes below for whylen(a)is necessary here.)The input is expected to be in the form returned byrfft, i.e. the\nreal zero-frequency term followed by the complex positive frequency terms\nin order of increasing frequency.  Since the discrete Fourier Transform of\nreal input is Hermitian-symmetric, the negative frequency terms are taken\nto be the complex conjugates of the corresponding positive frequency terms.Parameters:aarray_likeThe input array.nint, optionalLength of the transformed axis of the output.\nFornoutput points,n//2+1input points are necessary.  If the\ninput is longer than this, it is cropped.  If it is shorter than this,\nit is padded with zeros.  Ifnis not given, it is taken to be2*(m-1)wheremis the length of the input along the axis\nspecified byaxis.axisint, optionalAxis over which to compute the inverse FFT. If not given, the last\naxis is used.norm{\u201cbackward\u201d, \u201cortho\u201d, \u201cforward\u201d}, optionalNew in version 1.10.0.Normalization mode (seenumpy.fft). Default is \u201cbackward\u201d.\nIndicates which direction of the forward/backward pair of transforms\nis scaled and with what normalization factor.New in version 1.20.0:The \u201cbackward\u201d, \u201cforward\u201d values were added.Returns:outndarrayThe truncated or zero-padded input, transformed along the axis\nindicated byaxis, or the last one ifaxisis not specified.\nThe length of the transformed axis isn, or, ifnis not given,2*(m-1)wheremis the length of the transformed axis of the\ninput. To get an odd number of output points,nmust be specified.Raises:IndexErrorIfaxisis not a valid axis ofa.See alsonumpy.fftFor definition of the DFT and conventions used.rfftThe one-dimensional FFT of real input, of whichirfftis inverse.fftThe one-dimensional FFT.irfft2The inverse of the two-dimensional FFT of real input.irfftnThe inverse of then-dimensional FFT of real input.NotesReturns the real valuedn-point inverse discrete Fourier transform\nofa, whereacontains the non-negative frequency terms of a\nHermitian-symmetric sequence.nis the length of the result, not the\ninput.If you specify annsuch thatamust be zero-padded or truncated, the\nextra/removed values will be added/removed at high frequencies. One can\nthus resample a series tompoints via Fourier interpolation by:a_resamp=irfft(rfft(a),m).The correct interpretation of the hermitian input depends on the length of\nthe original data, as given byn. This is because each input shape could\ncorrespond to either an odd or even length signal. By default,irfftassumes an even output length which puts the last entry at the Nyquist\nfrequency; aliasing with its symmetric counterpart. By Hermitian symmetry,\nthe value is thus treated as purely real. To avoid losing information, the\ncorrect length of the real inputmustbe given.Examples>>>np.fft.ifft([1,-1j,-1,1j])array([0.+0.j,  1.+0.j,  0.+0.j,  0.+0.j]) # may vary>>>np.fft.irfft([1,-1j,-1])array([0.,  1.,  0.,  0.])Notice how the last term in the input to the ordinaryifftis the\ncomplex conjugate of the second term, and the output has", "doc_id": "d18a3604-75ba-4c87-b99b-09f237044326", "embedding": null, "doc_hash": "d4cb3b4d6f516421ab6a6739b5a4d74465fe6234a3c328ee94bcaaf406896127", "extra_info": null, "node_info": {"start": 0, "end": 3327, "_node_type": "1"}, "relationships": {"1": "88a1e370-219c-4587-b26b-1bc2c82abb1c", "3": "65d727ae-616a-4c61-9d01-2a675a185260"}}, "__type__": "1"}, "65d727ae-616a-4c61-9d01-2a675a185260": {"__data__": {"text": "to either an odd or even length signal. By default,irfftassumes an even output length which puts the last entry at the Nyquist\nfrequency; aliasing with its symmetric counterpart. By Hermitian symmetry,\nthe value is thus treated as purely real. To avoid losing information, the\ncorrect length of the real inputmustbe given.Examples>>>np.fft.ifft([1,-1j,-1,1j])array([0.+0.j,  1.+0.j,  0.+0.j,  0.+0.j]) # may vary>>>np.fft.irfft([1,-1j,-1])array([0.,  1.,  0.,  0.])Notice how the last term in the input to the ordinaryifftis the\ncomplex conjugate of the second term, and the output has zero imaginary\npart everywhere.  When callingirfft, the negative frequencies are not\nspecified, and the output array is purely real.", "doc_id": "65d727ae-616a-4c61-9d01-2a675a185260", "embedding": null, "doc_hash": "4ad7746c0b353071de456c1b8cf2a61acc745650f0305de27892aaf833934c2a", "extra_info": null, "node_info": {"start": 2742, "end": 3460, "_node_type": "1"}, "relationships": {"1": "88a1e370-219c-4587-b26b-1bc2c82abb1c", "2": "d18a3604-75ba-4c87-b99b-09f237044326"}}, "__type__": "1"}, "a5e3c63e-0bd5-4c1b-adeb-12087ea77d2e": {"__data__": {"text": "\u3010Name\u3011Numpy\u3010Chapter\u3011fft\u3010Section\u3011numpy.fft.rfft2\u3010Content\u3011numpy.fft.rfft2#fft.rfft2(a,s=None,axes=(-2,-1),norm=None)[source]#Compute the 2-dimensional FFT of a real array.Parameters:aarrayInput array, taken to be real.ssequence of ints, optionalShape of the FFT.axessequence of ints, optionalAxes over which to compute the FFT.norm{\u201cbackward\u201d, \u201cortho\u201d, \u201cforward\u201d}, optionalNew in version 1.10.0.Normalization mode (seenumpy.fft). Default is \u201cbackward\u201d.\nIndicates which direction of the forward/backward pair of transforms\nis scaled and with what normalization factor.New in version 1.20.0:The \u201cbackward\u201d, \u201cforward\u201d values were added.Returns:outndarrayThe result of the real 2-D FFT.See alsorfftnCompute the N-dimensional discrete Fourier Transform for real input.NotesThis is really justrfftnwith different default behavior.\nFor more details seerfftn.Examples>>>a=np.mgrid[:5,:5][0]>>>np.fft.rfft2(a)array([[ 50.  +0.j        ,   0.  +0.j        ,   0.  +0.j        ],[-12.5+17.20477401j,   0.  +0.j        ,   0.  +0.j        ],[-12.5 +4.0614962j ,   0.  +0.j        ,   0.  +0.j        ],[-12.5 -4.0614962j ,   0.  +0.j        ,   0.  +0.j        ],[-12.5-17.20477401j,   0.  +0.j        ,   0.  +0.j        ]])", "doc_id": "a5e3c63e-0bd5-4c1b-adeb-12087ea77d2e", "embedding": null, "doc_hash": "5a0f8f80aede76804c9489c35e2a3f81abce535d55e69e24c2af9ded83141ce9", "extra_info": null, "node_info": {"start": 0, "end": 1211, "_node_type": "1"}, "relationships": {"1": "f0981b41-11e4-439a-a647-f5d6b0d1fa44"}}, "__type__": "1"}, "e7c391e6-fee3-4d4a-9eac-a0148fc63d10": {"__data__": {"text": "\u3010Name\u3011Numpy\u3010Chapter\u3011fft\u3010Section\u3011numpy.fft.irfft2\u3010Content\u3011numpy.fft.irfft2#fft.irfft2(a,s=None,axes=(-2,-1),norm=None)[source]#Computes the inverse ofrfft2.Parameters:aarray_likeThe input arrayssequence of ints, optionalShape of the real output to the inverse FFT.axessequence of ints, optionalThe axes over which to compute the inverse fft.\nDefault is the last two axes.norm{\u201cbackward\u201d, \u201cortho\u201d, \u201cforward\u201d}, optionalNew in version 1.10.0.Normalization mode (seenumpy.fft). Default is \u201cbackward\u201d.\nIndicates which direction of the forward/backward pair of transforms\nis scaled and with what normalization factor.New in version 1.20.0:The \u201cbackward\u201d, \u201cforward\u201d values were added.Returns:outndarrayThe result of the inverse real 2-D FFT.See alsorfft2The forward two-dimensional FFT of real input, of whichirfft2is the inverse.rfftThe one-dimensional FFT for real input.irfftThe inverse of the one-dimensional FFT of real input.irfftnCompute the inverse of the N-dimensional FFT of real input.NotesThis is reallyirfftnwith different defaults.\nFor more details seeirfftn.Examples>>>a=np.mgrid[:5,:5][0]>>>A=np.fft.rfft2(a)>>>np.fft.irfft2(A,s=a.shape)array([[0., 0., 0., 0., 0.],[1., 1., 1., 1., 1.],[2., 2., 2., 2., 2.],[3., 3., 3., 3., 3.],[4., 4., 4., 4., 4.]])", "doc_id": "e7c391e6-fee3-4d4a-9eac-a0148fc63d10", "embedding": null, "doc_hash": "755b1d45bd029d9b3233131d8e2f25ddedfa9270ed98643699a043a06e0846ee", "extra_info": null, "node_info": {"start": 0, "end": 1258, "_node_type": "1"}, "relationships": {"1": "2bf38792-63b3-4269-9c73-499c09224d9c"}}, "__type__": "1"}, "2105398f-5911-4912-9559-543baffa23fa": {"__data__": {"text": "\u3010Name\u3011Numpy\u3010Chapter\u3011fft\u3010Section\u3011numpy.fft.rfftn\u3010Content\u3011numpy.fft.rfftn#fft.rfftn(a,s=None,axes=None,norm=None)[source]#Compute the N-dimensional discrete Fourier Transform for real input.This function computes the N-dimensional discrete Fourier Transform over\nany number of axes in an M-dimensional real array by means of the Fast\nFourier Transform (FFT).  By default, all axes are transformed, with the\nreal transform performed over the last axis, while the remaining\ntransforms are complex.Parameters:aarray_likeInput array, taken to be real.ssequence of ints, optionalShape (length along each transformed axis) to use from the input.\n(s[0]refers to axis 0,s[1]to axis 1, etc.).\nThe final element ofscorresponds tonforrfft(x,n), while\nfor the remaining axes, it corresponds tonforfft(x,n).\nAlong any axis, if the given shape is smaller than that of the input,\nthe input is cropped.  If it is larger, the input is padded with zeros.\nifsis not given, the shape of the input along the axes specified\nbyaxesis used.axessequence of ints, optionalAxes over which to compute the FFT.  If not given, the lastlen(s)axes are used, or all axes ifsis also not specified.norm{\u201cbackward\u201d, \u201cortho\u201d, \u201cforward\u201d}, optionalNew in version 1.10.0.Normalization mode (seenumpy.fft). Default is \u201cbackward\u201d.\nIndicates which direction of the forward/backward pair of transforms\nis scaled and with what normalization factor.New in version 1.20.0:The \u201cbackward\u201d, \u201cforward\u201d values were added.Returns:outcomplex ndarrayThe truncated or zero-padded input, transformed along the axes\nindicated byaxes, or by a combination ofsanda,\nas explained in the parameters section above.\nThe length of the last axis transformed will bes[-1]//2+1,\nwhile the remaining transformed axes will have lengths according tos, or unchanged from the input.Raises:ValueErrorIfsandaxeshave different length.IndexErrorIf an element ofaxesis larger than than the number of axes ofa.See alsoirfftnThe inverse ofrfftn, i.e. the inverse of the n-dimensional FFT of real input.fftThe one-dimensional FFT, with definitions and conventions used.rfftThe one-dimensional FFT of real input.fftnThe n-dimensional FFT.rfft2The two-dimensional FFT of real input.NotesThe transform for real input is performed over the last transformation\naxis, as byrfft, then the transform over the remaining axes is\nperformed as byfftn.  The order of the output is as forrfftfor the\nfinal transformation axis, and as forfftnfor the remaining\ntransformation axes.Seefftfor details, definitions and conventions used.Examples>>>a=np.ones((2,2,2))>>>np.fft.rfftn(a)array([[[8.+0.j,  0.+0.j], # may vary[0.+0.j,  0.+0.j]],[[0.+0.j,  0.+0.j],[0.+0.j,  0.+0.j]]])>>>np.fft.rfftn(a,axes=(2,0))array([[[4.+0.j,  0.+0.j], # may vary[4.+0.j,  0.+0.j]],[[0.+0.j,  0.+0.j],[0.+0.j,  0.+0.j]]])", "doc_id": "2105398f-5911-4912-9559-543baffa23fa", "embedding": null, "doc_hash": "5380d0f682330a92d583e779a524741c4d610a1dd3dd57bf790d7593d8c8529a", "extra_info": null, "node_info": {"start": 0, "end": 2799, "_node_type": "1"}, "relationships": {"1": "2c0cf7cf-ff7f-40be-92f3-9b2dc3f32677"}}, "__type__": "1"}, "7d6e7d7f-0152-4baa-aa0d-80b54aa5d71a": {"__data__": {"text": "\u3010Name\u3011Numpy\u3010Chapter\u3011fft\u3010Section\u3011numpy.fft.irfftn\u3010Content\u3011numpy.fft.irfftn#fft.irfftn(a,s=None,axes=None,norm=None)[source]#Computes the inverse ofrfftn.This function computes the inverse of the N-dimensional discrete\nFourier Transform for real input over any number of axes in an\nM-dimensional array by means of the Fast Fourier Transform (FFT).  In\nother words,irfftn(rfftn(a),a.shape)==ato within numerical\naccuracy. (Thea.shapeis necessary likelen(a)is forirfft,\nand for the same reason.)The input should be ordered in the same way as is returned byrfftn,\ni.e. as forirfftfor the final transformation axis, and as forifftnalong all the other axes.Parameters:aarray_likeInput array.ssequence of ints, optionalShape (length of each transformed axis) of the output\n(s[0]refers to axis 0,s[1]to axis 1, etc.).sis also the\nnumber of input points used along this axis, except for the last axis,\nwheres[-1]//2+1points of the input are used.\nAlong any axis, if the shape indicated bysis smaller than that of\nthe input, the input is cropped.  If it is larger, the input is padded\nwith zeros. Ifsis not given, the shape of the input along the axes\nspecified by axes is used. Except for the last axis which is taken to\nbe2*(m-1)wheremis the length of the input along that axis.axessequence of ints, optionalAxes over which to compute the inverse FFT. If not given, the lastlen(s)axes are used, or all axes ifsis also not specified.\nRepeated indices inaxesmeans that the inverse transform over that\naxis is performed multiple times.norm{\u201cbackward\u201d, \u201cortho\u201d, \u201cforward\u201d}, optionalNew in version 1.10.0.Normalization mode (seenumpy.fft). Default is \u201cbackward\u201d.\nIndicates which direction of the forward/backward pair of transforms\nis scaled and with what normalization factor.New in version 1.20.0:The \u201cbackward\u201d, \u201cforward\u201d values were added.Returns:outndarrayThe truncated or zero-padded input, transformed along the axes\nindicated byaxes, or by a combination ofsora,\nas explained in the parameters section above.\nThe length of each transformed axis is as given by the corresponding\nelement ofs, or the length of the input in every axis except for the\nlast one ifsis not given.  In the final transformed axis the length\nof the output whensis not given is2*(m-1)wheremis the\nlength of the final transformed axis of the input.  To get an odd\nnumber of output points in the final axis,smust be specified.Raises:ValueErrorIfsandaxeshave different length.IndexErrorIf an element ofaxesis larger than than the number of axes ofa.See alsorfftnThe forward n-dimensional FFT of real input, of whichifftnis the inverse.fftThe one-dimensional FFT, with definitions and conventions used.irfftThe inverse of the one-dimensional FFT of real input.irfft2The inverse of the two-dimensional FFT of real input.NotesSeefftfor definitions and conventions used.Seerfftfor definitions and conventions used for real input.The correct interpretation of the hermitian input depends on the shape of\nthe original data, as given bys. This is because each input shape could\ncorrespond to either an odd or even length signal. By default,irfftnassumes an even output length which puts the last entry at the Nyquist\nfrequency; aliasing with its symmetric counterpart. When performing the\nfinal complex to real transform, the last value is thus treated as purely\nreal. To avoid losing information, the correct shape of the real inputmustbe", "doc_id": "7d6e7d7f-0152-4baa-aa0d-80b54aa5d71a", "embedding": null, "doc_hash": "d38e2d2d4261056f34e5a3ce40eaeff382d2ece4ed25f1e7af1fcd15dae6dbdb", "extra_info": null, "node_info": {"start": 0, "end": 3394, "_node_type": "1"}, "relationships": {"1": "c0114562-c484-4d04-a492-b936b4801e97", "3": "0767020e-4325-49e6-9f47-a24807d74237"}}, "__type__": "1"}, "0767020e-4325-49e6-9f47-a24807d74237": {"__data__": {"text": "inverse.fftThe one-dimensional FFT, with definitions and conventions used.irfftThe inverse of the one-dimensional FFT of real input.irfft2The inverse of the two-dimensional FFT of real input.NotesSeefftfor definitions and conventions used.Seerfftfor definitions and conventions used for real input.The correct interpretation of the hermitian input depends on the shape of\nthe original data, as given bys. This is because each input shape could\ncorrespond to either an odd or even length signal. By default,irfftnassumes an even output length which puts the last entry at the Nyquist\nfrequency; aliasing with its symmetric counterpart. When performing the\nfinal complex to real transform, the last value is thus treated as purely\nreal. To avoid losing information, the correct shape of the real inputmustbe given.Examples>>>a=np.zeros((3,2,2))>>>a[0,0,0]=3*2*2>>>np.fft.irfftn(a)array([[[1.,  1.],[1.,  1.]],[[1.,  1.],[1.,  1.]],[[1.,  1.],[1.,  1.]]])", "doc_id": "0767020e-4325-49e6-9f47-a24807d74237", "embedding": null, "doc_hash": "6d1b2794843ca6a0c2313e31bc26913b3c61331f0a114974a959dbfb69b80e34", "extra_info": null, "node_info": {"start": 2589, "end": 3541, "_node_type": "1"}, "relationships": {"1": "c0114562-c484-4d04-a492-b936b4801e97", "2": "7d6e7d7f-0152-4baa-aa0d-80b54aa5d71a"}}, "__type__": "1"}, "c773aabc-06b5-419a-9229-1af15abb87ec": {"__data__": {"text": "\u3010Name\u3011Numpy\u3010Chapter\u3011fft\u3010Section\u3011numpy.fft.hfft\u3010Content\u3011numpy.fft.hfft#fft.hfft(a,n=None,axis=-1,norm=None)[source]#Compute the FFT of a signal that has Hermitian symmetry, i.e., a real\nspectrum.Parameters:aarray_likeThe input array.nint, optionalLength of the transformed axis of the output. Fornoutput\npoints,n//2+1input points are necessary.  If the input is\nlonger than this, it is cropped.  If it is shorter than this, it is\npadded with zeros.  Ifnis not given, it is taken to be2*(m-1)wheremis the length of the input along the axis specified byaxis.axisint, optionalAxis over which to compute the FFT. If not given, the last\naxis is used.norm{\u201cbackward\u201d, \u201cortho\u201d, \u201cforward\u201d}, optionalNew in version 1.10.0.Normalization mode (seenumpy.fft). Default is \u201cbackward\u201d.\nIndicates which direction of the forward/backward pair of transforms\nis scaled and with what normalization factor.New in version 1.20.0:The \u201cbackward\u201d, \u201cforward\u201d values were added.Returns:outndarrayThe truncated or zero-padded input, transformed along the axis\nindicated byaxis, or the last one ifaxisis not specified.\nThe length of the transformed axis isn, or, ifnis not given,2*m-2wheremis the length of the transformed axis of\nthe input. To get an odd number of output points,nmust be\nspecified, for instance as2*m-1in the typical case,Raises:IndexErrorIfaxisis not a valid axis ofa.See alsorfftCompute the one-dimensional FFT for real input.ihfftThe inverse ofhfft.Noteshfft/ihfftare a pair analogous torfft/irfft, but for the\nopposite case: here the signal has Hermitian symmetry in the time\ndomain and is real in the frequency domain. So here it\u2019shfftfor\nwhich you must supply the length of the result if it is to be odd.even:ihfft(hfft(a,2*len(a)-2))==a, within roundoff error,odd:ihfft(hfft(a,2*len(a)-1))==a, within roundoff error.The correct interpretation of the hermitian input depends on the length of\nthe original data, as given byn. This is because each input shape could\ncorrespond to either an odd or even length signal. By default,hfftassumes an even output length which puts the last entry at the Nyquist\nfrequency; aliasing with its symmetric counterpart. By Hermitian symmetry,\nthe value is thus treated as purely real. To avoid losing information, the\nshape of the full signalmustbe given.Examples>>>signal=np.array([1,2,3,4,3,2])>>>np.fft.fft(signal)array([15.+0.j,  -4.+0.j,   0.+0.j,  -1.-0.j,   0.+0.j,  -4.+0.j]) # may vary>>>np.fft.hfft(signal[:4])# Input first half of signalarray([15.,  -4.,   0.,  -1.,   0.,  -4.])>>>np.fft.hfft(signal,6)# Input entire signal and truncatearray([15.,  -4.,   0.,  -1.,   0.,  -4.])>>>signal=np.array([[1,1.j],[-1.j,2]])>>>np.conj(signal.T)-signal# check Hermitian symmetryarray([[ 0.-0.j,  -0.+0.j], # may vary[ 0.+0.j,  0.-0.j]])>>>freq_spectrum=np.fft.hfft(signal)>>>freq_spectrumarray([[ 1.,", "doc_id": "c773aabc-06b5-419a-9229-1af15abb87ec", "embedding": null, "doc_hash": "a01a03d4d4a5476b20c30a78db563cd832efc978da35508ec008ee45b65542ab", "extra_info": null, "node_info": {"start": 0, "end": 2830, "_node_type": "1"}, "relationships": {"1": "bb912eaa-9ced-4ba5-a2fe-859c4614dc29", "3": "58fe08ae-4c47-42ed-a60e-999b0c004aae"}}, "__type__": "1"}, "58fe08ae-4c47-42ed-a60e-999b0c004aae": {"__data__": {"text": "Input first half of signalarray([15.,  -4.,   0.,  -1.,   0.,  -4.])>>>np.fft.hfft(signal,6)# Input entire signal and truncatearray([15.,  -4.,   0.,  -1.,   0.,  -4.])>>>signal=np.array([[1,1.j],[-1.j,2]])>>>np.conj(signal.T)-signal# check Hermitian symmetryarray([[ 0.-0.j,  -0.+0.j], # may vary[ 0.+0.j,  0.-0.j]])>>>freq_spectrum=np.fft.hfft(signal)>>>freq_spectrumarray([[ 1.,  1.],[ 2., -2.]])", "doc_id": "58fe08ae-4c47-42ed-a60e-999b0c004aae", "embedding": null, "doc_hash": "5ec5aea8811876d84fdec825ace4f0a8b7f0ab11630223b721d2ccd522afc865", "extra_info": null, "node_info": {"start": 2449, "end": 2848, "_node_type": "1"}, "relationships": {"1": "bb912eaa-9ced-4ba5-a2fe-859c4614dc29", "2": "c773aabc-06b5-419a-9229-1af15abb87ec"}}, "__type__": "1"}, "fb2e8bd0-e88b-4d7e-bc30-4e284ead9f38": {"__data__": {"text": "\u3010Name\u3011Numpy\u3010Chapter\u3011fft\u3010Section\u3011numpy.fft.ihfft\u3010Content\u3011numpy.fft.ihfft#fft.ihfft(a,n=None,axis=-1,norm=None)[source]#Compute the inverse FFT of a signal that has Hermitian symmetry.Parameters:aarray_likeInput array.nint, optionalLength of the inverse FFT, the number of points along\ntransformation axis in the input to use.  Ifnis smaller than\nthe length of the input, the input is cropped.  If it is larger,\nthe input is padded with zeros. Ifnis not given, the length of\nthe input along the axis specified byaxisis used.axisint, optionalAxis over which to compute the inverse FFT. If not given, the last\naxis is used.norm{\u201cbackward\u201d, \u201cortho\u201d, \u201cforward\u201d}, optionalNew in version 1.10.0.Normalization mode (seenumpy.fft). Default is \u201cbackward\u201d.\nIndicates which direction of the forward/backward pair of transforms\nis scaled and with what normalization factor.New in version 1.20.0:The \u201cbackward\u201d, \u201cforward\u201d values were added.Returns:outcomplex ndarrayThe truncated or zero-padded input, transformed along the axis\nindicated byaxis, or the last one ifaxisis not specified.\nThe length of the transformed axis isn//2+1.See alsohfft,irfftNoteshfft/ihfftare a pair analogous torfft/irfft, but for the\nopposite case: here the signal has Hermitian symmetry in the time\ndomain and is real in the frequency domain. So here it\u2019shfftfor\nwhich you must supply the length of the result if it is to be odd:even:ihfft(hfft(a,2*len(a)-2))==a, within roundoff error,odd:ihfft(hfft(a,2*len(a)-1))==a, within roundoff error.Examples>>>spectrum=np.array([15,-4,0,-1,0,-4])>>>np.fft.ifft(spectrum)array([1.+0.j,  2.+0.j,  3.+0.j,  4.+0.j,  3.+0.j,  2.+0.j]) # may vary>>>np.fft.ihfft(spectrum)array([ 1.-0.j,  2.-0.j,  3.-0.j,  4.-0.j]) # may vary", "doc_id": "fb2e8bd0-e88b-4d7e-bc30-4e284ead9f38", "embedding": null, "doc_hash": "ce952c90247fa4f0a399d2907ad638e64c8f29e092b97a863d61ef77f3b75f99", "extra_info": null, "node_info": {"start": 0, "end": 1726, "_node_type": "1"}, "relationships": {"1": "dafb0b0d-fafc-4624-aa61-6be42ec512e0"}}, "__type__": "1"}, "7311894b-ca9b-42eb-a466-32ea75773860": {"__data__": {"text": "\u3010Name\u3011Numpy\u3010Chapter\u3011fft\u3010Section\u3011numpy.fft.fftfreq\u3010Content\u3011numpy.fft.fftfreq#fft.fftfreq(n,d=1.0)[source]#Return the Discrete Fourier Transform sample frequencies.The returned float arrayfcontains the frequency bin centers in cycles\nper unit of the sample spacing (with zero at the start).  For instance, if\nthe sample spacing is in seconds, then the frequency unit is cycles/second.Given a window lengthnand a sample spacingd:f=[0,1,...,n/2-1,-n/2,...,-1]/(d*n)ifnisevenf=[0,1,...,(n-1)/2,-(n-1)/2,...,-1]/(d*n)ifnisoddParameters:nintWindow length.dscalar, optionalSample spacing (inverse of the sampling rate). Defaults to 1.Returns:fndarrayArray of lengthncontaining the sample frequencies.Examples>>>signal=np.array([-2,8,6,4,1,0,3,5],dtype=float)>>>fourier=np.fft.fft(signal)>>>n=signal.size>>>timestep=0.1>>>freq=np.fft.fftfreq(n,d=timestep)>>>freqarray([ 0.  ,  1.25,  2.5 , ..., -3.75, -2.5 , -1.25])", "doc_id": "7311894b-ca9b-42eb-a466-32ea75773860", "embedding": null, "doc_hash": "c3b083ea44b7442fd1c95fe8e892faf4f77cfa1afe3b9bbfd2cd18c35fda55c7", "extra_info": null, "node_info": {"start": 0, "end": 907, "_node_type": "1"}, "relationships": {"1": "b5d1a0c7-82fd-4b01-a6ad-ad6a4f597092"}}, "__type__": "1"}, "4db49a9a-30bf-4cc1-9975-09e14a8e2946": {"__data__": {"text": "\u3010Name\u3011Numpy\u3010Chapter\u3011fft\u3010Section\u3011numpy.fft.rfftfreq\u3010Content\u3011numpy.fft.rfftfreq#fft.rfftfreq(n,d=1.0)[source]#Return the Discrete Fourier Transform sample frequencies\n(for usage with rfft, irfft).The returned float arrayfcontains the frequency bin centers in cycles\nper unit of the sample spacing (with zero at the start).  For instance, if\nthe sample spacing is in seconds, then the frequency unit is cycles/second.Given a window lengthnand a sample spacingd:f=[0,1,...,n/2-1,n/2]/(d*n)ifnisevenf=[0,1,...,(n-1)/2-1,(n-1)/2]/(d*n)ifnisoddUnlikefftfreq(but likescipy.fftpack.rfftfreq)\nthe Nyquist frequency component is considered to be positive.Parameters:nintWindow length.dscalar, optionalSample spacing (inverse of the sampling rate). Defaults to 1.Returns:fndarrayArray of lengthn//2+1containing the sample frequencies.Examples>>>signal=np.array([-2,8,6,4,1,0,3,5,-3,4],dtype=float)>>>fourier=np.fft.rfft(signal)>>>n=signal.size>>>sample_rate=100>>>freq=np.fft.fftfreq(n,d=1./sample_rate)>>>freqarray([  0.,  10.,  20., ..., -30., -20., -10.])>>>freq=np.fft.rfftfreq(n,d=1./sample_rate)>>>freqarray([  0.,  10.,  20.,  30.,  40.,  50.])", "doc_id": "4db49a9a-30bf-4cc1-9975-09e14a8e2946", "embedding": null, "doc_hash": "de487aede9b9c9aaf38811c989f9ef155a2a74085ba673067bf81d3fde67491e", "extra_info": null, "node_info": {"start": 0, "end": 1139, "_node_type": "1"}, "relationships": {"1": "2d44903b-29ef-40b0-9263-33869ee118b1"}}, "__type__": "1"}, "4568c442-3a88-48d5-997d-c73633f1c10f": {"__data__": {"text": "\u3010Name\u3011Numpy\u3010Chapter\u3011fft\u3010Section\u3011numpy.fft.fftshift\u3010Content\u3011numpy.fft.fftshift#fft.fftshift(x,axes=None)[source]#Shift the zero-frequency component to the center of the spectrum.This function swaps half-spaces for all axes listed (defaults to all).\nNote thaty[0]is the Nyquist component only iflen(x)is even.Parameters:xarray_likeInput array.axesint or shape tuple, optionalAxes over which to shift.  Default is None, which shifts all axes.Returns:yndarrayThe shifted array.See alsoifftshiftThe inverse offftshift.Examples>>>freqs=np.fft.fftfreq(10,0.1)>>>freqsarray([ 0.,  1.,  2., ..., -3., -2., -1.])>>>np.fft.fftshift(freqs)array([-5., -4., -3., -2., -1.,  0.,  1.,  2.,  3.,  4.])Shift the zero-frequency component only along the second axis:>>>freqs=np.fft.fftfreq(9,d=1./9).reshape(3,3)>>>freqsarray([[ 0.,  1.,  2.],[ 3.,  4., -4.],[-3., -2., -1.]])>>>np.fft.fftshift(freqs,axes=(1,))array([[ 2.,  0.,  1.],[-4.,  3.,  4.],[-1., -3., -2.]])", "doc_id": "4568c442-3a88-48d5-997d-c73633f1c10f", "embedding": null, "doc_hash": "1b623ed160b4693126792b8af52f8fadfd3bdc17068140c2bd9e59cc18d86e12", "extra_info": null, "node_info": {"start": 0, "end": 947, "_node_type": "1"}, "relationships": {"1": "dfe74ba2-ec55-467a-818a-db46176c3532"}}, "__type__": "1"}, "3ecafc0d-addb-4d49-9533-6bc4b690642b": {"__data__": {"text": "\u3010Name\u3011Numpy\u3010Chapter\u3011fft\u3010Section\u3011numpy.fft.ifftshift\u3010Content\u3011numpy.fft.ifftshift#fft.ifftshift(x,axes=None)[source]#The inverse offftshift. Although identical for even-lengthx, the\nfunctions differ by one sample for odd-lengthx.Parameters:xarray_likeInput array.axesint or shape tuple, optionalAxes over which to calculate.  Defaults to None, which shifts all axes.Returns:yndarrayThe shifted array.See alsofftshiftShift zero-frequency component to the center of the spectrum.Examples>>>freqs=np.fft.fftfreq(9,d=1./9).reshape(3,3)>>>freqsarray([[ 0.,  1.,  2.],[ 3.,  4., -4.],[-3., -2., -1.]])>>>np.fft.ifftshift(np.fft.fftshift(freqs))array([[ 0.,  1.,  2.],[ 3.,  4., -4.],[-3., -2., -1.]])", "doc_id": "3ecafc0d-addb-4d49-9533-6bc4b690642b", "embedding": null, "doc_hash": "4628e7cff58754ad9d908ee071c982bdcdc61568218404233bf6869f225541fc", "extra_info": null, "node_info": {"start": 0, "end": 692, "_node_type": "1"}, "relationships": {"1": "9595da32-3271-476f-93b0-d6a6671b8902"}}, "__type__": "1"}}}